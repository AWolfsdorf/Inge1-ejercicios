

----STARTUP---- (24 June 2021 21:36:33) as /home/nikita/r/f/ingsoft1/Inge1-ejercicios/20-TusLibros-Iteracion-4/CuisUniversity-4532.image!


TestCase subclass: #CheckOutTest
	instanceVariableNames: 'creditCardNumber cardOwner validCreditCard book1 book2 expiredCreditCard currentMonth today expiredThisMonthCreditCard mockAlwaysStolenCardMerchantProcessor mockAlwaysOkMerchantProcessor mockAlwaysFakeCardMerchantProcessor mockAlwaysWithoutCreditCardMerchantProcessor invalidNumberCreditCard emptyOwnerCreditCard emptyOwnerCreditCard2 stubs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #CheckOutTest category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:15'!
TestCase subclass: #CheckOutTest
	instanceVariableNames: 'creditCardNumber cardOwner validCreditCard book1 book2 expiredCreditCard currentMonth today expiredThisMonthCreditCard mockAlwaysStolenCardMerchantProcessor mockAlwaysOkMerchantProcessor mockAlwaysFakeCardMerchantProcessor mockAlwaysWithoutCreditCardMerchantProcessor invalidNumberCreditCard emptyOwnerCreditCard emptyOwnerCreditCard2 stubs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!CheckOutTest methodsFor: 'valid checkout' stamp: 'nz 6/23/2021 01:25:02'!
 test02CheckoutACartWithOneItem

	| aCashier bookPrices cart receipt receiptBook |
	
	bookPrices _ PriceList new.
	bookPrices set: book1 price: 124.
	
	receiptBook _ OrderedCollection new.
	
	aCashier _ Cashier withPrices: bookPrices receiptBook: receiptBook merchantProcessor: mockAlwaysOkMerchantProcessor.
	
	cart _ ShoppingCart new.
	cart add: 1 of: book1.
	
	receipt _ aCashier checkOut: cart payingWith: validCreditCard on: today.
	
	self assert: 124 equals: receipt total.
	self assert: 1 equals: receipt items size.
	self assert: 1 equals: (receipt items occurrencesOf: book1).
	
	self assert: receipt isTheOnlyIn: receiptBook.! !
!CheckOutTest methodsFor: 'valid checkout' stamp: 'nz 6/23/2021 01:27:57'!
                       test03CheckoutACartWithMultipleItems

	| aCashier bookPrices cart receipt receiptBook |
	
	bookPrices _ PriceList new.
	bookPrices set: book1 price: 100.
	bookPrices set: book2 price: 25.
	
	receiptBook _ OrderedCollection new.
	
	aCashier _ Cashier withPrices: bookPrices receiptBook: receiptBook merchantProcessor: mockAlwaysOkMerchantProcessor.
	
	cart _ ShoppingCart new.
	cart add: 1 of: book1.
	cart add: 2 of: book2.
	
	receipt _ aCashier checkOut: cart payingWith: validCreditCard on: today.
	
	self assert: 150 equals: receipt total.
	self assert: 3 equals: receipt items size.
	self assert: 1 equals: (receipt items occurrencesOf: book1).
	self assert: 2 equals: (receipt items occurrencesOf: book2).

	self assert: receipt isTheOnlyIn: receiptBook.
	! !
!CheckOutTest methodsFor: 'assertions' stamp: 'AW 6/14/2021 21:59:15'!
                            assert: anItem isTheOnlyIn: aCollection

	self assert: aCollection size equals: 1.
	self assert: aCollection includes: anItem! !
!CheckOutTest methodsFor: 'card validation' stamp: 'nz 6/16/2021 00:42:38'!
                   test05CheckoutWithExpiredCardShouldRaiseError

	| aCashier bookPrices cart receiptBook |
	
	bookPrices _ PriceList new.
	bookPrices set: book1 price: 50.
	
	receiptBook _ OrderedCollection new.
	
	aCashier _ Cashier withPrices: bookPrices receiptBook: receiptBook merchantProcessor: mockAlwaysOkMerchantProcessor .
	
	cart _ ShoppingCart new.
	cart add: 3 of: book1.
	
	self should: [ aCashier checkOut: cart payingWith: expiredCreditCard on: today. ]
		raise: Error - MessageNotUnderstood
		withMessageText: Cashier cantCheckWithExpiredCardErrorDescription.
		
	self assert: receiptBook isEmpty.! !
!CheckOutTest methodsFor: 'card validation' stamp: 'nz 6/16/2021 00:45:20'!
                            test06CheckoutWithCardExpiredThisMonthShouldRaiseError

	| aCashier bookPrices cart receiptBook |
	
	bookPrices _ PriceList new.
	bookPrices set: book1 price: 50.
	
	receiptBook _ OrderedCollection new.
	
	aCashier _ Cashier withPrices: bookPrices receiptBook: receiptBook merchantProcessor: mockAlwaysOkMerchantProcessor.
	
	cart _ ShoppingCart new.
	cart add: 3 of: book1.
	
	self should: [ aCashier checkOut: cart payingWith: expiredThisMonthCreditCard on: today. ]
		raise: Error - MessageNotUnderstood
		withMessageText: Cashier cantCheckWithExpiredCardErrorDescription.
		
	self assert: receiptBook isEmpty.! !
!CheckOutTest methodsFor: 'card validation' stamp: 'nz 6/16/2021 00:48:37'!
           test10CheckoutWithInvalidCardNumberShouldRaiseError

	| aCashier bookPrices cart receiptBook |
	
	bookPrices _ PriceList new.
	bookPrices set: book1 price: 50.
	
	receiptBook _ OrderedCollection new.
	
	aCashier _ Cashier withPrices: bookPrices receiptBook: receiptBook merchantProcessor: mockAlwaysOkMerchantProcessor.
	
	cart _ ShoppingCart new.
	cart add: 3 of: book1.
	
	self should: [ aCashier checkOut: cart payingWith: invalidNumberCreditCard on: today. ]
		raise: Error - MessageNotUnderstood
		withMessageText: Cashier invalidCreditCardNumberErrorDescription.
		
	self assert: receiptBook isEmpty.! !
!CheckOutTest methodsFor: 'card validation' stamp: 'nz 6/16/2021 00:50:15'!
                  test11CheckoutWithEmptyCardOwnerNameShouldRaiseError

	| aCashier bookPrices cart receiptBook |
	
	bookPrices _ PriceList new.
	bookPrices set: book1 price: 50.
	
	receiptBook _ OrderedCollection new.
	
	aCashier _ Cashier withPrices: bookPrices receiptBook: receiptBook merchantProcessor: mockAlwaysOkMerchantProcessor.
	
	cart _ ShoppingCart new.
	cart add: 3 of: book1.
	
	self should: [ aCashier checkOut: cart payingWith: emptyOwnerCreditCard on: today. ]
		raise: Error - MessageNotUnderstood
		withMessageText: Cashier invalidCreditCardOwnerNameErrorDescription.
		
	self assert: receiptBook isEmpty.! !
!CheckOutTest methodsFor: 'card validation' stamp: 'nz 6/16/2021 00:50:50'!
                 test12CheckoutWithBlankCardOwnerNameShouldRaiseError

	| aCashier bookPrices cart receiptBook |
	
	bookPrices _ PriceList new.
	bookPrices set: book1 price: 50.
	
	receiptBook _ OrderedCollection new.
	
	aCashier _ Cashier withPrices: bookPrices receiptBook: receiptBook merchantProcessor: mockAlwaysOkMerchantProcessor.
	
	cart _ ShoppingCart new.
	cart add: 3 of: book1.
	
	self should: [ aCashier checkOut: cart payingWith: emptyOwnerCreditCard2 on: today. ]
		raise: Error - MessageNotUnderstood
		withMessageText: Cashier invalidCreditCardOwnerNameErrorDescription.
		
	self assert: receiptBook isEmpty.! !
!CheckOutTest methodsFor: 'shopping cart validation' stamp: 'nz 6/16/2021 00:46:51'!
       test01CheckoutEmptyCartShouldRaiseError

	| aCashier bookPrices cart  receiptBook |
	
	bookPrices _ PriceList new.
	
	receiptBook _ OrderedCollection new.
	
	aCashier _ Cashier withPrices: bookPrices receiptBook: receiptBook merchantProcessor: mockAlwaysOkMerchantProcessor .
	
	cart _ ShoppingCart new.
	
	self should: [ aCashier checkOut: cart payingWith: validCreditCard on: today. ]
		raise: Error - MessageNotUnderstood
		withMessageText: Cashier cantCheckoutEmptyCartErrorDescription.
		
	self assert: receiptBook isEmpty.! !
!CheckOutTest methodsFor: 'shopping cart validation' stamp: 'nz 6/16/2021 00:42:03'!
                       test04CheckoutItemWithoutPricesShouldRaiseError

	| aCashier bookPrices cart receiptBook |
	
	bookPrices _ PriceList new.
	receiptBook _ OrderedCollection new.
	
	aCashier _ Cashier withPrices: bookPrices receiptBook: receiptBook merchantProcessor: mockAlwaysOkMerchantProcessor.
	
	cart _ ShoppingCart new.
	cart add: 3 of: book1.
	
	self should: [ aCashier checkOut: cart payingWith: validCreditCard on: today. ]
		raise: Error - MessageNotUnderstood
		withMessageText: Cashier cantCheckoutItemWithNoPriceForItErrorDescription.
		
	self assert: receiptBook isEmpty.! !
!CheckOutTest methodsFor: 'setUp/tearDown' stamp: 'AW 6/24/2021 00:23:52' overrides: 16927572!
      setUp

	today _ FixedGregorianDate today.
	currentMonth _ today monthOfYear.
	
	creditCardNumber _ '4182418241824182'.
	cardOwner _ 'PEPE SANCHEZ'.

	stubs := TestStubs new.

	validCreditCard _ CreditCard
		number: creditCardNumber
		owner: cardOwner
		expiration: currentMonth next.
	
	expiredCreditCard _ CreditCard
		number: creditCardNumber
		owner: cardOwner
		expiration: currentMonth previous.
		
	expiredThisMonthCreditCard _ CreditCard
		number: creditCardNumber
		owner: cardOwner
		expiration: currentMonth.
		
	invalidNumberCreditCard _ stubs invalidNumberCreditCard.
		
	emptyOwnerCreditCard _ CreditCard
		number: creditCardNumber
		owner: ''
		expiration: currentMonth next.
		
	emptyOwnerCreditCard2 _ CreditCard
		number: creditCardNumber
		owner: '            '
		expiration: currentMonth next.
		
	book1 := stubs book1.
	book2 := stubs book2.
	
	mockAlwaysStolenCardMerchantProcessor _ MockAlwaysStolenCardMerchantProcessor new.
	mockAlwaysOkMerchantProcessor _ stubs mockAlwaysOkMerchantProcessor: stubs timeProvider.
	mockAlwaysFakeCardMerchantProcessor _ MockAlwaysFakeCardMerchantProcessor new.
	mockAlwaysWithoutCreditCardMerchantProcessor _ MockAlwaysWithoutCreditCardMerchantProcessor new.! !
!CheckOutTest methodsFor: 'merchant processor' stamp: 'nz 6/16/2021 00:46:43'!
              test07CheckoutWithStolenCardShouldRaiseError

	| aCashier bookPrices cart receiptBook |
	
	bookPrices _ PriceList new.
	bookPrices set: book1 price: 50.
	
	receiptBook _ OrderedCollection new.
	
	aCashier _ Cashier withPrices: bookPrices receiptBook: receiptBook merchantProcessor: mockAlwaysStolenCardMerchantProcessor.
	
	cart _ ShoppingCart new.
	cart add: 3 of: book1.
	
	self should: [ aCashier checkOut: cart payingWith: validCreditCard on: today. ]
		raise: Error - MessageNotUnderstood
		withMessageText: MerchantProcessor stolenCreditCardErrorDescription.
		
	self assert: receiptBook isEmpty.! !
!CheckOutTest methodsFor: 'merchant processor' stamp: 'nz 6/16/2021 00:47:45'!
                   test08CheckoutWithFakeCardShouldRaiseError

	| aCashier bookPrices cart receiptBook |
	
	bookPrices _ PriceList new.
	bookPrices set: book1 price: 50.
	
	receiptBook _ OrderedCollection new.
	
	aCashier _ Cashier withPrices: bookPrices receiptBook: receiptBook merchantProcessor: mockAlwaysFakeCardMerchantProcessor.
	
	cart _ ShoppingCart new.
	cart add: 3 of: book1.
	
	self should: [ aCashier checkOut: cart payingWith: validCreditCard on: today. ]
		raise: Error - MessageNotUnderstood
		withMessageText: MerchantProcessor fakeCreditCardErrorDescription.
		
	self assert: receiptBook isEmpty.! !
!CheckOutTest methodsFor: 'merchant processor' stamp: 'nz 6/16/2021 00:47:36'!
                         test09CheckoutWithInsufficientFundsShouldRaiseError

	| aCashier bookPrices cart receiptBook |
	
	bookPrices _ PriceList new.
	bookPrices set: book1 price: 50.
	
	receiptBook _ OrderedCollection new.
	
	aCashier _ Cashier withPrices: bookPrices receiptBook: receiptBook merchantProcessor: mockAlwaysWithoutCreditCardMerchantProcessor.
	
	cart _ ShoppingCart new.
	cart add: 3 of: book1.
	
	self should: [ aCashier checkOut: cart payingWith: validCreditCard on: today. ]
		raise: Error - MessageNotUnderstood
		withMessageText: MerchantProcessor insufficientFundsCreditCardErrorDescription.
		
	self assert: receiptBook isEmpty.! !

TestCase subclass: #PriceListTest
	instanceVariableNames: 'book1 book2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #PriceListTest category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:15'!
TestCase subclass: #PriceListTest
	instanceVariableNames: 'book1 book2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!PriceListTest methodsFor: 'price validation' stamp: 'nz 6/16/2021 01:25:23'!
   test01AddItemWithNegativePriceShouldRaiseError

	| priceList |
	
	priceList _ PriceList new.
	
	self should: [ priceList set: book1 price: -100.]
		raise: Error - MessageNotUnderstood
		withMessageText: PriceList itemPriceMustBePositiveErrorDescription.! !
!PriceListTest methodsFor: 'price validation' stamp: 'nz 6/16/2021 01:25:37'!
                 test02AddItemWithZeroPriceShouldRaiseError

	| priceList |
	
	priceList _ PriceList new.
	
	self should: [ priceList set: book1 price: 0.]
		raise: Error - MessageNotUnderstood
		withMessageText: PriceList itemPriceMustBePositiveErrorDescription.! !
!PriceListTest methodsFor: 'setUp/tearDown' stamp: 'nz 6/16/2021 01:15:07' overrides: 16927572!
      setUp
	
	book1 := 'ISBN1'.
	book2 := 'ISBN2'.! !

TestCase subclass: #ShopTest
	instanceVariableNames: 'creditCard1 stubs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #ShopTest category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:15'!
TestCase subclass: #ShopTest
	instanceVariableNames: 'creditCard1 stubs'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!ShopTest methodsFor: 'cart creation and listing' stamp: 'AW 6/24/2021 01:32:59'!
        test01InvalidClientShallNotPass
	
	| shop |
	
	shop := Shop
		withUserAuthenticator: (MockUserAuthenticator alwaysReturning: false) 
		prices: stubs priceList
		merchantProcessor: stubs mockAlwaysOkMerchantProcessor 
		timeProvider: stubs timeProvider.
	
	self should: [ shop createCartClientId: 3 password: '123'. ]
		raise: Error - MessageNotUnderstood
		withMessageText: Shop incorrectPasswordOrClientIdErrorDescription.	
	
	! !
!ShopTest methodsFor: 'cart creation and listing' stamp: 'AW 6/24/2021 01:37:38'!
                              test02NewCartsAreEmpty
	
	| shop cartId cartItems |
	
	shop := Shop 
		withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) 
		prices: stubs priceList 
		merchantProcessor: stubs mockAlwaysOkMerchantProcessor 
		timeProvider: stubs timeProvider.
	
	cartId := shop createCartClientId: 3 password: '1234'.
	
	cartItems := shop listCart: cartId.
	
	self assert: cartItems isEmpty.! !
!ShopTest methodsFor: 'cart creation and listing' stamp: 'AW 6/24/2021 01:38:17'!
 test03ListCartWithOneItem
	
	| shop cartId cartItems bookIsbn quantity |
	
	shop := Shop 
		withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) 
		prices: stubs priceList 
		merchantProcessor: stubs mockAlwaysOkMerchantProcessor 
		timeProvider: stubs timeProvider.
	
	cartId := shop createCartClientId: 3 password: '1234'.
	
	quantity := 2.
	bookIsbn := 'book_isbn'.
		
	shop add: quantity of: bookIsbn to: cartId.
	
	cartItems := shop listCart: cartId.
	
	self assert: cartItems size equals: 1.
	self assert: cartItems first quantity equals: quantity.
	self assert: cartItems first item equals: bookIsbn.! !
!ShopTest methodsFor: 'cart creation and listing' stamp: 'AW 6/24/2021 01:38:40'!
                           test04ListInvalidCartShouldRaiseError
	
	| shop |
	
	shop := Shop withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) prices: stubs priceList merchantProcessor: stubs mockAlwaysOkMerchantProcessor timeProvider: stubs timeProvider.
	
	self should: [ shop listCart: 15 ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Shop invalidCartIdErrorDescription.
	! !
!ShopTest methodsFor: 'cart creation and listing' stamp: 'AW 6/24/2021 01:39:39'!
             test05AddItemToCartDoesntModifyOtherCarts
	
	| shop bookIsbn cartId1 cartId2 quantity |
	
	shop := Shop withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) prices: stubs priceList merchantProcessor: stubs mockAlwaysOkMerchantProcessor timeProvider: stubs timeProvider.
	
	cartId1 := shop createCartClientId: 3 password: '1234'.
	cartId2 := shop createCartClientId: 4 password: '12345'.
	
	quantity := 2.
	bookIsbn := 'book_isbn'.
		
	shop add: quantity of: bookIsbn to: cartId1.
	
	self assert: (shop listCart: cartId2) isEmpty.
	! !
!ShopTest methodsFor: 'cart expiration' stamp: 'nz 6/24/2021 16:25:02'!
                 test14CheckingOutAnExpiredCardShouldFail
	
	| shop cartId password clientId timeProvider |
	
	timeProvider := stubs timeProvider.
	shop := Shop 
		withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) 
		prices: stubs priceList 
		merchantProcessor: stubs mockAlwaysOkMerchantProcessor 
		timeProvider: timeProvider.
		
	clientId := 15.
	password := '123456'.
	
	cartId := shop createCartClientId: clientId password: password.
	
	timeProvider toTheFuture: 31 * minute.
	
	self should: [ shop checkOut: cartId payingWith: stubs validCreditCard ]
		raise: Error - MessageNotUnderstood
		withMessageText: Shop expiredCartErrorDescription.
	
	! !
!ShopTest methodsFor: 'cart expiration' stamp: 'nz 6/24/2021 16:27:57'!
      test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended
	
	| shop cartId password clientId timeProvider |
	
	timeProvider := stubs timeProvider.
	shop := Shop 
		withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) 
		prices: stubs priceList 
		merchantProcessor: stubs mockAlwaysOkMerchantProcessor 
		timeProvider: timeProvider.
		
	clientId := 15.
	password := '123456'.
	
	timeProvider toTheFuture: 31 * minute.
	
	cartId := shop createCartClientId: clientId password: password.
		
	self should: [ shop checkOut: cartId payingWith: stubs validCreditCard ]
		raise: Error - MessageNotUnderstood
		withMessageText: Cashier cantCheckoutEmptyCartErrorDescription.
	
	! !
!ShopTest methodsFor: 'cart expiration' stamp: 'nz 6/24/2021 16:28:15'!
    test16AddingItemsToAnExpiredCartShouldFail
	
	| shop cartId password clientId timeProvider |
	
	timeProvider := stubs timeProvider.
	shop := Shop 
		withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) 
		prices: stubs priceList 
		merchantProcessor: stubs mockAlwaysOkMerchantProcessor 
		timeProvider: timeProvider.
		
	clientId := 15.
	password := '123456'.
	
	cartId := shop createCartClientId: clientId password: password.
	
	timeProvider toTheFuture: 31 * minute.
	
	self should: [ shop add: 12 of: stubs book1 to: cartId ]
		raise: Error - MessageNotUnderstood
		withMessageText: Shop expiredCartErrorDescription.
	
	! !
!ShopTest methodsFor: 'check out and purchase listing' stamp: 'AW 6/24/2021 01:40:21'!
     test06CheckoutInvalidCartIdShouldRaiseError
	
	| shop |
	
	shop := Shop withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) prices: stubs priceList merchantProcessor: stubs mockAlwaysOkMerchantProcessor timeProvider: stubs timeProvider.
	
	self should: [ shop checkOut: 16 payingWith: creditCard1 ]
		raise: Error - MessageNotUnderstood
		withMessageText: Shop invalidCartIdErrorDescription.
	! !
!ShopTest methodsFor: 'check out and purchase listing' stamp: 'AW 6/24/2021 01:40:45'!
           test07CheckoutUsesTheCashier
	
	| shop cartId |
	
	shop := Shop withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) prices: stubs priceList merchantProcessor: stubs mockAlwaysOkMerchantProcessor timeProvider: stubs timeProvider.
	
	cartId := shop createCartClientId: 15 password: '1234'.
	
	self should: [ shop checkOut: cartId payingWith: stubs validCreditCard ]
		raise: Error - MessageNotUnderstood
		withMessageText: Cashier cantCheckoutEmptyCartErrorDescription.
	! !
!ShopTest methodsFor: 'check out and purchase listing' stamp: 'AW 6/24/2021 01:43:21'!
                               test08ListPurchasesOnOnlyOneBuyClient
	
	| shop cartId clientId password purchases |
	
	shop := Shop withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) prices: stubs priceList merchantProcessor: stubs mockAlwaysOkMerchantProcessor timeProvider: stubs timeProvider.
		
	clientId := 15.
	password := '123456'.
	cartId := shop createCartClientId: clientId password: password.
	
	shop add: 2 of: stubs book1 to: cartId.
	
	shop checkOut: cartId payingWith: stubs validCreditCard.
	
	purchases := shop listPurchasesOf: clientId with: password.
	self assert: purchases total equals: 100.
	self assert: purchases items size equals: 2.
	self assert: (purchases items occurrencesOf: stubs book1) equals: 2.
	! !
!ShopTest methodsFor: 'check out and purchase listing' stamp: 'nz 6/24/2021 16:21:59'!
                        test09ListPurchasesOfManyItemsByOneClient
	
	| shop cartId clientId password purchases |
	
	shop := Shop withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) prices: stubs priceList merchantProcessor: stubs mockAlwaysOkMerchantProcessor timeProvider: stubs timeProvider.
		
	clientId := 15.
	password := '123456'.
	cartId := shop createCartClientId: clientId password: password.
	
	shop add: 2 of: stubs book1 to: cartId.
	
	shop add: 1 of: stubs book2 to: cartId.
	
	shop add: 1 of: stubs book3 to: cartId.
	
	shop checkOut: cartId payingWith: stubs validCreditCard.
	
	purchases := shop listPurchasesOf: clientId with: password.
	self assert: purchases total equals: 150.
	self assert: purchases items size equals: 4.
	self assert: (purchases items occurrencesOf: stubs book1) equals: 2.
	self assert: (purchases items occurrencesOf: stubs book2) equals: 1.
	self assert: (purchases items occurrencesOf: stubs book3) equals: 1.
	! !
!ShopTest methodsFor: 'check out and purchase listing' stamp: 'nz 6/24/2021 16:22:34'!
                  test10CheckoutWithInvalidCreditCardShouldFail
	
	| shop cartId clientId password |
	
	shop := Shop withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) prices: stubs priceList merchantProcessor: stubs mockAlwaysOkMerchantProcessor timeProvider: stubs timeProvider.
		
	clientId := 15.
	password := '123456'.
	cartId := shop createCartClientId: clientId password: password.
	
	shop add: 1 of: stubs book1 to: cartId.
	
	self
		should: [ shop
				checkOut: cartId
				payingWith: stubs invalidNumberCreditCard. ]
		raise: Error - MessageNotUnderstood
		withMessageText: Cashier invalidCreditCardNumberErrorDescription.
	! !
!ShopTest methodsFor: 'check out and purchase listing' stamp: 'nz 6/24/2021 16:23:14'!
           test11ListMultiplePurchasesOfTheSameClient
	
	| shop cartId clientId password purchases cartId2 |
	
	shop := Shop withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) prices: stubs priceList merchantProcessor: stubs mockAlwaysOkMerchantProcessor timeProvider: stubs timeProvider.
		
	clientId := 15.
	password := '123456'.
	
	cartId := shop createCartClientId: clientId password: password.
	shop add: 2 of: stubs book1 to: cartId.
	shop add: 1 of: stubs book2 to: cartId.
	shop add: 1 of: stubs book3 to: cartId.
	shop checkOut: cartId payingWith: stubs validCreditCard.
	
	cartId2 := shop createCartClientId: clientId password: password.
	shop add: 1 of: stubs book1 to: cartId2.
	shop add: 1 of: stubs book3 to: cartId2.
	shop checkOut: cartId2 payingWith: stubs validCreditCard.
	
	purchases := shop listPurchasesOf: clientId with: password.
	self assert: 230 equals: purchases total.
	self assert: 6 equals: purchases items size.
	self assert: (purchases items occurrencesOf: stubs book1) equals: 3.
	self assert: (purchases items occurrencesOf: stubs book2) equals: 1.
	self assert: (purchases items occurrencesOf: stubs book3) equals: 2.
	! !
!ShopTest methodsFor: 'check out and purchase listing' stamp: 'nz 6/24/2021 16:23:52'!
                            test12ListPurchasesOfIncorrectPasswordShouldFail
	
	| shop clientId password |
	
	shop := Shop withUserAuthenticator: (MockUserAuthenticator alwaysReturning: false) prices: stubs priceList merchantProcessor: stubs mockAlwaysOkMerchantProcessor timeProvider: stubs timeProvider.
		
	clientId := 15.
	password := '123456'.
	
	self should: [ shop listPurchasesOf: clientId with: password ] 
		raise: Error - MessageNotUnderstood 
		withMessageText: Shop incorrectPasswordOrClientIdErrorDescription.
	! !
!ShopTest methodsFor: 'check out and purchase listing' stamp: 'nz 6/24/2021 16:24:14'!
                    test13ListPurchasesOfDifferentClients
	
	| shop cartId clientId1 clientId2 password client1purchases cartId2 client2purchases |
	
	shop := Shop withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) prices: stubs priceList merchantProcessor: stubs mockAlwaysOkMerchantProcessor timeProvider: stubs timeProvider.
		
	clientId1 := 15.
	clientId2 := 42.
	password := '123456'.
	
	cartId := shop createCartClientId: clientId1 password: password.
	shop add: 2 of: stubs book1 to: cartId.
	shop add: 1 of: stubs book2 to: cartId.
	shop add: 1 of: stubs book3 to: cartId.
	shop checkOut: cartId payingWith: stubs validCreditCard.
	
	cartId2 := shop createCartClientId: clientId2 password: password.
	shop add: 1 of: stubs book1 to: cartId2.
	shop add: 1 of: stubs book3 to: cartId2.
	shop checkOut: cartId2 payingWith: stubs validCreditCard.
	
	client1purchases := shop listPurchasesOf: clientId1 with: password.
	self assert: 150 equals: client1purchases total.
	self assert: 4 equals: client1purchases items size.
	
	client2purchases := shop listPurchasesOf: clientId2 with: password.
	self assert: 80 equals: client2purchases total.
	self assert: 2 equals: client2purchases items size.
	! !
!ShopTest methodsFor: 'setUp/tearDown' stamp: 'nz 6/23/2021 00:46:42' overrides: 16927572!
                    setUp

	stubs := TestStubs new.! !

TestCase subclass: #ShoppingCartTest
	instanceVariableNames: 'book1 book2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #ShoppingCartTest category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:16'!
TestCase subclass: #ShoppingCartTest
	instanceVariableNames: 'book1 book2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!ShoppingCartTest methodsFor: 'quantity errors' stamp: 'AW 6/14/2021 22:06:29'!
            test04AddingANegativeQuantityRaisesError
	| shoppingCart |

	shoppingCart := ShoppingCart new.
	
	self  should: [ shoppingCart add: -2 of: book1. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: ShoppingCart itemQuantityMustBeGreaterThanZeroErrorDescription.
	! !
!ShoppingCartTest methodsFor: 'quantity errors' stamp: 'AW 6/14/2021 22:06:35'!
                             test05AddingZeroQuantityRaisesError
	| shoppingCart |

	shoppingCart := ShoppingCart new.
	
	self  should: [ shoppingCart add: 0 of: book1. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: ShoppingCart itemQuantityMustBeGreaterThanZeroErrorDescription.
	! !
!ShoppingCartTest methodsFor: 'quantity errors' stamp: 'AW 6/14/2021 22:08:22'!
   test06AddingNonIntegerQuantityRaisesError
	| shoppingCart |

	shoppingCart := ShoppingCart new.
	
	self  should: [ shoppingCart add: 1.5 of: book1. ]
		raise: Error - MessageNotUnderstood 
		withMessageText: ShoppingCart itemQuantyMustBeAnIntegerErrorDescription.
	! !
!ShoppingCartTest methodsFor: 'assertions' stamp: 'nz 6/14/2021 19:02:37'!
        assert: shoppingCart has: quantity of: item

	self assert: (shoppingCart entries anySatisfy: [ :anShoppingCartItem | 
		anShoppingCartItem is: quantity of: item.
	] ).! !
!ShoppingCartTest methodsFor: 'adding items' stamp: 'nz 6/14/2021 19:02:37'!
        test01EmptyCartHasNoItems

	| shoppingCart |
	shoppingCart := ShoppingCart new.
	
	self assert: shoppingCart entries size equals: 0. ! !
!ShoppingCartTest methodsFor: 'adding items' stamp: 'nz 6/14/2021 19:02:37'!
          test02AddingAnItemToACart
	| shoppingCart quantity |

	shoppingCart := ShoppingCart new.
	quantity := 1.
	
	shoppingCart add: quantity of: book1.
	
	self assert: shoppingCart entries size equals: 1.
	self assert: shoppingCart has: quantity of: book1.! !
!ShoppingCartTest methodsFor: 'adding items' stamp: 'nz 6/14/2021 19:02:37'!
                     test03AddingMultipleItemsToACart
	| shoppingCart |

	shoppingCart := ShoppingCart new.
	
	shoppingCart add: 1 of: book1.
	shoppingCart add: 2 of: book2.
	
	self assert: shoppingCart entries size equals: 2.
	self assert: shoppingCart has: 1 of: book1.
	self assert: shoppingCart has: 2 of: book2.! !
!ShoppingCartTest methodsFor: 'setUp/tearDown' stamp: 'nz 6/16/2021 00:52:20' overrides: 16927572!
                  setUp
	
	book1 := 'ISBN1'.
	book2 := 'ISBN2'.! !

Object subclass: #Cashier
	instanceVariableNames: 'priceList receiptBook merchantProcessor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #Cashier category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:16'!
Object subclass: #Cashier
	instanceVariableNames: 'priceList receiptBook merchantProcessor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!Cashier methodsFor: 'initialization' stamp: 'AW 6/15/2021 23:05:59'!
               initializePrices: aPriceList receiptBook: aReceiptBook merchantProcessor: aMerchantProcessor  
	
	priceList := aPriceList.
	receiptBook := aReceiptBook.
	merchantProcessor := aMerchantProcessor.! !
!Cashier methodsFor: 'private' stamp: 'nz 6/15/2021 23:47:15'!
                           calculateShoppingCartTotal: aShoppingCart

	^ aShoppingCart entries sum: [ :entry |
		self priceFor: entry.
	] ifEmpty: [
		self error: self class cantCheckoutEmptyCartErrorDescription .
	]! !
!Cashier methodsFor: 'private' stamp: 'nz 6/23/2021 01:34:27'!
createReceiptWithTotal: anAmountOfMoney cart: aShoppingCart 

	| receipt |
	
	receipt _ Receipt withTotal: anAmountOfMoney items: (self getEntriesAsBag: aShoppingCart).
	receiptBook add: receipt.
	
	^receipt .! !
!Cashier methodsFor: 'private' stamp: 'nz 6/23/2021 01:37:45'!
            getEntriesAsBag: aShoppingCart 
	
	| aBag |
	aBag := Bag new.
	
	aShoppingCart entries do: [ :entry | aBag add: entry item withOccurrences: entry quantity ].
	
	^aBag.! !
!Cashier methodsFor: 'private' stamp: 'nz 6/14/2021 18:55:26'!
                      priceFor: aShoppingCartEntry
	
	^(priceList priceFor: aShoppingCartEntry item) * (aShoppingCartEntry quantity).! !
!Cashier methodsFor: 'checkout' stamp: 'nz 6/23/2021 01:31:18'!
             checkOut: aShoppingCart payingWith: aCreditCard on: aGregorianDate  

	| total |

	self assertCanCheckout: aShoppingCart payingWith: aCreditCard on: aGregorianDate.
	
	total _ self calculateShoppingCartTotal: aShoppingCart.

	merchantProcessor debit: total from: aCreditCard. 

	^ self createReceiptWithTotal: total cart: aShoppingCart.
	! !
!Cashier methodsFor: 'validation' stamp: 'nz 6/14/2021 19:30:27'!
        areAllItemsInPriceList: aCollectionOfShoppingCartEntries

	^ aCollectionOfShoppingCartEntries allSatisfy: [ :entry | priceList hasPriceFor: entry item ]! !
!Cashier methodsFor: 'validation' stamp: 'nz 6/14/2021 19:30:27'!
  assertAllItemsInPriceList: aCollectionOfShoppingCartEntries

	(self areAllItemsInPriceList: aCollectionOfShoppingCartEntries)
		ifFalse: [ self error: self class cantCheckoutItemWithNoPriceForItErrorDescription ]
	
	! !
!Cashier methodsFor: 'validation' stamp: 'nz 6/16/2021 00:12:02'!
  assertCanCheckout: aShoppingCart payingWith: aCreditCard on: aGregorianDate

	self assertAllItemsInPriceList: aShoppingCart entries.
	self assertCardIsValid: aCreditCard on: aGregorianDate.! !
!Cashier methodsFor: 'validation' stamp: 'nz 6/16/2021 00:21:41'!
                             assertCardIsValid: aCreditCard on: aGregorianDate 
	
	(aCreditCard isExpiredOn: aGregorianDate) ifTrue: [
		self error: self class cantCheckWithExpiredCardErrorDescription.	
	].
	aCreditCard hasValidNumber ifFalse: [
		self error: self class invalidCreditCardNumberErrorDescription.	
	].
	aCreditCard hasValidOwnerName ifFalse: [
		self error: self class invalidCreditCardOwnerNameErrorDescription.	
	].! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Cashier class
	instanceVariableNames: ''!

!classDefinition: 'Cashier class' category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
Cashier class
	instanceVariableNames: ''!
!Cashier class methodsFor: 'instance creation' stamp: 'AW 6/15/2021 23:06:29'!
                withPrices: aPriceList receiptBook: aReceiptBook merchantProcessor: aMerchantProcessor  
	^self new initializePrices: aPriceList receiptBook: aReceiptBook merchantProcessor: aMerchantProcessor ! !
!Cashier class methodsFor: 'errors' stamp: 'AW 6/14/2021 22:11:12'!
                       cantCheckWithExpiredCardErrorDescription
	^'The card is expired!!'! !
!Cashier class methodsFor: 'errors' stamp: 'nz 6/10/2021 00:21:44'!
                      cantCheckoutEmptyCartErrorDescription
	^'Cannot checkout an empty shopping cart!!'.! !
!Cashier class methodsFor: 'errors' stamp: 'nz 6/14/2021 19:17:37'!
     cantCheckoutItemWithNoPriceForItErrorDescription
	^'Cant checkout item with no price for it!!'.! !
!Cashier class methodsFor: 'errors' stamp: 'nz 6/15/2021 23:55:55'!
                         invalidCreditCardNumberErrorDescription
	^'The credit card number is invalid!!'.! !
!Cashier class methodsFor: 'errors' stamp: 'nz 6/16/2021 00:21:09'!
        invalidCreditCardOwnerNameErrorDescription
	^'Invalid credit card owner name!!'.! !

Object subclass: #CreditCard
	instanceVariableNames: 'number owner expiration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #CreditCard category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
Object subclass: #CreditCard
	instanceVariableNames: 'number owner expiration'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!CreditCard methodsFor: 'initialization' stamp: 'nz 6/10/2021 00:21:00'!
initializeNumber: aCreditCardNumber owner: anOwnerName expiration: anExpirationMonthOfYear 

	number := aCreditCardNumber.
	owner := anOwnerName.
	expiration := anExpirationMonthOfYear.! !
!CreditCard methodsFor: 'validations' stamp: 'nz 6/16/2021 00:17:53'!
                             hasValidNumber
	^number size = 16.! !
!CreditCard methodsFor: 'validations' stamp: 'nz 6/16/2021 00:32:49'!
                    hasValidOwnerName
	^owner withBlanksTrimmed isEmpty not.! !
!CreditCard methodsFor: 'validations' stamp: 'AW 6/14/2021 23:03:42'!
                              isExpiredOn: aGregorianDate 
	
	^expiration <= aGregorianDate monthOfYear.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

CreditCard class
	instanceVariableNames: ''!

!classDefinition: 'CreditCard class' category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
CreditCard class
	instanceVariableNames: ''!
!CreditCard class methodsFor: 'instance creation' stamp: 'nz 6/10/2021 00:20:07'!
             number: aCreditCardNumber owner: anOwnerName expiration: anExpirationMonthOfYear 

	^self new initializeNumber: aCreditCardNumber owner: anOwnerName expiration: anExpirationMonthOfYear ! !

Object subclass: #MerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #MerchantProcessor category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
Object subclass: #MerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!MerchantProcessor methodsFor: 'debit' stamp: 'AW 6/15/2021 23:11:55'!
                  debit: anAmountOfMoney from: aCreditCard
	
	self subclassResponsibility.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

MerchantProcessor class
	instanceVariableNames: ''!

!classDefinition: 'MerchantProcessor class' category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
MerchantProcessor class
	instanceVariableNames: ''!
!MerchantProcessor class methodsFor: 'errors' stamp: 'AW 6/15/2021 23:15:42'!
                              fakeCreditCardErrorDescription
	^'Cannot debit from a fake card!!'.! !
!MerchantProcessor class methodsFor: 'errors' stamp: 'nz 6/16/2021 01:04:01'!
           insufficientFundsCreditCardErrorDescription
	^'Cannot debit from a credit card with insufficient funds!!'.! !
!MerchantProcessor class methodsFor: 'errors' stamp: 'nz 6/16/2021 01:04:04'!
    stolenCreditCardErrorDescription
	^'Cannot debit from stolen credit card!!'.! !

MerchantProcessor subclass: #MockAlwaysFakeCardMerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #MockAlwaysFakeCardMerchantProcessor category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
MerchantProcessor subclass: #MockAlwaysFakeCardMerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!MockAlwaysFakeCardMerchantProcessor methodsFor: 'debit' stamp: 'AW 6/15/2021 23:16:20' overrides: 50332734!
             debit: anAmountOfMoney from: aCreditCard 
	
	^self error: self class fakeCreditCardErrorDescription .! !

MerchantProcessor subclass: #MockAlwaysOkMerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #MockAlwaysOkMerchantProcessor category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
MerchantProcessor subclass: #MockAlwaysOkMerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!MockAlwaysOkMerchantProcessor methodsFor: 'debit' stamp: 'AW 6/15/2021 23:10:31' overrides: 50332734!
            debit: anAmountOfMoney from: aCreditCard ! !

MerchantProcessor subclass: #MockAlwaysStolenCardMerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #MockAlwaysStolenCardMerchantProcessor category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
MerchantProcessor subclass: #MockAlwaysStolenCardMerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!MockAlwaysStolenCardMerchantProcessor methodsFor: 'debit' stamp: 'AW 6/15/2021 23:07:32' overrides: 50332734!
        debit: anAmountOfMoney from: aCreditCard 
	
	^self error: self class stolenCreditCardErrorDescription.! !

MerchantProcessor subclass: #MockAlwaysWithoutCreditCardMerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #MockAlwaysWithoutCreditCardMerchantProcessor category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
MerchantProcessor subclass: #MockAlwaysWithoutCreditCardMerchantProcessor
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!MockAlwaysWithoutCreditCardMerchantProcessor methodsFor: 'debit' stamp: 'AW 6/15/2021 23:30:15' overrides: 50332734!
               debit: anAmountOfMoney from: aCreditCard 
	
	^self error: self class insufficientFundsCreditCardErrorDescription .! !

Object subclass: #MockTimeProvider
	instanceVariableNames: 'now'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #MockTimeProvider category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
Object subclass: #MockTimeProvider
	instanceVariableNames: 'now'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!MockTimeProvider methodsFor: 'time traveling' stamp: 'AW 6/24/2021 00:57:56'!
              toTheFuture: anAmountOfFuture
	now := now next: anAmountOfFuture.! !
!MockTimeProvider methodsFor: 'accessing time' stamp: 'AW 6/24/2021 00:59:41'!
            now
	^now.! !
!MockTimeProvider methodsFor: 'initialization' stamp: 'AW 6/24/2021 00:59:25' overrides: 16896425!
               initialize

	now := GregorianDateTime now.! !

Object subclass: #MockUserAuthenticator
	instanceVariableNames: 'authenticationResponse'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #MockUserAuthenticator category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
Object subclass: #MockUserAuthenticator
	instanceVariableNames: 'authenticationResponse'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!MockUserAuthenticator methodsFor: 'initialization' stamp: 'nz 6/17/2021 21:25:35'!
                            initializeAlwaysReturning: anAuthenticationResponse 
	
	authenticationResponse := anAuthenticationResponse.! !
!MockUserAuthenticator methodsFor: 'as yet unclassified' stamp: 'nz 6/17/2021 21:31:32'!
                        authenticate: aSmallInteger password: aString 
	^authenticationResponse .! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

MockUserAuthenticator class
	instanceVariableNames: ''!

!classDefinition: 'MockUserAuthenticator class' category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
MockUserAuthenticator class
	instanceVariableNames: ''!
!MockUserAuthenticator class methodsFor: 'instance creation' stamp: 'nz 6/17/2021 21:26:42'!
  alwaysReturning: anAuthenticationResponse
	^self new initializeAlwaysReturning: anAuthenticationResponse ! !

Object subclass: #PriceList
	instanceVariableNames: 'prices'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #PriceList category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
Object subclass: #PriceList
	instanceVariableNames: 'prices'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!PriceList methodsFor: 'initialization' stamp: 'nz 6/14/2021 18:59:05' overrides: 16896425!
                         initialize

	prices _ Dictionary new.! !
!PriceList methodsFor: 'accessing' stamp: 'nz 6/14/2021 19:29:04'!
                    hasPriceFor: aBook 
	
	^prices includesKey: aBook.! !
!PriceList methodsFor: 'accessing' stamp: 'nz 6/14/2021 19:00:48'!
       priceFor: aBook 
	
	^prices at: aBook.! !
!PriceList methodsFor: 'set prices' stamp: 'nz 6/16/2021 01:24:12'!
                  set: aBook price: aPrice 
	self assertPriceIsValid: aPrice.
	prices at: aBook put: aPrice.! !
!PriceList methodsFor: 'validation' stamp: 'nz 6/16/2021 01:24:12'!
                              assertPriceIsValid: aPrice

	^ (aPrice > 0) ifFalse: [ self error: self class itemPriceMustBePositiveErrorDescription. ]! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

PriceList class
	instanceVariableNames: ''!

!classDefinition: 'PriceList class' category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
PriceList class
	instanceVariableNames: ''!
!PriceList class methodsFor: 'errors' stamp: 'nz 6/16/2021 01:21:09'!
              itemPriceMustBePositiveErrorDescription
	^'Item price must be positive!!'.! !

Object subclass: #PurchasesSummary
	instanceVariableNames: 'items total'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #PurchasesSummary category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
Object subclass: #PurchasesSummary
	instanceVariableNames: 'items total'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!PurchasesSummary methodsFor: 'accessing' stamp: 'nz 6/23/2021 00:25:00'!
           items
	^ items. ! !
!PurchasesSummary methodsFor: 'accessing' stamp: 'nz 6/23/2021 00:24:54'!
  total
	^total.! !
!PurchasesSummary methodsFor: 'initialization' stamp: 'AW 6/23/2021 23:14:32'!
                               initializeFor: aReceiptCollection

	total := 0.
	items := Bag new.
	aReceiptCollection do: [ :aReceipt | 
		items addAll: aReceipt items.
		total := total + aReceipt total.	
	].
	! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

PurchasesSummary class
	instanceVariableNames: ''!

!classDefinition: 'PurchasesSummary class' category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
PurchasesSummary class
	instanceVariableNames: ''!
!PurchasesSummary class methodsFor: 'instance creation' stamp: 'AW 6/23/2021 23:08:11'!
            for: aReceiptCollection

	^self new initializeFor: aReceiptCollection.! !

Object subclass: #Receipt
	instanceVariableNames: 'total items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #Receipt category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
Object subclass: #Receipt
	instanceVariableNames: 'total items'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!Receipt methodsFor: 'initialization' stamp: 'nz 6/23/2021 01:40:10'!
              initializeWithTotal: aTransactionTotal items: aBagOfItems  
	
	total := aTransactionTotal.
	items := aBagOfItems.! !
!Receipt methodsFor: 'accessing' stamp: 'nz 6/23/2021 01:40:20'!
          items
	^items.! !
!Receipt methodsFor: 'accessing' stamp: 'nz 6/14/2021 18:49:08'!
             total
	^total.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Receipt class
	instanceVariableNames: ''!

!classDefinition: 'Receipt class' category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
Receipt class
	instanceVariableNames: ''!
!Receipt class methodsFor: 'instance creation' stamp: 'nz 6/23/2021 01:39:45'!
                     withTotal: aTransactionTotal items: aBagOfItems  

	^self new initializeWithTotal: aTransactionTotal items: aBagOfItems ! !

Object subclass: #Shop
	instanceVariableNames: 'userAuthenticator carts clientReceipts cashier cartsClients timeProvider cartCreationTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #Shop category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
Object subclass: #Shop
	instanceVariableNames: 'userAuthenticator carts clientReceipts cashier cartsClients timeProvider cartCreationTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!Shop methodsFor: 'facade' stamp: 'AW 6/23/2021 23:34:42'!
                  add: aQuantity of: anItem to: aShoppingCartId
	
	(self getCart: aShoppingCartId) add: aQuantity of: anItem! !
!Shop methodsFor: 'facade' stamp: 'nz 6/24/2021 16:38:48'!
                       checkOut: aShoppingCartId payingWith: aCreditCard 
	"
	Acá quedo expuesta la clase de la tarjeta de credito.
	"
	
	| cart clientId receipt |
	
	cart := self getCart: aShoppingCartId. 
	clientId := self getClientIdOf: aShoppingCartId.
	
	receipt := cashier checkOut: cart payingWith: aCreditCard on: self today.
	
	self registerReceipt: receipt for: clientId.
! !
!Shop methodsFor: 'facade' stamp: 'AW 6/24/2021 00:11:58'!
                          createCartClientId: aClientId password: aPassword

	self authenticateClient: aClientId withPassword: aPassword.

	^self createCartAndGetIdFor: aClientId.! !
!Shop methodsFor: 'facade' stamp: 'nz 6/24/2021 16:39:35'!
        listCart: aShoppingCartId 
	"
	Aca nos quedo expuesta la clase ShoppingCartEntry
	Despues de definir PurchasesSummary pensamos en
	refactorizar el carrito para que use una Bag pero
	no llegamos con ese refactor.
	"
	(self cartExists: aShoppingCartId) ifTrue: [ self error: self class invalidCartIdErrorDescription ]. 
 	
	^self getCartEntries: aShoppingCartId.! !
!Shop methodsFor: 'facade' stamp: 'AW 6/23/2021 23:42:03'!
                         listPurchasesOf: aClientId with: aClientPassword
	
	self authenticateClient: aClientId withPassword: aClientPassword.
	
	^ PurchasesSummary for: (self receiptsFor: aClientId).! !
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/24/2021 00:01:59'!
        assertCartExists: aShoppingCartId
	
	(self cartExists: aShoppingCartId ) 
		ifTrue: [ self error: self class invalidCartIdErrorDescription ].
! !
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/22/2021 22:06:13'!
         cartExists: aShoppingCartId

	^ carts size < aShoppingCartId! !
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/24/2021 01:22:56'!
                           createCartAndGetIdFor: aClientId
	| cartId |
	carts add: ShoppingCart new.
	
	cartId := carts size.
	
	cartsClients at: cartId put: aClientId. 
	cartCreationTimes at: cartId put: timeProvider now.
	
	^ cartId.! !
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/24/2021 01:28:40'!
      getCart: aShoppingCartId

	self assertCartExists: aShoppingCartId.
	self assertCartIsNotExpired: aShoppingCartId.
	
	^ carts at: aShoppingCartId! !
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/22/2021 22:00:46'!
       getCartEntries: aShoppingCartId

	^ (self getCart: aShoppingCartId) entries! !
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/24/2021 00:08:15'!
            getClientIdOf: aCartId 
	
	^cartsClients at: aCartId .! !
!Shop methodsFor: 'cart expiration' stamp: 'AW 6/24/2021 01:17:04'!
  assertCartIsNotExpired: aCartId 
	| cartAge |
	cartAge := self getCartAgeFor: aCartId. 
	(cartAge > self maxCartAge) 
		ifTrue: [ self error: self class expiredCartErrorDescription ].! !
!Shop methodsFor: 'cart expiration' stamp: 'AW 6/24/2021 01:15:39'!
 getCartAgeFor: aCartId
	| cartCreationTime now |
	
	cartCreationTime := self getCreationTime: aCartId.
	now := timeProvider now.
	
	^cartCreationTime distanceTo: now.! !
!Shop methodsFor: 'cart expiration' stamp: 'AW 6/24/2021 01:21:52'!
                  getCreationTime: aCartId 
	^cartCreationTimes at: aCartId.! !
!Shop methodsFor: 'cart expiration' stamp: 'AW 6/24/2021 01:13:32'!
                              maxCartAge

	^ 30 * minute! !
!Shop methodsFor: 'client receipts' stamp: 'AW 6/23/2021 23:41:33'!
                              receiptsFor: aClientId

	^ clientReceipts at: aClientId! !
!Shop methodsFor: 'client receipts' stamp: 'AW 6/23/2021 23:04:08'!
 registerReceipt: aReceipt for: aClientId 
	| receipts |
	receipts := clientReceipts at: aClientId ifAbsentPut: OrderedCollection new.
	
	receipts add: aReceipt.! !
!Shop methodsFor: 'time provider' stamp: 'nz 6/23/2021 01:11:36'!
                          today
	^FixedGregorianDate today.! !
!Shop methodsFor: 'initialization' stamp: 'AW 6/24/2021 01:22:19'!
                        initializeWithUserAuthenticator: anUserAuthenticator prices: aPriceList merchantProcessor: aMerchantProcessor timeProvider: aTimeProvider    
	
	userAuthenticator := anUserAuthenticator.
	carts := OrderedCollection new.
	clientReceipts  := Dictionary new. 
	cartsClients := Dictionary new. 
	cartCreationTimes := Dictionary new. 
	timeProvider := aTimeProvider.		
	cashier := Cashier
		withPrices: aPriceList
		receiptBook: OrderedCollection new
		merchantProcessor: aMerchantProcessor.
		

		
	
		

		! !
!Shop methodsFor: 'user authentication' stamp: 'AW 6/23/2021 23:40:21'!
                              authenticateClient: aClientId withPassword: aPassword
	
	(userAuthenticator authenticate: aClientId password: aPassword) ifFalse: [
		self error: self class incorrectPasswordOrClientIdErrorDescription .
	]! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

Shop class
	instanceVariableNames: ''!

!classDefinition: 'Shop class' category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
Shop class
	instanceVariableNames: ''!
!Shop class methodsFor: 'errors' stamp: 'AW 6/24/2021 00:38:25'!
             expiredCartErrorDescription
	^'The cart is expired!!'.! !
!Shop class methodsFor: 'errors' stamp: 'nz 6/17/2021 21:10:15'!
     incorrectPasswordOrClientIdErrorDescription
	^'Incorrect password or client id!!'.! !
!Shop class methodsFor: 'errors' stamp: 'AW 6/22/2021 21:33:52'!
         invalidCartIdErrorDescription
	^'The cart id is invalid!!'! !
!Shop class methodsFor: 'instance creation' stamp: 'AW 6/24/2021 00:50:00'!
                      withUserAuthenticator: anUserAuthenticator prices: aPriceList merchantProcessor: aMerchantProcessor timeProvider: aTimeProvider    

	^self new initializeWithUserAuthenticator: anUserAuthenticator prices: aPriceList merchantProcessor: aMerchantProcessor timeProvider: aTimeProvider ! !

Object subclass: #ShoppingCart
	instanceVariableNames: 'entries'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #ShoppingCart category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
Object subclass: #ShoppingCart
	instanceVariableNames: 'entries'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!ShoppingCart methodsFor: 'accessing' stamp: 'nz 6/14/2021 19:02:37'!
                   entries
	^entries.! !
!ShoppingCart methodsFor: 'adding' stamp: 'nz 6/14/2021 19:42:41'!
       add: aQuantity of: anItem 

	self assertQuantityIsValid: aQuantity.
	
	entries add: (ShoppingCartEntry for: anItem quantity: aQuantity).! !
!ShoppingCart methodsFor: 'validations' stamp: 'AW 6/10/2021 20:09:49'!
            assertQuantityIsValid: aQuantity

	aQuantity strictlyPositive
		ifFalse: [ self error: self class itemQuantityMustBeGreaterThanZeroErrorDescription ].
	
	aQuantity isInteger
		ifFalse: [ self error: self class itemQuantyMustBeAnIntegerErrorDescription ]! !
!ShoppingCart methodsFor: 'initialization' stamp: 'nz 6/14/2021 19:42:36' overrides: 16896425!
initialize

	entries := OrderedCollection new.! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

ShoppingCart class
	instanceVariableNames: ''!

!classDefinition: 'ShoppingCart class' category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
ShoppingCart class
	instanceVariableNames: ''!
!ShoppingCart class methodsFor: 'errors' stamp: 'nz 6/9/2021 23:47:56'!
             itemQuantityMustBeGreaterThanZeroErrorDescription
	^'Cannot add item with negative quantity!!'.! !
!ShoppingCart class methodsFor: 'errors' stamp: 'AW 6/10/2021 20:05:50'!
                    itemQuantyMustBeAnIntegerErrorDescription
	^'Quanty must be an integer!!'! !

Object subclass: #ShoppingCartEntry
	instanceVariableNames: 'item quantity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #ShoppingCartEntry category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
Object subclass: #ShoppingCartEntry
	instanceVariableNames: 'item quantity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!ShoppingCartEntry methodsFor: 'initialization' stamp: 'AW 6/9/2021 00:31:25'!
initializeFor: anItem quantity: aQuantity 
	
	item := anItem.
	quantity := aQuantity.! !
!ShoppingCartEntry methodsFor: 'accessing' stamp: 'AW 6/9/2021 00:32:01'!
                             item
	
	^item! !
!ShoppingCartEntry methodsFor: 'accessing' stamp: 'AW 6/9/2021 00:32:11'!
     quantity
	
	^quantity! !
!ShoppingCartEntry methodsFor: 'testing' stamp: 'AW 6/9/2021 00:54:31'!
                               is: aQuantity of: anItem 
	^(item = anItem) and: [ quantity = aQuantity ].! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

ShoppingCartEntry class
	instanceVariableNames: ''!

!classDefinition: 'ShoppingCartEntry class' category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
ShoppingCartEntry class
	instanceVariableNames: ''!
!ShoppingCartEntry class methodsFor: 'instance creation' stamp: 'AW 6/9/2021 00:31:03'!
                  for: anItem quantity: aQuantity 

	^self new initializeFor: anItem quantity: aQuantity ! !

Object subclass: #TestStubs
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #TestStubs category: 'Tus-Libros' stamp: 'nz 6/24/2021 21:37:17'!
Object subclass: #TestStubs
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!TestStubs methodsFor: 'books' stamp: 'nz 6/23/2021 01:01:49'!
                    book1
	^'ISBN1'.! !
!TestStubs methodsFor: 'books' stamp: 'nz 6/23/2021 01:01:53'!
             book2
	^'ISBN2'.! !
!TestStubs methodsFor: 'books' stamp: 'nz 6/23/2021 01:12:43'!
             book3
	^'ISBN3'.! !
!TestStubs methodsFor: 'books' stamp: 'nz 6/23/2021 01:43:29'!
             priceList

	| bookPrices |
	bookPrices _ PriceList new.
	bookPrices set: self book1 price: 50.
	bookPrices set: self book2 price: 20.
	bookPrices set: self book3 price: 30.
	^bookPrices.! !
!TestStubs methodsFor: 'cards' stamp: 'nz 6/23/2021 00:43:00'!
   cardOwner
	^ 'PEPE SANCHEZ'.! !
!TestStubs methodsFor: 'cards' stamp: 'nz 6/23/2021 00:42:35'!
 invalidNumberCreditCard

	^ CreditCard
		number: '418241'
		owner: self cardOwner
		expiration: self currentMonth next.! !
!TestStubs methodsFor: 'cards' stamp: 'AW 6/24/2021 00:25:18'!
      mockAlwaysOkMerchantProcessor

	^MockAlwaysOkMerchantProcessor new.! !
!TestStubs methodsFor: 'cards' stamp: 'nz 6/23/2021 01:16:35'!
                          validCreditCard
	^CreditCard
		number: self validCreditCardNumber
		owner: self cardOwner
		expiration: self currentMonth next.! !
!TestStubs methodsFor: 'cards' stamp: 'nz 6/23/2021 01:16:56'!
                              validCreditCardNumber
	^'4182418241824182'.! !
!TestStubs methodsFor: 'time' stamp: 'nz 6/23/2021 00:43:27'!
                   currentMonth
	^ self today monthOfYear.! !
!TestStubs methodsFor: 'time' stamp: 'AW 6/24/2021 00:23:09'!
                       timeProvider
	^MockTimeProvider new.! !
!TestStubs methodsFor: 'time' stamp: 'nz 6/23/2021 00:43:41'!
                          today

	^ FixedGregorianDate today.! !

----End fileIn of /home/nikita/r/f/ingsoft1/Inge1-ejercicios/20-TusLibros-Iteracion-4/Tus-Libros.st----!

!testRun: #PriceListTest #test01AddItemWithNegativePriceShouldRaiseError stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #PriceListTest #test02AddItemWithZeroPriceShouldRaiseError stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test01InvalidClientShallNotPass stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test02NewCartsAreEmpty stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test04ListInvalidCartShouldRaiseError stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test05AddItemToCartDoesntModifyOtherCarts stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test06CheckoutInvalidCartIdShouldRaiseError stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test07CheckoutUsesTheCashier stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test12ListPurchasesOfIncorrectPasswordShouldFail stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test14CheckingOutAnExpiredCardShouldFail stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShopTest #test16AddingItemsToAnExpiredCartShouldFail stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShoppingCartTest #test01EmptyCartHasNoItems stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShoppingCartTest #test04AddingANegativeQuantityRaisesError stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShoppingCartTest #test05AddingZeroQuantityRaisesError stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #ShoppingCartTest #test06AddingNonIntegerQuantityRaisesError stamp: 'nz 6/24/2021 21:37:27'!
PASSED!

!testRun: #PriceListTest #test01AddItemWithNegativePriceShouldRaiseError stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #PriceListTest #test02AddItemWithZeroPriceShouldRaiseError stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test01InvalidClientShallNotPass stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test02NewCartsAreEmpty stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test04ListInvalidCartShouldRaiseError stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test05AddItemToCartDoesntModifyOtherCarts stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test06CheckoutInvalidCartIdShouldRaiseError stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test07CheckoutUsesTheCashier stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test12ListPurchasesOfIncorrectPasswordShouldFail stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test14CheckingOutAnExpiredCardShouldFail stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShopTest #test16AddingItemsToAnExpiredCartShouldFail stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShoppingCartTest #test01EmptyCartHasNoItems stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShoppingCartTest #test04AddingANegativeQuantityRaisesError stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShoppingCartTest #test05AddingZeroQuantityRaisesError stamp: 'nz 6/24/2021 21:38:02'!
PASSED!

!testRun: #ShoppingCartTest #test06AddingNonIntegerQuantityRaisesError stamp: 'nz 6/24/2021 21:38:02'!
PASSED!
!CheckOutTest methodsFor: 'setUp/tearDown' stamp: 'nz 6/24/2021 21:38:37' prior: 50331895 overrides: 16927572!
          setUp

	today _ FixedGregorianDate today.
	currentMonth _ today monthOfYear.
	
	creditCardNumber _ '4182418241824182'.
	cardOwner _ 'PEPE SANCHEZ'.

	stubs := TestStubs new.

	validCreditCard _ CreditCard
		number: creditCardNumber
		owner: cardOwner
		expiration: currentMonth next.
	
	expiredCreditCard _ CreditCard
		number: creditCardNumber
		owner: cardOwner
		expiration: currentMonth previous.
		
	expiredThisMonthCreditCard _ CreditCard
		number: creditCardNumber
		owner: cardOwner
		expiration: currentMonth.
		
	invalidNumberCreditCard _ stubs invalidNumberCreditCard.
		
	emptyOwnerCreditCard _ CreditCard
		number: creditCardNumber
		owner: ''
		expiration: currentMonth next.
		
	emptyOwnerCreditCard2 _ CreditCard
		number: creditCardNumber
		owner: '            '
		expiration: currentMonth next.
		
	book1 := stubs book1.
	book2 := stubs book2.
	
	mockAlwaysStolenCardMerchantProcessor _ MockAlwaysStolenCardMerchantProcessor new.
	mockAlwaysOkMerchantProcessor _ stubs mockAlwaysOkMerchantProcessor.
	mockAlwaysFakeCardMerchantProcessor _ MockAlwaysFakeCardMerchantProcessor new.
	mockAlwaysWithoutCreditCardMerchantProcessor _ MockAlwaysWithoutCreditCardMerchantProcessor new.! !

!testRun: #CheckOutTest #test01CheckoutEmptyCartShouldRaiseError stamp: 'nz 6/24/2021 21:38:50'!
PASSED!

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'nz 6/24/2021 21:38:51'!
PASSED!

!testRun: #CheckOutTest #test03CheckoutACartWithMultipleItems stamp: 'nz 6/24/2021 21:38:52'!
PASSED!

!testRun: #CheckOutTest #test04CheckoutItemWithoutPricesShouldRaiseError stamp: 'nz 6/24/2021 21:38:53'!
PASSED!

!testRun: #CheckOutTest #test05CheckoutWithExpiredCardShouldRaiseError stamp: 'nz 6/24/2021 21:38:53'!
PASSED!

!testRun: #CheckOutTest #test06CheckoutWithCardExpiredThisMonthShouldRaiseError stamp: 'nz 6/24/2021 21:38:53'!
PASSED!

!testRun: #CheckOutTest #test07CheckoutWithStolenCardShouldRaiseError stamp: 'nz 6/24/2021 21:38:53'!
PASSED!

!testRun: #CheckOutTest #test08CheckoutWithFakeCardShouldRaiseError stamp: 'nz 6/24/2021 21:38:54'!
PASSED!

!testRun: #CheckOutTest #test09CheckoutWithInsufficientFundsShouldRaiseError stamp: 'nz 6/24/2021 21:38:54'!
PASSED!

!testRun: #CheckOutTest #test10CheckoutWithInvalidCardNumberShouldRaiseError stamp: 'nz 6/24/2021 21:38:54'!
PASSED!

!testRun: #CheckOutTest #test11CheckoutWithEmptyCardOwnerNameShouldRaiseError stamp: 'nz 6/24/2021 21:38:54'!
PASSED!

!testRun: #CheckOutTest #test12CheckoutWithBlankCardOwnerNameShouldRaiseError stamp: 'nz 6/24/2021 21:38:54'!
PASSED!

Object subclass: #StringGenius
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'StringsServicesServer'!

!classDefinition: #StringGenius category: 'StringsServicesServer' stamp: 'nz 6/24/2021 21:47:34'!
Object subclass: #StringGenius
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'StringsServicesServer'!
!StringGenius methodsFor: 'converting' stamp: 'NR 11/11/2019 16:14:06'!
          firstLetter: aWord
	
	^aWord at:1! !
!StringGenius methodsFor: 'converting' stamp: 'NR 6/24/2021 19:12:44'!
                    removeSpecialCharacters: aSentence
	
	^aSentence select:[:ch| ch isAlphaNumeric or: [ch isSeparator ]].! !
!StringGenius methodsFor: 'converting' stamp: 'NR 11/11/2019 16:14:58'!
             toLowercase: aWord
	
	^aWord translateToLowercase! !
!StringGenius methodsFor: 'converting' stamp: 'NR 11/11/2019 16:14:47'!
   toUppercase: aWord
	
	^aWord translateToUppercase! !
!StringGenius methodsFor: 'converting' stamp: 'NR 11/11/2019 16:44:40'!
   vowels: aWord
	
	^aWord select: [:letter | letter isVowel]! !
!StringGenius methodsFor: 'converting' stamp: 'NR 6/24/2021 19:16:17'!
                           words: aSentence
	
	^(self removeSpecialCharacters:aSentence) substrings! !

Object subclass: #StringsServicesRestInterface
	instanceVariableNames: 'webServer port stringGenius'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'StringsServicesServer'!

!classDefinition: #StringsServicesRestInterface category: 'StringsServicesServer' stamp: 'nz 6/24/2021 21:47:34'!
Object subclass: #StringsServicesRestInterface
	instanceVariableNames: 'webServer port stringGenius'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'StringsServicesServer'!
!StringsServicesRestInterface methodsFor: 'enabling services' stamp: 'NR 6/24/2019 06:51:52'!
                    destroy
	
	webServer ifNotNil:[webServer destroy].! !
!StringsServicesRestInterface methodsFor: 'enabling services' stamp: 'NR 6/23/2021 20:38:01'!
            startListening
	
	webServer startListener.

	^'Listening on port: ', self port asString.
	! !
!StringsServicesRestInterface methodsFor: 'enabling services' stamp: 'NR 11/11/2019 15:54:20'!
   stopListening
	
	webServer stopListener.
	
	^'Stopped listening from port: ', self port asString! !
!StringsServicesRestInterface methodsFor: 'initialization' stamp: 'NR 6/24/2021 19:18:02'!
 initializeWith: aPortNumber
	
	stringGenius := StringGenius new.
	
	port:= aPortNumber.
	
	webServer := WebServer new listenOn: self port.
	
	webServer addService: '/quote' action:[:request |	
		
		request send200Response: (self sayRandomQuote)].
	
	webServer addService: '/words' action:[:request | |wordsAsJson sentence words |
		
		[sentence := (request fields at:'sentence').
		words := stringGenius words: sentence.
		wordsAsJson:= WebUtils jsonEncode: (words).
		request send200Response: (wordsAsJson)
		 ] 
		on: Error 
		do: [ :anError |
			request send400Response: (anError messageText) ]].
	
	webServer addService: '/firstLetter' action:[:request | |letterAsJson word letter |
		
		[word := (request fields at:'sentence').
		letter := stringGenius firstLetter: word.
		letterAsJson:= WebUtils jsonEncode: (letter asString).
		request send200Response: (letterAsJson)
		 ] 
		on: Error 
		do: [ :anError |
			request send400Response: (anError messageText) ]].
	
	webServer addService: '/vowels' action:[:request | |vowelsAsJson word vowels |
		
		[word := (request fields at:'sentence').
		vowels := stringGenius vowels: word.
		vowelsAsJson:= WebUtils jsonEncode: (vowels).
		request send200Response: (vowelsAsJson)
		 ] 
		on: Error 
		do: [ :anError |
			request send400Response: (anError messageText) ]].
	
	webServer addService: '/toUppercase' action:[:request | |upperCasedWordAsJson word upperCasedWord |
		
		[word := (request fields at:'sentence').
		upperCasedWord := stringGenius toUppercase: word.
		upperCasedWordAsJson:= WebUtils jsonEncode: (upperCasedWord).
		request send200Response: (upperCasedWordAsJson)
		 ] 
		on: Error 
		do:  [ :anError | request 
			request send400Response: (anError messageText)]].
! !
!StringsServicesRestInterface methodsFor: 'initialization' stamp: 'NR 11/11/2019 17:19:18'!
                           port
	"Use a random port to minimise chances of concurrently running test suites clashing."
	"^ port
		ifNil: [port := (10000 to: 50000) atRandom]"
	
	^port ifNil: [port:=8080].
	
	! !
!StringsServicesRestInterface methodsFor: 'private' stamp: 'NR 6/23/2021 20:29:59'!
                   quoteList
	
	^OrderedCollection with: 'You should have gone for the head' with: 'I Love you 3000!!' with: 'I am Groot!!' with: 'For All Time, Allways' with: 'I am inevitable...' with: 'Because Im Baaaatman!!'
	
	! !
!StringsServicesRestInterface methodsFor: 'private' stamp: 'NR 6/23/2021 20:33:19'!
                    sayRandomQuote
	| quotes |
	
	quotes := self quoteList.
	
	^quotes at: (quotes size atRandom).
	! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

StringsServicesRestInterface class
	instanceVariableNames: ''!

!classDefinition: 'StringsServicesRestInterface class' category: 'StringsServicesServer' stamp: 'nz 6/24/2021 21:47:34'!
StringsServicesRestInterface class
	instanceVariableNames: ''!
!StringsServicesRestInterface class methodsFor: 'as yet unclassified' stamp: 'NR 11/11/2019 15:43:02'!
 listeningOn: aPortNumber

	^self new initializeWith: aPortNumber.! !

----End fileIn of /home/nikita/r/f/ingsoft1/Inge1-ejercicios/20-TusLibros-Iteracion-4/StringsServicesServer.st----!

ssri := StringsServicesRestInterface listeningOn: 8080.!

Smalltalk allObjectsDo: [
	:obj |
	(obj isKindOf: StringsServicesRestInterface)
	ifTrue: [ obj stopListening. ]
].!


servers : OrderedCollection new.!


servers := OrderedCollection new.!

Smalltalk allObjectsDo: [
	:obj |
	(obj isKindOf: StringsServicesRestInterface)
	ifTrue: [ servers add: obj. ]
].!

servers!


servers do: [ :srv | srv stopListening ].!


servers do: [ :srv | srv destroy ].!

servers := OrderedCollection new.
!


Smalltalk allObjectsDo: [
  :obj |
  (obj isKindOf: StringsServicesRestInterface)
  ifTrue: [ servers add: obj. ]
].!

servers!

!testRun: #CheckOutTest #test01CheckoutEmptyCartShouldRaiseError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #CheckOutTest #test03CheckoutACartWithMultipleItems stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #CheckOutTest #test04CheckoutItemWithoutPricesShouldRaiseError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #CheckOutTest #test05CheckoutWithExpiredCardShouldRaiseError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #CheckOutTest #test06CheckoutWithCardExpiredThisMonthShouldRaiseError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #CheckOutTest #test07CheckoutWithStolenCardShouldRaiseError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #CheckOutTest #test08CheckoutWithFakeCardShouldRaiseError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #CheckOutTest #test09CheckoutWithInsufficientFundsShouldRaiseError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #CheckOutTest #test10CheckoutWithInvalidCardNumberShouldRaiseError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #CheckOutTest #test11CheckoutWithEmptyCardOwnerNameShouldRaiseError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #CheckOutTest #test12CheckoutWithBlankCardOwnerNameShouldRaiseError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #PriceListTest #test01AddItemWithNegativePriceShouldRaiseError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #PriceListTest #test02AddItemWithZeroPriceShouldRaiseError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test01InvalidClientShallNotPass stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test02NewCartsAreEmpty stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test04ListInvalidCartShouldRaiseError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test05AddItemToCartDoesntModifyOtherCarts stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test06CheckoutInvalidCartIdShouldRaiseError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test07CheckoutUsesTheCashier stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test12ListPurchasesOfIncorrectPasswordShouldFail stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test14CheckingOutAnExpiredCardShouldFail stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShopTest #test16AddingItemsToAnExpiredCartShouldFail stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShoppingCartTest #test01EmptyCartHasNoItems stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShoppingCartTest #test04AddingANegativeQuantityRaisesError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShoppingCartTest #test05AddingZeroQuantityRaisesError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

!testRun: #ShoppingCartTest #test06AddingNonIntegerQuantityRaisesError stamp: 'nz 6/24/2021 22:13:15'!
PASSED!

----QUIT----(24 June 2021 22:13:29) CuisUniversity-4532.image priorSource: 18058935!

----STARTUP---- (27 June 2021 22:23:03) as /home/awolfsdorf/Dropbox/CSCOM/IngeSoft1/Inge1-ejercicios/20-TusLibros-Iteracion-4/CuisUniversity-4532.image!


Object subclass: #TusLibrosRestInterface
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #TusLibrosRestInterface category: 'Tus-Libros' stamp: 'AW 6/27/2021 22:31:33'!
Object subclass: #TusLibrosRestInterface
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

Object subclass: #TusLibrosRestInterface
	instanceVariableNames: 'webServer port'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #TusLibrosRestInterface category: 'Tus-Libros' stamp: 'AW 6/27/2021 22:31:51'!
Object subclass: #TusLibrosRestInterface
	instanceVariableNames: 'webServer port'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!TusLibrosRestInterface class methodsFor: 'no messages' stamp: 'AW 6/27/2021 22:32:38'!
                on: aPort! !
!TusLibrosRestInterface class methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:33:46' prior: 50333994!
   on: aPort

	^self new withPort: aPort! !
!TusLibrosRestInterface class methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:34:16' prior: 50333998!
       on: aPort

	^self new initializeOn: aPort! !
!TusLibrosRestInterface methodsFor: 'nil' stamp: 'AW 6/27/2021 22:36:08'!
         initializeOn: aPort

	port := aPort.
	
	webServer := WebServer new listenOn: self port.! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:37:13'!
           port

	^port ifNil: [ port _ 8080].! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:37:37' prior: 50334007!
               initializeOn: aPort

	port := aPort.
	
	webServer := WebServer new listenOn: self port.
	
	self configRoutes.! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:43:07'!
                     configRoutes

	self addService: '/sayHello' action: [ :request | request send200Response: 'Que ondas' ].! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:44:24'!
                          addService: aRouteString action: aBlockClosure

	webServer addService: aRouteString action: aBlockClosure.! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:44:56'!
                        destroy
	webServer ifNotNil: [ webServer destroy ].! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:45:09'!
               startListening
	webServer startListener.
	^ 'Listening on port: ' , self port asString.! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:45:14'!
           stopListening
	webServer stopListener.
	^ 'Stopped listening from port: ' , self port asString.! !

tusLibrosWebServer _ TusLibrosRestInterface on: 8080.!

tusLibrosWebServer startListening.!

tusLibrosWebServer stopListening !

tusLibrosWebServer destroy !

tusLibrosWebServer destroy.!

stubs _ TestStubs new. !

!classDefinition: #ShopConfiguration category: 'Tus-Libros' stamp: 'AW 6/27/2021 22:55:12'!
Object subclass: #ShopConfiguration
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!


shopConfiguration _ ShopConfiguration 
		withUserAuthenticator: (stubs mockUserAuthenticatorAlwaysReturning: false)
		prices: stubs priceList
		merchantProcessor: stubs mockAlwaysOkMerchantProcessor
		timeProvider: stubs timeProvider.!
!TestStubs methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:55:35'!
        mockUserAuthenticatorAlwaysReturning: aFalse 
	self shouldBeImplemented.! !
!TestStubs methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:55:51' prior: 50334077!
                       mockUserAuthenticatorAlwaysReturning: aFalse 
	MockUserAuthenticator alwaysReturning: false.! !
!TestStubs methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:56:07' prior: 50334083!
   mockUserAuthenticatorAlwaysReturning: aBoolean
	^MockUserAuthenticator alwaysReturning: aBoolean.! !
!ShopConfiguration class methodsFor: 'instance creation' stamp: 'AW 6/27/2021 22:56:18'!
  withUserAuthenticator: aMockUserAuthenticator prices: aPriceList merchantProcessor: aMockAlwaysOkMerchantProcessor timeProvider: aMockTimeProvider 
	"DO NOT FORGET TO RENAME COLLABORATORS AND REMOVE THIS COMMENT!!!!"
	self shouldBeImplemented.
	^self new initializeWithUserAuthenticator: aMockUserAuthenticator prices: aPriceList merchantProcessor: aMockAlwaysOkMerchantProcessor timeProvider: aMockTimeProvider ! !
!ShopConfiguration class methodsFor: 'instance creation' stamp: 'AW 6/27/2021 22:56:44' prior: 50334095!
                       withUserAuthenticator: aMockUserAuthenticator prices: aPriceList merchantProcessor: aMockAlwaysOkMerchantProcessor timeProvider: aMockTimeProvider 


	^self new initializeWithUserAuthenticator: aMockUserAuthenticator prices: aPriceList merchantProcessor: aMockAlwaysOkMerchantProcessor timeProvider: aMockTimeProvider ! !
!ShopConfiguration class methodsFor: 'instance creation' stamp: 'AW 6/27/2021 22:56:52' prior: 50334112!
                     withUserAuthenticator: aMockUserAuthenticator prices: aPriceList merchantProcessor: aMockAlwaysOkMerchantProcessor timeProvider: aTimeProvider 


	^self new initializeWithUserAuthenticator: aMockUserAuthenticator prices: aPriceList merchantProcessor: aMockAlwaysOkMerchantProcessor timeProvider: aTimeProvider ! !
!ShopConfiguration class methodsFor: 'instance creation' stamp: 'AW 6/27/2021 22:57:04' prior: 50334126!
                             withUserAuthenticator: aMockUserAuthenticator prices: aPriceList merchantProcessor: aMerchantProcessor timeProvider: aTimeProvider 


	^self new initializeWithUserAuthenticator: aMockUserAuthenticator prices: aPriceList merchantProcessor: aMerchantProcessor timeProvider: aTimeProvider ! !
!ShopConfiguration class methodsFor: 'instance creation' stamp: 'AW 6/27/2021 22:57:11' prior: 50334140!
                     withUserAuthenticator: aUserAuthenticator prices: aPriceList merchantProcessor: aMerchantProcessor timeProvider: aTimeProvider 


	^self new initializeWithUserAuthenticator: aUserAuthenticator prices: aPriceList merchantProcessor: aMerchantProcessor timeProvider: aTimeProvider ! !

!classDefinition: #ShopConfiguration category: 'Tus-Libros' stamp: 'AW 6/27/2021 22:57:26'!
Object subclass: #ShopConfiguration
	instanceVariableNames: 'userAuthenticator'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #ShopConfiguration category: 'Tus-Libros' stamp: 'AW 6/27/2021 22:57:26'!
Object subclass: #ShopConfiguration
	instanceVariableNames: 'userAuthenticator priceList'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #ShopConfiguration category: 'Tus-Libros' stamp: 'AW 6/27/2021 22:57:26'!
Object subclass: #ShopConfiguration
	instanceVariableNames: 'userAuthenticator priceList merchantProcessor'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!classDefinition: #ShopConfiguration category: 'Tus-Libros' stamp: 'AW 6/27/2021 22:57:26'!
Object subclass: #ShopConfiguration
	instanceVariableNames: 'userAuthenticator priceList merchantProcessor timeProvider'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!ShopConfiguration methodsFor: 'initialization' stamp: 'AW 6/27/2021 22:57:26'!
                       initializeWithUserAuthenticator: aUserAuthenticator prices: aPriceList merchantProcessor: aMerchantProcessor timeProvider: aTimeProvider 
	self shouldBeImplemented.
	userAuthenticator := aUserAuthenticator.
	priceList := aPriceList.
	merchantProcessor := aMerchantProcessor.
	timeProvider := aTimeProvider.! !
!ShopConfiguration methodsFor: 'initialization' stamp: 'AW 6/27/2021 22:57:37' prior: 50334198!
          initializeWithUserAuthenticator: aUserAuthenticator prices: aPriceList merchantProcessor: aMerchantProcessor timeProvider: aTimeProvider 
	userAuthenticator := aUserAuthenticator.
	priceList := aPriceList.
	merchantProcessor := aMerchantProcessor.
	timeProvider := aTimeProvider.! !
!TusLibrosRestInterface class methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:58:42'!
     on: aPort shopConfiguration: aShopConfiguration 

	^self new initializeOn: aPort! !

!methodRemoval: TusLibrosRestInterface class #on: stamp: 'AW 6/27/2021 22:58:42'!
on: aPort

	^self new initializeOn: aPort!
!TusLibrosRestInterface class methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:59:04' prior: 50334223!
                              on: aPort shopConfiguration: aShopConfiguration 

	^self new initializeOn: aPort! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:59:35'!
                  initializeOn: aPort shopConfiguration: aShopConfiguration 

	port := aPort.
	
	webServer := WebServer new listenOn: self port.
	
	self configRoutes.! !
!TusLibrosRestInterface class methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 22:59:35' prior: 50334234!
                        on: aPort shopConfiguration: aShopConfiguration 

	^self new initializeOn: aPort shopConfiguration: aShopConfiguration! !

!methodRemoval: TusLibrosRestInterface #initializeOn: stamp: 'AW 6/27/2021 22:59:35'!
initializeOn: aPort

	port := aPort.
	
	webServer := WebServer new listenOn: self port.
	
	self configRoutes.!

!classDefinition: #TusLibrosRestInterface category: 'Tus-Libros' stamp: 'AW 6/27/2021 23:01:52'!
Object subclass: #TusLibrosRestInterface
	instanceVariableNames: 'webServer port shop'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 23:01:50' prior: 50334240!
                      initializeOn: aPort shopConfiguration: aShopConfiguration 

	shop := self createShopFrom: aShopConfiguration.
	port := aPort.
	webServer := WebServer new listenOn: self port.
	
	self configRoutes.! !

tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 23:02:22'!
 createShopFrom: aShopConfiguration 
	self shouldBeImplemented.! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 23:04:20' prior: 50334283!
                    createShopFrom: aShopConfiguration 
	^aShopConfiguration create.! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 23:04:29' prior: 50334289!
                  createShopFrom: aShopConfiguration 
	^aShopConfiguration createShop.! !
!ShopConfiguration methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 23:04:40'!
   createShop
	self shouldBeImplemented.! !
!ShopConfiguration methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 23:05:19' prior: 50334300!
                  createShop
	^Shop 
		withUserAuthenticator: userAuthenticator 
		prices: priceList 
		merchantProcessor: merchantProcessor 
		timeProvider: timeProvider.! !

tusLibrosWebServer startListening .!

tusLibrosWebServer destroy.!

WebUtils jsonEncode: 'Hola'!

WebUtils jsonEncode: 3 !

WebUtils jsonEncode: Dictionary new!

dict _ Dictionary new.!

dict at: 'id' put: 'tumama'!

WebUtils jsonEncode: dict.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 23:20:18' prior: 50334025!
   configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | 
		response _ Dictionary new.
		cartId _ shop createCartClientId: clientId password: clientPassword.
		response at: 'cartId' put: cartId.
		request send200Response: WebUtils jsonEncode: response.
		
	].! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 23:20:46' prior: 50334321!
                      configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | 
		response _ Dictionary new.
		cartId _ shop createCartClientId: clientId password: clientPassword.
		response at: 'cartId' put: cartId.
		request send200Response: (WebUtils jsonEncode: response).
		
	].! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 23:22:05' prior: 50334335!
                    configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | 
		clientId _ request fields at: 'clientId'.
		clientPassword _ request fields at: 'password'.
		response _ Dictionary new.
		cartId _ shop createCartClientId: clientId password: clientPassword.
		response at: 'cartId' put: cartId.
		request send200Response: (WebUtils jsonEncode: response).
		
	].! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 23:22:20' prior: 50334349!
                      configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | 
		clientId _ request fields at: 'clientId'.
		clientPassword _ request fields at: 'password'.
		cartId _ shop createCartClientId: clientId password: clientPassword.
		
		response _ Dictionary new.
		response at: 'cartId' put: cartId.
		request send200Response: (WebUtils jsonEncode: response).
		
	].! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 23:25:17' prior: 50334366!
                   configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | 
		clientId _ request fields at: 'clientId'.
		clientPassword _ request fields at: 'password'.
		cartId _ shop createCartClientId: clientId password: clientPassword.
		
		response _ Dictionary new.
		response at: 'cartId' put: cartId.
		request send200Response: (WebUtils jsonEncode: response).
		
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | 
		cartItems _ shop listCart: cartId.
		
		response _ Dictionary new.
		response at: 'items' put: cartItems.
		request send200Response: (WebUtils jsonEncode: response).
		
	].! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 23:25:48' prior: 50334383!
                 configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | 
		clientId _ request fields at: 'clientId'.
		clientPassword _ request fields at: 'password'.
		cartId _ shop createCartClientId: clientId password: clientPassword.
		
		response _ Dictionary new.
		response at: 'cartId' put: cartId.
		request send200Response: (WebUtils jsonEncode: response).
		
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | 
		cartId _ request fields at: 'cartId'.
		cartItems _ shop listCart: cartId.
		
		response _ Dictionary new.
		response at: 'items' put: cartItems.
		request send200Response: (WebUtils jsonEncode: response).
		
	].! !

tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. !

tusLibrosWebServer startListening .!

onfiguration 
		withUserAuthenticator: (stubs mockUserAuthenticatorAlwaysReturning: true)
		prices: stubs priceList
		merchantProcessor: stubs mockAlwaysOkMerchantProcessor
		timeProvider: stubs timeProvider. !


shopConfiguration _ ShopConfiguration 
		withUserAuthenticator: (stubs mockUserAuthenticatorAlwaysReturning: true)
		prices: stubs priceList
		merchantProcessor: stubs mockAlwaysOkMerchantProcessor
		timeProvider: stubs timeProvider. !

tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. !

tusLibrosWebServer startListening.!

tusLibrosWebServer destroy !


tusLibrosWebServer stopListening.
tusLibrosWebServer destroy.!

tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
!

tusLibrosWebServer startListening.
!


tusLibrosWebServer stopListening.
tusLibrosWebServer destroy.!


tusLibrosWebServer stopListening.
tusLibrosWebServer destroy.!

tusLibrosWebServer stopListening.
tusLibrosWebServer destroy.!

tusLibrosWebServer stopListening.
tusLibrosWebServer destroy.!

tusLibrosWebServer stopListening.
tusLibrosWebServer destroy.!

TusLibrosRestInterface allInstances destroy .!

TusLibrosRestInterface allInstances do: [ :x | x destroy ].!

tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. !

tusLibrosWebServer startListening.!


tusLibrosWebServer stopListening.
tusLibrosWebServer destroy.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 23:37:15' prior: 50334408!
        configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | 
		clientId _ request fields at: 'clientId'.
		clientPassword _ request fields at: 'password'.
		cartId _ shop createCartClientId: clientId password: clientPassword.
		
		response _ Dictionary new.
		response at: 'cartId' put: cartId.
		request send200Response: (WebUtils jsonEncode: response).
		
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | 
		cartId _ request fields at: 'cartId' asNumber .
		cartItems _ shop listCart: cartId.
		
		response _ Dictionary new.
		response at: 'items' put: cartItems.
		request send200Response: (WebUtils jsonEncode: response).
		
	].! !


tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 

tusLibrosWebServer startListening.
!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/27/2021 23:37:37' prior: 50334483!
                           configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | 
		clientId _ request fields at: 'clientId'.
		clientPassword _ request fields at: 'password'.
		cartId _ shop createCartClientId: clientId password: clientPassword.
		
		response _ Dictionary new.
		response at: 'cartId' put: cartId.
		request send200Response: (WebUtils jsonEncode: response).
		
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | 
		cartId _ (request fields at: 'cartId') asNumber .
		cartItems _ shop listCart: cartId.
		
		response _ Dictionary new.
		response at: 'items' put: cartItems.
		request send200Response: (WebUtils jsonEncode: response).
		
	].! !


tusLibrosWebServer stopListening.
tusLibrosWebServer destroy.!


tusLibrosWebServer stopListening.
tusLibrosWebServer destroy.!

tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 

tusLibrosWebServer startListening.!

tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 

tusLibrosWebServer startListening.!


tusLibrosWebServer stopListening.
tusLibrosWebServer destroy.!


tusLibrosWebServer stopListening.
tusLibrosWebServer destroy.!


tusLibrosWebServer stopListening.
tusLibrosWebServer destroy.!


TusLibrosRestInterface allInstances do: [ :x | x destroy ].!

servers _ OrderedCollection new.!
!ShopTest methodsFor: 'cart creation and listing' stamp: 'AW 6/27/2021 23:56:19' prior: 50332084!
                          test03ListCartWithOneItem
	
	| shop cartId cartItems bookIsbn quantity |
	
	shop := Shop 
		withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) 
		prices: stubs priceList 
		merchantProcessor: stubs mockAlwaysOkMerchantProcessor 
		timeProvider: stubs timeProvider.
	
	cartId := shop createCartClientId: 3 password: '1234'.
	
	quantity := 2.
	bookIsbn := 'book_isbn'.
		
	shop add: quantity of: bookIsbn to: cartId.
	
	cartItems := shop listCart: cartId.
	
	self assert: cartItems size equals: 1.
	self assert: (cartItems first at: 'quantity') equals: quantity.
	self assert: (cartItems first at: 'item') equals: bookIsbn.! !
!ShopTest methodsFor: 'cart creation and listing' stamp: 'AW 6/27/2021 23:56:50' prior: 50334562!
                           test03ListCartWithOneItem
	
	| shop cartId cartItems bookIsbn quantity |
	
	shop := Shop 
		withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) 
		prices: stubs priceList 
		merchantProcessor: stubs mockAlwaysOkMerchantProcessor 
		timeProvider: stubs timeProvider.
	
	cartId := shop createCartClientId: 3 password: '1234'.
	
	quantity := 2.
	bookIsbn := 'book_isbn'.
		
	shop add: quantity of: bookIsbn to: cartId.
	
	cartItems := shop listCart: cartId.
	
	self assert: cartItems size equals: 1.
	self assert: (cartItems first at: 'quantity') equals: quantity.
	self assert: (cartItems first at: 'item') equals: bookIsbn.! !

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/27/2021 23:57:11'!
ERROR!
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/28/2021 00:02:16' prior: 50333132!
                 getCartEntries: aShoppingCartId

	^ (self getCart: aShoppingCartId) entries collect: [ :cartEntry | | ccc | 
		ccc _ Dictionary new.
		ccc at: 'item'	 put: cartEntry item.
		ccc at: 'quantity'	 put: cartEntry quantity.
	].! !
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/28/2021 00:03:09' prior: 50334612!
         getCartEntries: aShoppingCartId

	^ self getEntriesAsDictionary: (self getCart: aShoppingCartId) entries.! !
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/28/2021 00:04:45'!
              getEntriesAsDictionary: aEntryList

	^ aEntryList collect: [ :cartEntry | | entryDictionary | 
		entryDictionary _ Dictionary new.
		entryDictionary at: 'item'	 put: cartEntry item.
		entryDictionary at: 'quantity'	 put: cartEntry quantity.
	].! !

!testRun: #ShopTest #test01InvalidClientShallNotPass stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test02NewCartsAreEmpty stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 00:04:58'!
ERROR!

!testRun: #ShopTest #test04ListInvalidCartShouldRaiseError stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test05AddItemToCartDoesntModifyOtherCarts stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test06CheckoutInvalidCartIdShouldRaiseError stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test07CheckoutUsesTheCashier stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test12ListPurchasesOfIncorrectPasswordShouldFail stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test14CheckingOutAnExpiredCardShouldFail stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test16AddingItemsToAnExpiredCartShouldFail stamp: 'AW 6/28/2021 00:04:58'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 00:04:58'!
ERROR!

self!

self at: 0!

self at: 1!
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/28/2021 00:07:30' prior: 50334628!
 getEntriesAsDictionary: aEntryList

	^ aEntryList collect: [ :cartEntry | | entryDictionary | 
		entryDictionary _ Dictionary new.
		entryDictionary at: 'item'	 put: cartEntry item.
		entryDictionary at: 'quantity'	 put: cartEntry quantity.
		entryDictionary.
	].! !
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/28/2021 00:07:37' prior: 50334693!
getEntriesAsDictionary: aEntryList

	^ aEntryList collect: [ :cartEntry | | entryDictionary | 
		entryDictionary _ Dictionary new.
		entryDictionary at: 'item'	 put: cartEntry item.
		entryDictionary at: 'quantity'	 put: cartEntry quantity.
		entryDictionary
	].! !

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 00:08:04'!
PASSED!

!testRun: #ShopTest #test01InvalidClientShallNotPass stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test02NewCartsAreEmpty stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test04ListInvalidCartShouldRaiseError stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test05AddItemToCartDoesntModifyOtherCarts stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test06CheckoutInvalidCartIdShouldRaiseError stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test07CheckoutUsesTheCashier stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test12ListPurchasesOfIncorrectPasswordShouldFail stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test14CheckingOutAnExpiredCardShouldFail stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #ShopTest #test16AddingItemsToAnExpiredCartShouldFail stamp: 'AW 6/28/2021 00:08:09'!
PASSED!

!testRun: #CheckOutTest #test01CheckoutEmptyCartShouldRaiseError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #CheckOutTest #test03CheckoutACartWithMultipleItems stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #CheckOutTest #test04CheckoutItemWithoutPricesShouldRaiseError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #CheckOutTest #test05CheckoutWithExpiredCardShouldRaiseError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #CheckOutTest #test06CheckoutWithCardExpiredThisMonthShouldRaiseError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #CheckOutTest #test07CheckoutWithStolenCardShouldRaiseError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #CheckOutTest #test08CheckoutWithFakeCardShouldRaiseError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #CheckOutTest #test09CheckoutWithInsufficientFundsShouldRaiseError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #CheckOutTest #test10CheckoutWithInvalidCardNumberShouldRaiseError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #CheckOutTest #test11CheckoutWithEmptyCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #CheckOutTest #test12CheckoutWithBlankCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #PriceListTest #test01AddItemWithNegativePriceShouldRaiseError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #PriceListTest #test02AddItemWithZeroPriceShouldRaiseError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test01InvalidClientShallNotPass stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test02NewCartsAreEmpty stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test04ListInvalidCartShouldRaiseError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test05AddItemToCartDoesntModifyOtherCarts stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test06CheckoutInvalidCartIdShouldRaiseError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test07CheckoutUsesTheCashier stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test12ListPurchasesOfIncorrectPasswordShouldFail stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test14CheckingOutAnExpiredCardShouldFail stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShopTest #test16AddingItemsToAnExpiredCartShouldFail stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShoppingCartTest #test01EmptyCartHasNoItems stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShoppingCartTest #test04AddingANegativeQuantityRaisesError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShoppingCartTest #test05AddingZeroQuantityRaisesError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!

!testRun: #ShoppingCartTest #test06AddingNonIntegerQuantityRaisesError stamp: 'AW 6/28/2021 00:09:47'!
PASSED!


tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 

tusLibrosWebServer startListening.!

WebUtils jsonEncode: OrderedCollection new!

OrderedCollection new asArray !

WebUtils jsonEncode: OrderedCollection new asArray !
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/28/2021 00:13:42' prior: 50334704!
                         getEntriesAsDictionary: aEntryList

	^ aEntryList collect: [ :cartEntry | | entryDictionary | 
		entryDictionary _ Dictionary new.
		entryDictionary at: 'item'	 put: cartEntry item.
		entryDictionary at: 'quantity'	 put: cartEntry quantity.
		entryDictionary
	] asArray.! !
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/28/2021 00:13:56' prior: 50334897!
                         getEntriesAsDictionary: aEntryList

	^ (aEntryList collect: [ :cartEntry | | entryDictionary | 
		entryDictionary _ Dictionary new.
		entryDictionary at: 'item'	 put: cartEntry item.
		entryDictionary at: 'quantity'	 put: cartEntry quantity.
		entryDictionary
	]) asArray.! !

!testRun: #CheckOutTest #test01CheckoutEmptyCartShouldRaiseError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #CheckOutTest #test03CheckoutACartWithMultipleItems stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #CheckOutTest #test04CheckoutItemWithoutPricesShouldRaiseError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #CheckOutTest #test05CheckoutWithExpiredCardShouldRaiseError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #CheckOutTest #test06CheckoutWithCardExpiredThisMonthShouldRaiseError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #CheckOutTest #test07CheckoutWithStolenCardShouldRaiseError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #CheckOutTest #test08CheckoutWithFakeCardShouldRaiseError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #CheckOutTest #test09CheckoutWithInsufficientFundsShouldRaiseError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #CheckOutTest #test10CheckoutWithInvalidCardNumberShouldRaiseError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #CheckOutTest #test11CheckoutWithEmptyCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #CheckOutTest #test12CheckoutWithBlankCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #PriceListTest #test01AddItemWithNegativePriceShouldRaiseError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #PriceListTest #test02AddItemWithZeroPriceShouldRaiseError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test01InvalidClientShallNotPass stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test02NewCartsAreEmpty stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test04ListInvalidCartShouldRaiseError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test05AddItemToCartDoesntModifyOtherCarts stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test06CheckoutInvalidCartIdShouldRaiseError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test07CheckoutUsesTheCashier stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test12ListPurchasesOfIncorrectPasswordShouldFail stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test14CheckingOutAnExpiredCardShouldFail stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShopTest #test16AddingItemsToAnExpiredCartShouldFail stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShoppingCartTest #test01EmptyCartHasNoItems stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShoppingCartTest #test04AddingANegativeQuantityRaisesError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShoppingCartTest #test05AddingZeroQuantityRaisesError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

!testRun: #ShoppingCartTest #test06AddingNonIntegerQuantityRaisesError stamp: 'AW 6/28/2021 00:14:11'!
PASSED!

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.
!

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.
!

----QUIT----(28 June 2021 00:16:53) CuisUniversity-4532.image priorSource: 73944!

----STARTUP---- (28 June 2021 19:04:22) as /home/awolfsdorf/Dropbox/CSCOM/IngeSoft1/Inge1-ejercicios/20-TusLibros-Iteracion-4/CuisUniversity-4532.image!

!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 19:10:29' prior: 50334514!
          configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | 
		clientId _ request fields at: 'clientId'.
		clientPassword _ request fields at: 'password'.
		cartId _ shop createCartClientId: clientId password: clientPassword.
		
		response _ Dictionary new.
		response at: 'cartId' put: cartId.
		request send200Response: (WebUtils jsonEncode: response).
		
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | 
		cartId _ (request fields at: 'cartId') asNumber .
		bookIsbn _ request fields at: 'boookIsbn'.
		bookQuantity _ (request fields at: 'bookQuantity') asNumber.
		
		shop add: bookQuantity of: bookIsbn to: cartId.
		
		response _ Dictionary new.
		response at: 'response' put: 'OK'.
		request send200Response: (WebUtils jsonEncode: response).
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | 
		cartId _ (request fields at: 'cartId') asNumber .
		cartItems _ shop listCart: cartId.
		
		response _ Dictionary new.
		response at: 'items' put: cartItems.
		request send200Response: (WebUtils jsonEncode: response).
	].! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 19:14:08' prior: 50335060!
      configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'boookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 19:17:56' prior: 50335100!
                 configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			self inspect.
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'boookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 19:18:57' prior: 50335155!
configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			self halt.
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'boookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!

self fields!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 19:20:36' prior: 50335210!
                     configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			self halt.
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 19:23:15' prior: 50335266!
    configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 19:42:48' prior: 50335321!
                  configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			self halt.
			cced _ FixedGregorianDate fromDate: (request fields at: 'cced')  .
			cco _ request fields at: 'cco'.
			
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].
! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!

(request fields at: 'cced')!

FixedGregorianDate fromDate: (request fields at: 'cced')!

FixedGregorianDate fromDate: '10/15/2025' !

FixedGregorianDate fromDate: '2025/12/12' !

FixedGregorianDate monthOfYear: '12/2022' dayNumber: 10!

(GregorianMonthOfYear year: 2022 month: 12)!

(GregorianMonthOfYear year: 2022 month: 12)!

(GregorianMonthOfYear year: 2022 month: 12)!

(GregorianMonthOfYear year: 2022 month: 12)!

(GregorianMonthOfYear year: 2022 monthNumber: 12)!

(GregorianMonthOfYear yearNumber: 2022 monthNumber: 12)!

'10/2024' findTokens: '/'!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 19:59:59' prior: 50335376!
                configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			self halt.
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) 
				monthNumber: (ccedSplitted at: 1). 
			
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].
! !

----QUIT----(28 June 2021 20:03:53) CuisUniversity-4532.image priorSource: 108829!

----STARTUP---- (28 June 2021 20:04:17) as /home/awolfsdorf/Dropbox/CSCOM/IngeSoft1/Inge1-ejercicios/20-TusLibros-Iteracion-4/CuisUniversity-4532.image!

!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 20:06:24' prior: 50335469!
                         configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) 
				monthNumber: (ccedSplitted at: 1). 
			
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].


! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 20:07:31' prior: 50335550!
                       configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) 
				monthNumber: (ccedSplitted at: 1). 
			self halt.
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].


! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 20:08:25' prior: 50335629!
             configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			self halt.
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) 
				monthNumber: (ccedSplitted at: 1). 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].


! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 20:10:11' prior: 50335708!
                configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			self halt.
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].


! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 20:14:48' prior: 50335793!
  configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].


! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 20:24:02' prior: 50335884!
          configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			self halt.
			request send400Response: (anError messageText) 
		]
	].


! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!

anError messageText!

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 20:27:56' prior: 50335963!
         configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].


! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!


TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 20:29:51' prior: 50336049!
       configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | clientId password purchases response | [
			clientId _ (request fields at: 'clientId') asNumber.
			password _ request fields at: 'password'.
			
			purchases _ shop listPurchasesOf: clientId with: password.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].


! !
!Shop methodsFor: 'facade' stamp: 'AW 6/28/2021 20:40:07' prior: 50333096!
                             listPurchasesOf: aClientId with: aClientPassword
	| dictionary purchases |
	self
		authenticateClient: aClientId
		withPassword: aClientPassword.
	purchases _ PurchasesSummary for: (self receiptsFor: aClientId).
	
	dictionary _ Dictionary new.
	
	
	! !
!Shop methodsFor: 'facade' stamp: 'AW 6/28/2021 20:40:48' prior: 50336246!
                        listPurchasesOf: aClientId with: aClientPassword
	| dictionary purchases |
	self
		authenticateClient: aClientId
		withPassword: aClientPassword.
	purchases _ PurchasesSummary for: (self receiptsFor: aClientId).
	dictionary _ Dictionary new.
	
	dictionary at: 'total' put: purchases total.! !
!Shop methodsFor: 'facade' stamp: 'AW 6/28/2021 20:41:25' prior: 50336257!
                listPurchasesOf: aClientId with: aClientPassword
	| dictionary purchases |
	self
		authenticateClient: aClientId
		withPassword: aClientPassword.
	purchases _ PurchasesSummary for: (self receiptsFor: aClientId).
	dictionary _ Dictionary new.
	
	dictionary at: 'total' put: purchases total.
	dictionary at: 'items' put: purchases items asArray.! !
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/28/2021 21:15:45' prior: 50334909!
                getEntriesAsDictionary: aEntryBag

	^(aEntryBag asSet collect: [ :item | | entryDictionary |
		entryDictionary _ Dictionary new.
		entryDictionary at: 'item'	 put: item.
		entryDictionary at: 'quantity'	 put: (aEntryBag ocurrencesOf: item).
		entryDictionary
	]) asArray.! !
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/28/2021 21:16:01' prior: 50336283!
                        getEntriesAsDictionary: aEntryBag

	^(aEntryBag asSet collect: [ :item | | entryDictionary |
		entryDictionary _ Dictionary new.
		entryDictionary at: 'item'	 put: item.
		entryDictionary at: 'quantity'	 put: (aEntryBag occurrencesOf: item).
		entryDictionary
	]) asArray.! !
!ShoppingCart methodsFor: 'adding' stamp: 'AW 6/28/2021 21:17:44' prior: 50333257!
                         add: aQuantity of: anItem 

	self assertQuantityIsValid: aQuantity.
	
	entries add: anItem withQuantity: aQuantity.! !
!ShoppingCart methodsFor: 'initialization' stamp: 'AW 6/28/2021 21:18:02' prior: 50333275 overrides: 16896425!
                          initialize

	entries := Bag new.! !
!ShoppingCart methodsFor: 'adding' stamp: 'AW 6/28/2021 21:18:29' prior: 50336307!
         add: aQuantity of: anItem 

	self assertQuantityIsValid: aQuantity.
	
	entries add: anItem withOccurrences: aQuantity.! !

!classRemoval: #ShoppingCartEntry stamp: 'AW 6/28/2021 21:18:55'!
Object subclass: #ShoppingCartEntry
	instanceVariableNames: 'item quantity'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!

!testRun: #ShoppingCartTest #test01EmptyCartHasNoItems stamp: 'AW 6/28/2021 21:19:14'!
PASSED!

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'AW 6/28/2021 21:19:14'!
ERROR!

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'AW 6/28/2021 21:19:14'!
FAILURE!

!testRun: #ShoppingCartTest #test04AddingANegativeQuantityRaisesError stamp: 'AW 6/28/2021 21:19:14'!
PASSED!

!testRun: #ShoppingCartTest #test05AddingZeroQuantityRaisesError stamp: 'AW 6/28/2021 21:19:14'!
PASSED!

!testRun: #ShoppingCartTest #test06AddingNonIntegerQuantityRaisesError stamp: 'AW 6/28/2021 21:19:14'!
PASSED!

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'AW 6/28/2021 21:19:19'!
ERROR!
!ShoppingCartTest methodsFor: 'assertions' stamp: 'AW 6/28/2021 21:26:52' prior: 50332479!
      assert: shoppingCart has: quantity of: item

	self assert: (shoppingCart entries occurrencesOf: item) equals: quantity ! !

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'AW 6/28/2021 21:27:02'!
PASSED!

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'AW 6/28/2021 21:27:04'!
FAILURE!
!ShoppingCartTest methodsFor: 'adding items' stamp: 'AW 6/28/2021 21:28:10' prior: 50332505!
test03AddingMultipleItemsToACart
	| shoppingCart |

	shoppingCart := ShoppingCart new.
	
	shoppingCart add: 1 of: book1.
	shoppingCart add: 2 of: book2.
	
	self assert: shoppingCart entries size equals: 3.
	self assert: shoppingCart has: 1 of: book1.
	self assert: shoppingCart has: 2 of: book2.! !

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'AW 6/28/2021 21:28:12'!
PASSED!

!testRun: #CheckOutTest #test01CheckoutEmptyCartShouldRaiseError stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #CheckOutTest #test03CheckoutACartWithMultipleItems stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #CheckOutTest #test04CheckoutItemWithoutPricesShouldRaiseError stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #CheckOutTest #test05CheckoutWithExpiredCardShouldRaiseError stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #CheckOutTest #test06CheckoutWithCardExpiredThisMonthShouldRaiseError stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #CheckOutTest #test07CheckoutWithStolenCardShouldRaiseError stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #CheckOutTest #test08CheckoutWithFakeCardShouldRaiseError stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #CheckOutTest #test09CheckoutWithInsufficientFundsShouldRaiseError stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #CheckOutTest #test10CheckoutWithInvalidCardNumberShouldRaiseError stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #CheckOutTest #test11CheckoutWithEmptyCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #CheckOutTest #test12CheckoutWithBlankCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #PriceListTest #test01AddItemWithNegativePriceShouldRaiseError stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #PriceListTest #test02AddItemWithZeroPriceShouldRaiseError stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShopTest #test01InvalidClientShallNotPass stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShopTest #test02NewCartsAreEmpty stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShopTest #test04ListInvalidCartShouldRaiseError stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShopTest #test05AddItemToCartDoesntModifyOtherCarts stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShopTest #test06CheckoutInvalidCartIdShouldRaiseError stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShopTest #test07CheckoutUsesTheCashier stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #ShopTest #test12ListPurchasesOfIncorrectPasswordShouldFail stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'AW 6/28/2021 21:28:24'!
ERROR!

!testRun: #ShopTest #test14CheckingOutAnExpiredCardShouldFail stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShopTest #test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShopTest #test16AddingItemsToAnExpiredCartShouldFail stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShoppingCartTest #test01EmptyCartHasNoItems stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShoppingCartTest #test04AddingANegativeQuantityRaisesError stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShoppingCartTest #test05AddingZeroQuantityRaisesError stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #ShoppingCartTest #test06AddingNonIntegerQuantityRaisesError stamp: 'AW 6/28/2021 21:28:24'!
PASSED!

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'AW 6/28/2021 21:28:28'!
ERROR!
!Cashier methodsFor: 'validation' stamp: 'AW 6/28/2021 21:29:10' prior: 50332588!
                              areAllItemsInPriceList: aBagOfShoppingCartEntries

	^ aBagOfShoppingCartEntries allSatisfy: [ :entry | priceList hasPriceFor: entry item ]! !
!Cashier methodsFor: 'validation' stamp: 'AW 6/28/2021 21:29:22' prior: 50336506!
areAllItemsInPriceList: aBagOfItems

	^ aBagOfItems allSatisfy: [ :entry | priceList hasPriceFor: entry item ]! !
!Cashier methodsFor: 'validation' stamp: 'AW 6/28/2021 21:29:46' prior: 50336513!
                            areAllItemsInPriceList: aBagOfItems

	^ aBagOfItems asSet allSatisfy: [ :item | priceList hasPriceFor: item ]! !

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'AW 6/28/2021 21:29:47'!
ERROR!
!Cashier methodsFor: 'private' stamp: 'AW 6/28/2021 21:31:29' prior: 50332569!
priceFor: anItem
	
	^(priceList priceFor: anItem item) * (anItem quantity).! !
!Cashier methodsFor: 'private' stamp: 'AW 6/28/2021 21:31:48' prior: 50336529!
  priceFor: anItem
	
	^priceList priceFor: anItem.! !
!Cashier methodsFor: 'private' stamp: 'AW 6/28/2021 21:32:34' prior: 50332544!
                             calculateShoppingCartTotal: aShoppingCart

	^ aShoppingCart entries sum: [ :item |
		self priceFor: item.
	] ifEmpty: [
		self error: self class cantCheckoutEmptyCartErrorDescription .
	]! !

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'AW 6/28/2021 21:32:38'!
ERROR!
!Cashier methodsFor: 'private' stamp: 'AW 6/28/2021 21:33:27' prior: 50332552!
                  createReceiptWithTotal: anAmountOfMoney cart: aShoppingCart 

	| receipt |
	
	receipt _ Receipt withTotal: anAmountOfMoney items: aShoppingCart entries.
	receiptBook add: receipt.
	
	^receipt .! !

aShoppingCart entries!

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'AW 6/28/2021 21:33:35'!
PASSED!

!testRun: #CheckOutTest #test03CheckoutACartWithMultipleItems stamp: 'AW 6/28/2021 21:33:36'!
PASSED!

!testRun: #CheckOutTest #test04CheckoutItemWithoutPricesShouldRaiseError stamp: 'AW 6/28/2021 21:33:37'!
PASSED!

!testRun: #CheckOutTest #test05CheckoutWithExpiredCardShouldRaiseError stamp: 'AW 6/28/2021 21:33:37'!
PASSED!

!testRun: #CheckOutTest #test06CheckoutWithCardExpiredThisMonthShouldRaiseError stamp: 'AW 6/28/2021 21:33:37'!
PASSED!

!testRun: #CheckOutTest #test07CheckoutWithStolenCardShouldRaiseError stamp: 'AW 6/28/2021 21:33:38'!
PASSED!

!testRun: #CheckOutTest #test08CheckoutWithFakeCardShouldRaiseError stamp: 'AW 6/28/2021 21:33:38'!
PASSED!

!testRun: #CheckOutTest #test09CheckoutWithInsufficientFundsShouldRaiseError stamp: 'AW 6/28/2021 21:33:38'!
PASSED!

!testRun: #CheckOutTest #test10CheckoutWithInvalidCardNumberShouldRaiseError stamp: 'AW 6/28/2021 21:33:38'!
PASSED!

!testRun: #CheckOutTest #test11CheckoutWithEmptyCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 21:33:39'!
PASSED!

!testRun: #CheckOutTest #test12CheckoutWithBlankCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 21:33:39'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 21:33:40'!
ERROR!
!Shop methodsFor: 'facade' stamp: 'AW 6/28/2021 21:34:59' prior: 50336269!
                            listPurchasesOf: aClientId with: aClientPassword
	| dictionary purchases |
	self
		authenticateClient: aClientId
		withPassword: aClientPassword.
	purchases _ PurchasesSummary for: (self receiptsFor: aClientId).
	dictionary _ Dictionary new.
	
	dictionary at: 'total' put: purchases total.
	dictionary at: 'items' put: purchases items asArray.
	^dictionary ! !

purchases items!

self asSet!
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/28/2021 21:38:51'!
                   getBagAsDictionaryArray: aEntryBag

	^(aEntryBag asSet collect: [ :item | | entryDictionary |
		entryDictionary _ Dictionary new.
		entryDictionary at: 'item'	 put: item.
		entryDictionary at: 'quantity'	 put: (aEntryBag occurrencesOf: item).
		entryDictionary
	]) asArray.! !
!Shop methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 21:38:51' prior: 50334622!
                   getCartEntries: aShoppingCartId

	^ self getBagAsDictionaryArray: (self getCart: aShoppingCartId) entries.! !

!methodRemoval: Shop #getEntriesAsDictionary: stamp: 'AW 6/28/2021 21:38:51'!
getEntriesAsDictionary: aEntryBag

	^(aEntryBag asSet collect: [ :item | | entryDictionary |
		entryDictionary _ Dictionary new.
		entryDictionary at: 'item'	 put: item.
		entryDictionary at: 'quantity'	 put: (aEntryBag occurrencesOf: item).
		entryDictionary
	]) asArray.!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 21:39:04'!
ERROR!
!Shop methodsFor: 'facade' stamp: 'AW 6/28/2021 21:39:45' prior: 50336603!
   listPurchasesOf: aClientId with: aClientPassword
	| dictionary purchases |
	self
		authenticateClient: aClientId
		withPassword: aClientPassword.
	purchases _ PurchasesSummary for: (self receiptsFor: aClientId).
	dictionary _ Dictionary new.
	
	dictionary at: 'total' put: purchases total.
	dictionary at: 'items' put: (self getBagAsDictionaryArray: purchases items).
	^dictionary ! !

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 21:39:48'!
ERROR!
!ShopTest methodsFor: 'check out and purchase listing' stamp: 'AW 6/28/2021 21:40:32' prior: 50332247!
                     test08ListPurchasesOnOnlyOneBuyClient
	
	| shop cartId clientId password purchases |
	
	shop := Shop withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) prices: stubs priceList merchantProcessor: stubs mockAlwaysOkMerchantProcessor timeProvider: stubs timeProvider.
		
	clientId := 15.
	password := '123456'.
	cartId := shop createCartClientId: clientId password: password.
	
	shop add: 2 of: stubs book1 to: cartId.
	
	shop checkOut: cartId payingWith: stubs validCreditCard.
	
	purchases := shop listPurchasesOf: clientId with: password.
	self assert: (purchases at: 'total') equals: 100.
	self assert: (purchases at: 'items') size equals: 2.
	self assert: (purchases items occurrencesOf: stubs book1) equals: 2.
	! !

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 21:40:37'!
FAILURE!
!ShopTest methodsFor: 'check out and purchase listing' stamp: 'AW 6/28/2021 21:43:11' prior: 50336669!
                   test08ListPurchasesOnOnlyOneBuyClient
	
	| shop cartId clientId password purchases |
	
	shop := Shop withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) prices: stubs priceList merchantProcessor: stubs mockAlwaysOkMerchantProcessor timeProvider: stubs timeProvider.
		
	clientId := 15.
	password := '123456'.
	cartId := shop createCartClientId: clientId password: password.
	
	shop add: 2 of: stubs book1 to: cartId.
	
	shop checkOut: cartId payingWith: stubs validCreditCard.
	
	purchases := shop listPurchasesOf: clientId with: password.
	self assert: (purchases total) equals: 100.
	self assert: (purchases items) size equals: 2.
	self assert: (purchases items occurrencesOf: stubs book1) equals: 2.
	! !
!Shop methodsFor: 'facade' stamp: 'AW 6/28/2021 21:44:01' prior: 50336650!
listPurchasesOf: aClientId with: aClientPassword
	| dictionary purchases |
	self
		authenticateClient: aClientId
		withPassword: aClientPassword.
	purchases _ PurchasesSummary for: (self receiptsFor: aClientId).
	dictionary _ Dictionary new.
	
	dictionary at: 'total' put: purchases total.
	dictionary at: 'items' put: (self getBagAsDictionaryArray: purchases items).
	^purchases ! !

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 21:44:03'!
PASSED!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'AW 6/28/2021 21:44:04'!
PASSED!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'AW 6/28/2021 21:44:05'!
PASSED!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'AW 6/28/2021 21:44:05'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'AW 6/28/2021 21:44:06'!
PASSED!

!testRun: #CheckOutTest #test01CheckoutEmptyCartShouldRaiseError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #CheckOutTest #test03CheckoutACartWithMultipleItems stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #CheckOutTest #test04CheckoutItemWithoutPricesShouldRaiseError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #CheckOutTest #test05CheckoutWithExpiredCardShouldRaiseError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #CheckOutTest #test06CheckoutWithCardExpiredThisMonthShouldRaiseError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #CheckOutTest #test07CheckoutWithStolenCardShouldRaiseError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #CheckOutTest #test08CheckoutWithFakeCardShouldRaiseError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #CheckOutTest #test09CheckoutWithInsufficientFundsShouldRaiseError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #CheckOutTest #test10CheckoutWithInvalidCardNumberShouldRaiseError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #CheckOutTest #test11CheckoutWithEmptyCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #CheckOutTest #test12CheckoutWithBlankCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #PriceListTest #test01AddItemWithNegativePriceShouldRaiseError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #PriceListTest #test02AddItemWithZeroPriceShouldRaiseError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test01InvalidClientShallNotPass stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test02NewCartsAreEmpty stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test04ListInvalidCartShouldRaiseError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test05AddItemToCartDoesntModifyOtherCarts stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test06CheckoutInvalidCartIdShouldRaiseError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test07CheckoutUsesTheCashier stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test12ListPurchasesOfIncorrectPasswordShouldFail stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test14CheckingOutAnExpiredCardShouldFail stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShopTest #test16AddingItemsToAnExpiredCartShouldFail stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShoppingCartTest #test01EmptyCartHasNoItems stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShoppingCartTest #test04AddingANegativeQuantityRaisesError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShoppingCartTest #test05AddingZeroQuantityRaisesError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!

!testRun: #ShoppingCartTest #test06AddingNonIntegerQuantityRaisesError stamp: 'AW 6/28/2021 21:44:13'!
PASSED!
!Shop methodsFor: 'facade' stamp: 'AW 6/28/2021 21:44:36' prior: 50336724!
  listPurchasesOf: aClientId with: aClientPassword
	| purchases |
	self
		authenticateClient: aClientId
		withPassword: aClientPassword.
	purchases _ PurchasesSummary for: (self receiptsFor: aClientId).
	
	^purchases ! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 21:46:35'!
           serializePurchases: aPurchasesSummary
	| dictionary |
	
	dictionary _ Dictionary new.
	
	dictionary at: 'total' put: aPurchasesSummary total.
	dictionary at: 'items' put: (self getBagAsDictionaryArray: aPurchasesSummary items).! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 21:46:42' prior: 50336884!
               serializePurchases: aPurchasesSummary
	| dictionary |
	
	dictionary _ Dictionary new.
	
	dictionary at: 'total' put: aPurchasesSummary total.
	dictionary at: 'items' put: (self getBagAsDictionaryArray: aPurchasesSummary items).
	
	^dictionary .! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 21:47:40' prior: 50336158!
                              configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | clientId password purchases response | [
			clientId _ (request fields at: 'clientId') asNumber.
			password _ request fields at: 'password'.
			
			purchases _ shop listPurchasesOf: clientId with: password.
			
			response _ Dictionary new.
			response at: 'purchases' put: (self serializePurchases: purchases).
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].


! !

!testRun: #CheckOutTest #test01CheckoutEmptyCartShouldRaiseError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #CheckOutTest #test03CheckoutACartWithMultipleItems stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #CheckOutTest #test04CheckoutItemWithoutPricesShouldRaiseError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #CheckOutTest #test05CheckoutWithExpiredCardShouldRaiseError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #CheckOutTest #test06CheckoutWithCardExpiredThisMonthShouldRaiseError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #CheckOutTest #test07CheckoutWithStolenCardShouldRaiseError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #CheckOutTest #test08CheckoutWithFakeCardShouldRaiseError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #CheckOutTest #test09CheckoutWithInsufficientFundsShouldRaiseError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #CheckOutTest #test10CheckoutWithInvalidCardNumberShouldRaiseError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #CheckOutTest #test11CheckoutWithEmptyCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #CheckOutTest #test12CheckoutWithBlankCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #PriceListTest #test01AddItemWithNegativePriceShouldRaiseError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #PriceListTest #test02AddItemWithZeroPriceShouldRaiseError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test01InvalidClientShallNotPass stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test02NewCartsAreEmpty stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test04ListInvalidCartShouldRaiseError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test05AddItemToCartDoesntModifyOtherCarts stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test06CheckoutInvalidCartIdShouldRaiseError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test07CheckoutUsesTheCashier stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test12ListPurchasesOfIncorrectPasswordShouldFail stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test14CheckingOutAnExpiredCardShouldFail stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShopTest #test16AddingItemsToAnExpiredCartShouldFail stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShoppingCartTest #test01EmptyCartHasNoItems stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShoppingCartTest #test04AddingANegativeQuantityRaisesError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShoppingCartTest #test05AddingZeroQuantityRaisesError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!

!testRun: #ShoppingCartTest #test06AddingNonIntegerQuantityRaisesError stamp: 'AW 6/28/2021 21:47:48'!
PASSED!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 21:48:12' prior: 50336907!
               configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | clientId password purchases response | [
			self halt.
			clientId _ (request fields at: 'clientId') asNumber.
			password _ request fields at: 'password'.
			
			purchases _ shop listPurchasesOf: clientId with: password.
			
			response _ Dictionary new.
			response at: 'purchases' put: (self serializePurchases: purchases).
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].


! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 21:50:18' prior: 50337116!
                  configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listPurchases' action: [ :request | | clientId password purchases response | [
			self halt.
			clientId _ (request fields at: 'clientId') asNumber.
			password _ request fields at: 'password'.
			
			purchases _ shop listPurchasesOf: clientId with: password.
			
			response _ Dictionary new.
			response at: 'purchases' put: (self serializePurchases: purchases).
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 21:55:38'!
                              handleListPurchasesRequest: request
	| clientId password purchases response |
	self halt.
	clientId _ (request fields at: 'clientId') asNumber.
	password _ request fields at: 'password'.
	
	purchases _ shop listPurchasesOf: clientId with: password.
	
	response _ Dictionary new.
	response at: 'purchases' put: (self serializePurchases: purchases).
	request send200Response: (WebUtils jsonEncode: response).


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 21:55:50' prior: 50337302!
                         handleListPurchasesRequest: aRequest
	| clientId password purchases response |
	self halt.
	clientId _ (aRequest fields at: 'clientId') asNumber.
	password _ aRequest fields at: 'password'.
	
	purchases _ shop listPurchasesOf: clientId with: password.
	
	response _ Dictionary new.
	response at: 'purchases' put: (self serializePurchases: purchases).
	aRequest send200Response: (WebUtils jsonEncode: response).


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 21:55:55' prior: 50337319!
                     handleListPurchasesRequest: aRequest
	| clientId password purchases response |
	
	self halt.
	clientId _ (aRequest fields at: 'clientId') asNumber.
	password _ aRequest fields at: 'password'.
	
	purchases _ shop listPurchasesOf: clientId with: password.
	
	response _ Dictionary new.
	response at: 'purchases' put: (self serializePurchases: purchases).
	aRequest send200Response: (WebUtils jsonEncode: response).


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 21:56:25' prior: 50337212!
                   configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listPurchases' action: [ :request | [
			self handleListPurchasesRequest: request
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 21:57:50' prior: 50337353!
      configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listPurchases' action: [ :request | [
			self handleListPurchasesRequest: request
		] onErrorDo: [ :anError |
			request send400Response: (anError messageText) 
		]
	].


! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 22:00:19' prior: 50337432!
               configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listPurchases' action: [ :request | 
		self handleListPurchasesRequest: request 
	] onErrorDo: [ :request :anError |
		request send400Response: (anError messageText) 
	].


! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 22:00:37'!
                          addService: aString action: aBlockClosure onErrorDo: aBlockClosure3 
	self shouldBeImplemented.! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 22:01:06' prior: 50337608!
                   addService: aRootString action: aBlockClosure onErrorDo: aErrorBlockClosure 
	self shouldBeImplemented.! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 22:02:47' prior: 50337615!
           addService: aRouteString action: aBlockClosure onErrorDo: aErrorBlockClosure 
	
	webServer addService: aRouteString action: [ :aRequest |
		(aBlockClosure value: aRequest) on: Error do: aErrorBlockClosure.
	].! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 22:04:34' prior: 50337622!
 addService: aRouteString action: aBlockClosure onErrorDo: aErrorBlockClosure 
	
	webServer addService: aRouteString action: [ :aRequest |
		(aBlockClosure value: aRequest) on: Error do: [ :anError |
			aErrorBlockClosure value: anError
		].
	].! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 22:09:08' prior: 50337632!
                              addService: aRouteString action: aBlockClosure onErrorDo: aErrorBlockClosure 
	
	webServer addService: aRouteString action: [ :aRequest |
		[ aBlockClosure value: aRequest ] on: Error do: [ :anError |
			aErrorBlockClosure value: anError
		].
	].! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 22:12:42' prior: 50337644!
                            addService: aRouteString action: aBlockClosure onErrorDo: aErrorBlockClosure 
	
	webServer addService: aRouteString action: ([ :aRequest |
		aBlockClosure value: aRequest 
	] on: Error do: [ :anError |
		aErrorBlockClosure value: anError
	]).! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 22:13:44' prior: 50334032!
addService: aRouteString action: aBlockClosure

	self addService: aRouteString 
		action: aBlockClosure 
		onErrorDo: [ :anError |
		
	].
! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 22:15:01' prior: 50337656!
        addService: aRouteString action: aBlockClosure onErrorDo: aErrorBlockClosure 
	
	webServer addService: aRouteString action: [ :aRequest |
		[ aBlockClosure value: aRequest ] on: Error do: [ :anError |
			aErrorBlockClosure value: aRequest value: anError.	
		] 
	].! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 22:16:29' prior: 50337667!
          addService: aRouteString action: aBlockClosure

	self addService: aRouteString 
		action: aBlockClosure 
		onErrorDo: [ :aRequest :anError |
		
	].
! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 22:16:45' prior: 50337687!
                              addService: aRouteString action: aBlockClosure

	self addService: aRouteString 
		action: aBlockClosure 
		onErrorDo: [ :aRequest :anError |
		aRequest send400Response: (anError messageText)
	].
! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 22:16:57' prior: 50337523!
               configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listPurchases' action: [ :request | 
		self handleListPurchasesRequest: request 
	].


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 22:20:07' prior: 50337706!
                             configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ request fields at: 'clientId'.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listPurchases' action: [ :request | 
		self handleListPurchasesRequest: request.
	].


! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!

clientReceipts at: aClientId!

		self at: '10'!

(self findElementOrNil: arg1)!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 23:30:07' prior: 50337783!
               configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ (request fields at: 'clientId') asNumber.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: cartItems.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listPurchases' action: [ :request | 
		self handleListPurchasesRequest: request.
	].


! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!

(self serializePurchases: purchases)!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 23:38:59' prior: 50337336!
                 handleListPurchasesRequest: aRequest
	| clientId password purchases response |
	
	clientId _ (aRequest fields at: 'clientId') asNumber.
	password _ aRequest fields at: 'password'.
	
	purchases _ shop listPurchasesOf: clientId with: password.
	
	response _ Dictionary new.
	response at: 'purchases' put: (self serializePurchases: purchases).
	aRequest send200Response: (WebUtils jsonEncode: response).


! !
!FormSection methodsFor: 'initialization' stamp: 'AW 6/28/2021 23:42:52' prior: 50814657!
               initializeWithTitle: arg1 withExplanation: arg2 withColor: arg3
	| temp4 |
	title _ arg1.
	explanation _ arg2.
	self separation: 3.
	self color: arg3.
	titleMorph _ LabelMorph 
		contents: title
		font: Preferences windowTitleFont
		emphasis: 1.
	temp4 _ LayoutSpec
		fixedWidth: titleMorph morphWidth
		fixedHeight: titleMorph morphHeight.
	temp4 offAxisEdgeWeight: 0.03.
	self
		addMorph: titleMorph
		layoutSpec: temp4.
	explanation isEmpty ifFalse: [
		explanationMorph _ ImmutableTextModelMorph
			withText: arg2
			withColor: arg3
			withWidth: self fixedWidthForTexts.
		self addMorph: explanationMorph ].! !
!LabeledInput methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 23:43:05' prior: 50814774!
                        withLabel: arg1 withWidth: arg2 withModel: arg3 usingAs: arg4
	| temp5 temp6 |
	self separation: 5.
	self layoutSpec:
		(LayoutSpec
			proportionalWidth: 0.95
			fixedHeight: LabeledInput recommendedHeight).
	labelMorph _ LabelMorph contents: arg1.
	temp5 _ LayoutSpec
		fixedWidth: arg2
		fixedHeight: labelMorph morphHeight
		offAxisEdgeWeight: #center.
	self
		addMorph: labelMorph
		layoutSpec: temp5.
	inputMorph _ TabPassingTextModelMorph withModel: arg3.
	inputMorph textMorph focusMover: arg4.
	arg4 addFocusReceiver: inputMorph textMorph.
	inputMorph hideScrollBarsIndefinitely.
	temp6 _ LayoutSpec
		fixedWidth: LabeledInput inputWidth * 0.7
		fixedHeight: labelMorph morphHeight + 2.
	self
		addMorph: inputMorph
		layoutSpec: temp6.! !
!MessageKeywordsAndParametersTable methodsFor: 'GUI building' stamp: 'AW 6/28/2021 23:43:22' prior: 50815089!
      buildColumnTitlesRowFor: arg1
	| temp2 temp3 |
	temp3 _ LayoutMorph newRow.
	temp3 color: self backgroundColor.
	temp3 separation: self columnSeparation.
	temp2 _ OrderedCollection newFrom: arg1.
	temp2 addFirst: ''.
	self needsToReorderRows ifTrue: [ temp2 addLast: 'Change order' ].
	temp2 withIndexDo: [ :arg4 :arg5 | | temp6 temp7 |
		temp7 _ LayoutMorph newRow.
		temp7 color: self backgroundColor.
		temp7 axisEdgeWeight: #center.
		temp7 addMorph: (LabelMorph contents: arg4).
		temp6 _ LayoutSpec fixedWidth: (columnWidths at: arg5).
		temp3
			addMorph: temp7
			layoutSpec: temp6 ].
	^ temp3.! !
!MessageKeywordsAndParametersTable methodsFor: 'initialization' stamp: 'AW 6/28/2021 23:43:31' prior: 50814979!
                  withRows: arg1 withColor: arg2 withPreviewModel: arg3 withRefactoringModel: arg4
	| temp5 temp6 temp7 temp8 temp9 temp10 temp11 |
	backgroundColor _ arg2.
	rowModels _ OrderedCollection new.
	previewModel _ arg3.
	refactoringModel _ arg4.
	variablesToParametrize _ arg1.
	temp5 _ 4.
	self separation: temp5.
	temp7 _ arg1 size + 1.
	temp6 _ self rowHeight * temp7 + (temp5 * (temp7 + 1)) * 1.1.
	temp10 _ #('Keyword' 'Parameter name' ).
	columnWidths _ self
		columnWidthsRequiredForRowTitles: arg1
		forInputColumns: temp10 size.
	temp9 _ columnWidths sum + (self columnSeparation * (columnWidths size + 1)) * 1.1.
	self layoutSpec:
		(LayoutSpec
			fixedWidth: temp9
			fixedHeight: temp6).
	temp8 _ self buildColumnTitlesRowFor: temp10.
	self
		addMorph: temp8
		layoutSpec: self rowsLayoutSpec.
	arg1 withIndexDo: [ :arg13 :arg14 | | temp15 temp16 temp17 temp18 temp19 |
		temp15 _ LayoutMorph newRow.
		temp15
			color: self backgroundColor;
			separation: self columnSeparation.
		temp15
			addMorph: (LabelMorph contents: arg13)
			layoutSpec: (LayoutSpec fixedWidth: (columnWidths at: 1)).
		temp18 _ LayoutSpec
			fixedWidth: (columnWidths at: 2)
			fixedHeight: self rowHeight.
		temp17 _ self buildInputMorphWith: (arg4 keywordModelOf: arg13).
		temp15
			addMorph: temp17
			layoutSpec: temp18.
		temp19 _ self buildInputMorphWith: (arg4 parameterModelOf: arg13).
		temp15
			addMorph: temp19
			layoutSpec: temp18.
		self needsToReorderRows ifTrue: [
			temp16 _ ChangeRowOrderButtonModel
				for: arg1 size - (arg14 - 1)
				notifying: self.
			rowModels addFirst: temp16.
			temp11 _ self buildChangeOrderButtonsWith: temp16.
			temp15
				addMorph: temp11
				layoutSpec: (LayoutSpec fixedWidth: columnWidths last) ].
		self
			addMorph: temp15
			layoutSpec: self rowsLayoutSpec ].! !

!classDefinition: #BagSerializer category: 'Tus-Libros' stamp: 'AW 6/28/2021 23:48:18'!
Object subclass: #BagSerializer
	instanceVariableNames: 'bag'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros'!
!BagSerializer class methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 23:48:18'!
 getBagAsDictionaryArray: aBag
	^self new initializeGetBagAsDictionaryArray: aBag! !
!BagSerializer methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 23:48:18'!
                           initializeGetBagAsDictionaryArray: aBag
	bag := aBag.! !
!BagSerializer methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 23:48:18'!
                      getBagAsDictionaryArray

	^(bag asSet collect: [ :item | | entryDictionary |
		entryDictionary _ Dictionary new.
		entryDictionary at: 'item'	 put: item.
		entryDictionary at: 'quantity'	 put: (bag occurrencesOf: item).
		entryDictionary
	]) asArray.! !
!Shop methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 23:48:18' prior: 50336618!
          getBagAsDictionaryArray: aEntryBag
	^(BagSerializer getBagAsDictionaryArray: aEntryBag) getBagAsDictionaryArray! !
!BagSerializer methodsFor: 'initialization' stamp: 'AW 6/28/2021 23:49:09'!
 initializeWith: aBag
	bag := aBag.! !
!BagSerializer class methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 23:49:09' prior: 50338113!
                   getBagAsDictionaryArray: aBag
	^self new initializeWith: aBag! !

!methodRemoval: BagSerializer #initializeGetBagAsDictionaryArray: stamp: 'AW 6/28/2021 23:49:09'!
initializeGetBagAsDictionaryArray: aBag
	bag := aBag.!
!BagSerializer class methodsFor: 'instance creation' stamp: 'AW 6/28/2021 23:50:54' prior: 50338146!
getBagAsDictionaryArray: aBag
	^(self new initializeWith: aBag) getBagAsDictionaryArray ! !
!BagSerializer class methodsFor: 'instance creation' stamp: 'AW 6/28/2021 23:51:17' prior: 50338156!
                               getBagAsDictionaryArray: aBag
	^self new initializeWith: aBag ! !
!BagSerializer class methodsFor: 'instance creation' stamp: 'AW 6/28/2021 23:51:19' prior: 50338163!
                         getBagAsDictionaryArray: aBag
	^self new initializeWith: aBag ! !
!BagSerializer class methodsFor: 'instance creation' stamp: 'AW 6/28/2021 23:51:57'!
         bag: aBag
	^self new initializeWith: aBag ! !
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/28/2021 23:51:57'!
             bag: aEntryBag
	^(BagSerializer getBagAsDictionaryArray: aEntryBag) getBagAsDictionaryArray! !
!Shop methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 23:51:57' prior: 50336630!
         getCartEntries: aShoppingCartId

	^ self bag: (self getCart: aShoppingCartId) entries.! !
!Shop methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 23:51:57' prior: 50338135!
              getBagAsDictionaryArray: aEntryBag
	^(BagSerializer bag: aEntryBag) getBagAsDictionaryArray! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 23:51:57' prior: 50336895!
                       serializePurchases: aPurchasesSummary
	| dictionary |
	
	dictionary _ Dictionary new.
	
	dictionary at: 'total' put: aPurchasesSummary total.
	dictionary at: 'items' put: (self bag: aPurchasesSummary items).
	
	^dictionary .! !
!Shop methodsFor: 'as yet unclassified' stamp: 'AW 6/28/2021 23:51:57' prior: 50338178!
    bag: aEntryBag
	^(BagSerializer bag: aEntryBag) getBagAsDictionaryArray! !

!methodRemoval: BagSerializer class #getBagAsDictionaryArray: stamp: 'AW 6/28/2021 23:51:57'!
getBagAsDictionaryArray: aBag
	^self new initializeWith: aBag !

!methodRemoval: Shop #getBagAsDictionaryArray: stamp: 'AW 6/28/2021 23:51:57'!
getBagAsDictionaryArray: aEntryBag
	^(BagSerializer bag: aEntryBag) getBagAsDictionaryArray!
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/28/2021 23:54:13' prior: 50338184!
                    getCartEntries: aShoppingCartId

	| entriesBag |
	entriesBag _ (self getCart: aShoppingCartId) entries.
	^ (BagSerializer bag: entriesBag) getBagAsDictionaryArray .! !

!testRun: #CheckOutTest #test01CheckoutEmptyCartShouldRaiseError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #CheckOutTest #test03CheckoutACartWithMultipleItems stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #CheckOutTest #test04CheckoutItemWithoutPricesShouldRaiseError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #CheckOutTest #test05CheckoutWithExpiredCardShouldRaiseError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #CheckOutTest #test06CheckoutWithCardExpiredThisMonthShouldRaiseError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #CheckOutTest #test07CheckoutWithStolenCardShouldRaiseError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #CheckOutTest #test08CheckoutWithFakeCardShouldRaiseError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #CheckOutTest #test09CheckoutWithInsufficientFundsShouldRaiseError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #CheckOutTest #test10CheckoutWithInvalidCardNumberShouldRaiseError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #CheckOutTest #test11CheckoutWithEmptyCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #CheckOutTest #test12CheckoutWithBlankCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #PriceListTest #test01AddItemWithNegativePriceShouldRaiseError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #PriceListTest #test02AddItemWithZeroPriceShouldRaiseError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test01InvalidClientShallNotPass stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test02NewCartsAreEmpty stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test04ListInvalidCartShouldRaiseError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test05AddItemToCartDoesntModifyOtherCarts stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test06CheckoutInvalidCartIdShouldRaiseError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test07CheckoutUsesTheCashier stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test12ListPurchasesOfIncorrectPasswordShouldFail stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test14CheckingOutAnExpiredCardShouldFail stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShopTest #test16AddingItemsToAnExpiredCartShouldFail stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShoppingCartTest #test01EmptyCartHasNoItems stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShoppingCartTest #test04AddingANegativeQuantityRaisesError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShoppingCartTest #test05AddingZeroQuantityRaisesError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!testRun: #ShoppingCartTest #test06AddingNonIntegerQuantityRaisesError stamp: 'AW 6/28/2021 23:54:25'!
PASSED!

!methodRemoval: Shop #bag: stamp: 'AW 6/28/2021 23:54:40'!
bag: aEntryBag
	^(BagSerializer bag: aEntryBag) getBagAsDictionaryArray!

!testRun: #CheckOutTest #test01CheckoutEmptyCartShouldRaiseError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #CheckOutTest #test03CheckoutACartWithMultipleItems stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #CheckOutTest #test04CheckoutItemWithoutPricesShouldRaiseError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #CheckOutTest #test05CheckoutWithExpiredCardShouldRaiseError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #CheckOutTest #test06CheckoutWithCardExpiredThisMonthShouldRaiseError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #CheckOutTest #test07CheckoutWithStolenCardShouldRaiseError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #CheckOutTest #test08CheckoutWithFakeCardShouldRaiseError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #CheckOutTest #test09CheckoutWithInsufficientFundsShouldRaiseError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #CheckOutTest #test10CheckoutWithInvalidCardNumberShouldRaiseError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #CheckOutTest #test11CheckoutWithEmptyCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #CheckOutTest #test12CheckoutWithBlankCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #PriceListTest #test01AddItemWithNegativePriceShouldRaiseError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #PriceListTest #test02AddItemWithZeroPriceShouldRaiseError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test01InvalidClientShallNotPass stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test02NewCartsAreEmpty stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test04ListInvalidCartShouldRaiseError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test05AddItemToCartDoesntModifyOtherCarts stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test06CheckoutInvalidCartIdShouldRaiseError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test07CheckoutUsesTheCashier stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test12ListPurchasesOfIncorrectPasswordShouldFail stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test14CheckingOutAnExpiredCardShouldFail stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShopTest #test16AddingItemsToAnExpiredCartShouldFail stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShoppingCartTest #test01EmptyCartHasNoItems stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShoppingCartTest #test04AddingANegativeQuantityRaisesError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShoppingCartTest #test05AddingZeroQuantityRaisesError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!

!testRun: #ShoppingCartTest #test06AddingNonIntegerQuantityRaisesError stamp: 'AW 6/28/2021 23:54:43'!
PASSED!
!Shop methodsFor: 'cart persistence' stamp: 'AW 6/28/2021 23:56:15' prior: 50338223!
  getCartEntries: aShoppingCartId

	^(self getCart: aShoppingCartId) entries.! !

!testRun: #CheckOutTest #test01CheckoutEmptyCartShouldRaiseError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #CheckOutTest #test03CheckoutACartWithMultipleItems stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #CheckOutTest #test04CheckoutItemWithoutPricesShouldRaiseError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #CheckOutTest #test05CheckoutWithExpiredCardShouldRaiseError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #CheckOutTest #test06CheckoutWithCardExpiredThisMonthShouldRaiseError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #CheckOutTest #test07CheckoutWithStolenCardShouldRaiseError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #CheckOutTest #test08CheckoutWithFakeCardShouldRaiseError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #CheckOutTest #test09CheckoutWithInsufficientFundsShouldRaiseError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #CheckOutTest #test10CheckoutWithInvalidCardNumberShouldRaiseError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #CheckOutTest #test11CheckoutWithEmptyCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #CheckOutTest #test12CheckoutWithBlankCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #PriceListTest #test01AddItemWithNegativePriceShouldRaiseError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #PriceListTest #test02AddItemWithZeroPriceShouldRaiseError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test01InvalidClientShallNotPass stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test02NewCartsAreEmpty stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 23:56:54'!
FAILURE!

!testRun: #ShopTest #test04ListInvalidCartShouldRaiseError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test05AddItemToCartDoesntModifyOtherCarts stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test06CheckoutInvalidCartIdShouldRaiseError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test07CheckoutUsesTheCashier stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test12ListPurchasesOfIncorrectPasswordShouldFail stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test14CheckingOutAnExpiredCardShouldFail stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test16AddingItemsToAnExpiredCartShouldFail stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShoppingCartTest #test01EmptyCartHasNoItems stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShoppingCartTest #test04AddingANegativeQuantityRaisesError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShoppingCartTest #test05AddingZeroQuantityRaisesError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShoppingCartTest #test06AddingNonIntegerQuantityRaisesError stamp: 'AW 6/28/2021 23:56:54'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 23:56:54'!
FAILURE!
!ShopTest methodsFor: 'cart creation and listing' stamp: 'AW 6/28/2021 23:57:22' prior: 50334586!
       test03ListCartWithOneItem
	
	| shop cartId cartItems bookIsbn quantity |
	
	shop := Shop 
		withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) 
		prices: stubs priceList 
		merchantProcessor: stubs mockAlwaysOkMerchantProcessor 
		timeProvider: stubs timeProvider.
	
	cartId := shop createCartClientId: 3 password: '1234'.
	
	quantity := 2.
	bookIsbn := 'book_isbn'.
		
	shop add: quantity of: bookIsbn to: cartId.
	
	cartItems := shop listCart: cartId.
	
	self assert: cartItems size equals: 2.
	self assert: (cartItems first at: 'quantity') equals: quantity.
	self assert: (cartItems first at: 'item') equals: bookIsbn.! !

(cartItems occurrencesOf: bookIsbn)!
!ShopTest methodsFor: 'cart creation and listing' stamp: 'AW 6/28/2021 23:59:17' prior: 50338602!
                     test03ListCartWithOneItem
	
	| shop cartId cartItems bookIsbn quantity |
	
	shop := Shop 
		withUserAuthenticator: (MockUserAuthenticator alwaysReturning: true) 
		prices: stubs priceList 
		merchantProcessor: stubs mockAlwaysOkMerchantProcessor 
		timeProvider: stubs timeProvider.
	
	cartId := shop createCartClientId: 3 password: '1234'.
	
	quantity := 2.
	bookIsbn := 'book_isbn'.
		
	shop add: quantity of: bookIsbn to: cartId.
	
	cartItems := shop listCart: cartId.
	
	self assert: cartItems size equals: 2.
	self assert: (cartItems occurrencesOf: bookIsbn) equals: quantity.! !

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 23:59:23'!
PASSED!

!testRun: #CheckOutTest #test01CheckoutEmptyCartShouldRaiseError stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #CheckOutTest #test02CheckoutACartWithOneItem stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #CheckOutTest #test03CheckoutACartWithMultipleItems stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #CheckOutTest #test04CheckoutItemWithoutPricesShouldRaiseError stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #CheckOutTest #test05CheckoutWithExpiredCardShouldRaiseError stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #CheckOutTest #test06CheckoutWithCardExpiredThisMonthShouldRaiseError stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #CheckOutTest #test07CheckoutWithStolenCardShouldRaiseError stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #CheckOutTest #test08CheckoutWithFakeCardShouldRaiseError stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #CheckOutTest #test09CheckoutWithInsufficientFundsShouldRaiseError stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #CheckOutTest #test10CheckoutWithInvalidCardNumberShouldRaiseError stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #CheckOutTest #test11CheckoutWithEmptyCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #CheckOutTest #test12CheckoutWithBlankCardOwnerNameShouldRaiseError stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #PriceListTest #test01AddItemWithNegativePriceShouldRaiseError stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #PriceListTest #test02AddItemWithZeroPriceShouldRaiseError stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test01InvalidClientShallNotPass stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test02NewCartsAreEmpty stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test03ListCartWithOneItem stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test04ListInvalidCartShouldRaiseError stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test05AddItemToCartDoesntModifyOtherCarts stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test06CheckoutInvalidCartIdShouldRaiseError stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test07CheckoutUsesTheCashier stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test08ListPurchasesOnOnlyOneBuyClient stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test09ListPurchasesOfManyItemsByOneClient stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test10CheckoutWithInvalidCreditCardShouldFail stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test11ListMultiplePurchasesOfTheSameClient stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test12ListPurchasesOfIncorrectPasswordShouldFail stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test13ListPurchasesOfDifferentClients stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test14CheckingOutAnExpiredCardShouldFail stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test15CheckingOutInADifferentPointInTimeShouldWorkAsIntended stamp: 'AW 6/28/2021 23:59:27'!
PASSED!

!testRun: #ShopTest #test16AddingItemsToAnExpiredCartShouldFail stamp: 'AW 6/28/2021 23:59:28'!
PASSED!

!testRun: #ShoppingCartTest #test01EmptyCartHasNoItems stamp: 'AW 6/28/2021 23:59:28'!
PASSED!

!testRun: #ShoppingCartTest #test02AddingAnItemToACart stamp: 'AW 6/28/2021 23:59:28'!
PASSED!

!testRun: #ShoppingCartTest #test03AddingMultipleItemsToACart stamp: 'AW 6/28/2021 23:59:28'!
PASSED!

!testRun: #ShoppingCartTest #test04AddingANegativeQuantityRaisesError stamp: 'AW 6/28/2021 23:59:28'!
PASSED!

!testRun: #ShoppingCartTest #test05AddingZeroQuantityRaisesError stamp: 'AW 6/28/2021 23:59:28'!
PASSED!

!testRun: #ShoppingCartTest #test06AddingNonIntegerQuantityRaisesError stamp: 'AW 6/28/2021 23:59:28'!
PASSED!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:04:08' prior: 50337868!
       configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ (request fields at: 'clientId') asNumber.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: (BagSerializer bag: cartItems) getBagAsDictionaryArray .
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listPurchases' action: [ :request | 
		self handleListPurchasesRequest: request.
	].


! !
!BagSerializer methodsFor: 'evaluating' stamp: 'AW 6/29/2021 00:04:23'!
      asDictionaryArray

	^(bag asSet collect: [ :item | | entryDictionary |
		entryDictionary _ Dictionary new.
		entryDictionary at: 'item'	 put: item.
		entryDictionary at: 'quantity'	 put: (bag occurrencesOf: item).
		entryDictionary
	]) asArray.! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:04:23' prior: 50338771!
                              configRoutes
	
	
	self addService: '/createCart' action: [ :request | | cartId clientId clientPassword response | [
			clientId _ (request fields at: 'clientId') asNumber.
			clientPassword _ request fields at: 'password'.
			cartId _ shop createCartClientId: clientId password: clientPassword.
			
			response _ Dictionary new.
			response at: 'cartId' put: cartId.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: (BagSerializer bag: cartItems) asDictionaryArray .
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listPurchases' action: [ :request | 
		self handleListPurchasesRequest: request.
	].


! !

!methodRemoval: BagSerializer #getBagAsDictionaryArray stamp: 'AW 6/29/2021 00:04:23'!
getBagAsDictionaryArray

	^(bag asSet collect: [ :item | | entryDictionary |
		entryDictionary _ Dictionary new.
		entryDictionary at: 'item'	 put: item.
		entryDictionary at: 'quantity'	 put: (bag occurrencesOf: item).
		entryDictionary
	]) asArray.!

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:06:29' prior: 50337958!
                         handleListPurchasesRequest: aRequest
	| clientId password purchases response |
	
	self halt.
	clientId _ (aRequest fields at: 'clientId') asNumber.
	password _ aRequest fields at: 'password'.
	
	purchases _ shop listPurchasesOf: clientId with: password.
	
	response _ Dictionary new.
	response at: 'purchases' put: (self serializePurchases: purchases).
	aRequest send200Response: (WebUtils jsonEncode: response).


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:07:26' prior: 50338197!
                   serializePurchases: aPurchasesSummary
	| dictionary |
	
	dictionary _ Dictionary new.
	
	dictionary at: 'total' put: aPurchasesSummary total.
	dictionary at: 'items' put: (BagSerializer bag: aPurchasesSummary items) asDictionaryArray.
	
	^dictionary .! !

aPurchasesSummary items!

(BagSerializer bag: aPurchasesSummary items) asDictionaryArray!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:08:39' prior: 50338955!
                            handleListPurchasesRequest: aRequest
	| clientId password purchases response |
	
	clientId _ (aRequest fields at: 'clientId') asNumber.
	password _ aRequest fields at: 'password'.
	
	purchases _ shop listPurchasesOf: clientId with: password.
	
	response _ Dictionary new.
	response at: 'purchases' put: (self serializePurchases: purchases).
	aRequest send200Response: (WebUtils jsonEncode: response).


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:10:46'!
               handleCreateCartRequest: request
	| cartId clientId clientPassword response |
	clientId _ (request fields at: 'clientId') asNumber.
	clientPassword _ request fields at: 'password'.
	cartId _ shop createCartClientId: clientId password: clientPassword.
	
	response _ Dictionary new.
	response at: 'cartId' put: cartId.
	request send200Response: (WebUtils jsonEncode: response).
! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:10:53' prior: 50339003!
                          handleCreateCartRequest: request
	| cartId clientId clientPassword response |
	
	clientId _ (request fields at: 'clientId') asNumber.
	clientPassword _ request fields at: 'password'.
	cartId _ shop createCartClientId: clientId password: clientPassword.
	
	response _ Dictionary new.
	response at: 'cartId' put: cartId.
	request send200Response: (WebUtils jsonEncode: response).
! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:10:56' prior: 50339019!
                        handleCreateCartRequest: Arequest
	| cartId clientId clientPassword response |
	
	clientId _ (Arequest fields at: 'clientId') asNumber.
	clientPassword _ Arequest fields at: 'password'.
	cartId _ shop createCartClientId: clientId password: clientPassword.
	
	response _ Dictionary new.
	response at: 'cartId' put: cartId.
	Arequest send200Response: (WebUtils jsonEncode: response).
! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:11:01' prior: 50339035!
                    handleCreateCartRequest: aRequest
	| cartId clientId clientPassword response |
	
	clientId _ (aRequest fields at: 'clientId') asNumber.
	clientPassword _ aRequest fields at: 'password'.
	cartId _ shop createCartClientId: clientId password: clientPassword.
	
	response _ Dictionary new.
	response at: 'cartId' put: cartId.
	aRequest send200Response: (WebUtils jsonEncode: response).
! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:11:45'!
    handleAddToCartRequest: request
	
	| bookIsbn bookQuantity cartId response |
	cartId _ (request fields at: 'cartId') asNumber .
	bookIsbn _ request fields at: 'bookIsbn'.
	bookQuantity _ (request fields at: 'bookQuantity') asNumber.
	
	shop add: bookQuantity of: bookIsbn to: cartId.
	
	response _ Dictionary new.
	response at: 'response' put: 'OK'.
	request send200Response: (WebUtils jsonEncode: response).! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:11:53' prior: 50339066!
                          handleAddToCartRequest: request
	| bookIsbn bookQuantity cartId response |
	
	cartId _ (request fields at: 'cartId') asNumber .
	bookIsbn _ request fields at: 'bookIsbn'.
	bookQuantity _ (request fields at: 'bookQuantity') asNumber.
	
	shop add: bookQuantity of: bookIsbn to: cartId.
	
	response _ Dictionary new.
	response at: 'response' put: 'OK'.
	request send200Response: (WebUtils jsonEncode: response).! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:11:56' prior: 50339083!
                          handleAddToCartRequest: aRequest
	| bookIsbn bookQuantity cartId response |
	
	cartId _ (aRequest fields at: 'cartId') asNumber .
	bookIsbn _ aRequest fields at: 'bookIsbn'.
	bookQuantity _ (aRequest fields at: 'bookQuantity') asNumber.
	
	shop add: bookQuantity of: bookIsbn to: cartId.
	
	response _ Dictionary new.
	response at: 'response' put: 'OK'.
	aRequest send200Response: (WebUtils jsonEncode: response).! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:12:24'!
     handleListCart: request
	| cartId cartItems response |
	cartId _ (request fields at: 'cartId') asNumber .
	cartItems _ shop listCart: cartId.
	
	response _ Dictionary new.
	response at: 'items' put: (BagSerializer bag: cartItems) asDictionaryArray .
	request send200Response: (WebUtils jsonEncode: response).! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:12:29' prior: 50339116!
                              handleListCart: request
	| cartId cartItems response |
	
	cartId _ (request fields at: 'cartId') asNumber .
	cartItems _ shop listCart: cartId.
	
	response _ Dictionary new.
	response at: 'items' put: (BagSerializer bag: cartItems) asDictionaryArray .
	request send200Response: (WebUtils jsonEncode: response).! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:12:34' prior: 50339130!
                            handleListCart: aRequest
	| cartId cartItems response |
	
	cartId _ (aRequest fields at: 'cartId') asNumber .
	cartItems _ shop listCart: cartId.
	
	response _ Dictionary new.
	response at: 'items' put: (BagSerializer bag: cartItems) asDictionaryArray .
	aRequest send200Response: (WebUtils jsonEncode: response).! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:13:19'!
         handleCheckOutCart: request
			| cartId cced ccedSplitted ccn cco creditCard response |
	cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:13:40' prior: 50339157!
  handleCheckOutCart: request
	| cartId cced ccedSplitted ccn cco creditCard response |
	
	cartId _ (request fields at: 'cartId') asNumber .
	ccn _ request fields at: 'ccn' .
	ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
	cco _ request fields at: 'cco'.
	cced _ GregorianMonthOfYear 
		yearNumber: (ccedSplitted at: 2) asNumber
		monthNumber: (ccedSplitted at: 1) asNumber. 
	creditCard _ CreditCard number: ccn owner: cco expiration: cced.

	shop checkOut: cartId payingWith: creditCard.

	response _ Dictionary new.
	response at: 'response' put: 'OK'.
	request send200Response: (WebUtils jsonEncode: response).


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:13:45' prior: 50339181!
                              handleCheckOutCart: aRequest
	| cartId cced ccedSplitted ccn cco creditCard response |
	
	cartId _ (aRequest fields at: 'cartId') asNumber .
	ccn _ aRequest fields at: 'ccn' .
	ccedSplitted _ (aRequest fields at: 'cced') findTokens: '/'.
	cco _ aRequest fields at: 'cco'.
	cced _ GregorianMonthOfYear 
		yearNumber: (ccedSplitted at: 2) asNumber
		monthNumber: (ccedSplitted at: 1) asNumber. 
	creditCard _ CreditCard number: ccn owner: cco expiration: cced.

	shop checkOut: cartId payingWith: creditCard.

	response _ Dictionary new.
	response at: 'response' put: 'OK'.
	aRequest send200Response: (WebUtils jsonEncode: response).


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:14:52' prior: 50338860!
                        configRoutes
	
	
	self addService: '/createCart' action: [ :request | 
		self handleCreateCartRequest: request.
	].

	self addService: '/addToCart' action: [ :request | | cartId bookIsbn bookQuantity response | [
			cartId _ (request fields at: 'cartId') asNumber .
			bookIsbn _ request fields at: 'bookIsbn'.
			bookQuantity _ (request fields at: 'bookQuantity') asNumber.
			
			shop add: bookQuantity of: bookIsbn to: cartId.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: (BagSerializer bag: cartItems) asDictionaryArray .
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listPurchases' action: [ :request | 
		self handleListPurchasesRequest: request.
	].


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:15:08' prior: 50339229!
                            configRoutes
	
	
	self addService: '/createCart' action: [ :request | 
		self handleCreateCartRequest: request.
	].

	self addService: '/addToCart' action: [ :request | 
		self handleAddToCartRequest: request.
	].

	self addService: '/listCart' action: [ :request | | cartId response cartItems | [
			cartId _ (request fields at: 'cartId') asNumber .
			cartItems _ shop listCart: cartId.
			
			response _ Dictionary new.
			response at: 'items' put: (BagSerializer bag: cartItems) asDictionaryArray .
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listPurchases' action: [ :request | 
		self handleListPurchasesRequest: request.
	].


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:15:27' prior: 50339295!
                   configRoutes
	
	
	self addService: '/createCart' action: [ :request | 
		self handleCreateCartRequest: request.
	].

	self addService: '/addToCart' action: [ :request | 
		self handleAddToCartRequest: request.
	].

	self addService: '/listCart' action: [ :request |
		self handleListCart: request.
	].

	self addService: '/checkOutCart' action: [ :request | | cartId ccn cced ccedSplitted cco creditCard response | [
			cartId _ (request fields at: 'cartId') asNumber .
			ccn _ request fields at: 'ccn' .
			ccedSplitted _ (request fields at: 'cced') findTokens: '/'.
			cco _ request fields at: 'cco'.
			cced _ GregorianMonthOfYear 
				yearNumber: (ccedSplitted at: 2) asNumber
				monthNumber: (ccedSplitted at: 1) asNumber. 
			creditCard _ CreditCard number: ccn owner: cco expiration: cced.
			
			shop checkOut: cartId payingWith: creditCard.
			
			response _ Dictionary new.
			response at: 'response' put: 'OK'.
			request send200Response: (WebUtils jsonEncode: response).
		] on: Error do: [ :anError |
			request send400Response: (anError messageText) 
		]
	].

	self addService: '/listPurchases' action: [ :request | 
		self handleListPurchasesRequest: request.
	].


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:15:49' prior: 50339347!
                   configRoutes
	
	
	self addService: '/createCart' action: [ :request | 
		self handleCreateCartRequest: request.
	].

	self addService: '/addToCart' action: [ :request | 
		self handleAddToCartRequest: request.
	].

	self addService: '/listCart' action: [ :request |
		self handleListCart: request.
	].

	self addService: '/checkOutCart' action: [ :request | 
		self handleCheckOutCart: request.
	].

	self addService: '/listPurchases' action: [ :request | 
		self handleListPurchasesRequest: request.
	].


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:16:12'!
       handleListCartRequest: aRequest
	| cartId cartItems response |
	
	cartId _ (aRequest fields at: 'cartId') asNumber .
	cartItems _ shop listCart: cartId.
	
	response _ Dictionary new.
	response at: 'items' put: (BagSerializer bag: cartItems) asDictionaryArray .
	aRequest send200Response: (WebUtils jsonEncode: response).! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:16:12' prior: 50339388!
                  configRoutes
	
	
	self addService: '/createCart' action: [ :request | 
		self handleCreateCartRequest: request.
	].

	self addService: '/addToCart' action: [ :request | 
		self handleAddToCartRequest: request.
	].

	self addService: '/listCart' action: [ :request |
		self handleListCartRequest: request.
	].

	self addService: '/checkOutCart' action: [ :request | 
		self handleCheckOutCart: request.
	].

	self addService: '/listPurchases' action: [ :request | 
		self handleListPurchasesRequest: request.
	].


! !

!methodRemoval: TusLibrosRestInterface #handleListCart: stamp: 'AW 6/29/2021 00:16:12'!
handleListCart: aRequest
	| cartId cartItems response |
	
	cartId _ (aRequest fields at: 'cartId') asNumber .
	cartItems _ shop listCart: cartId.
	
	response _ Dictionary new.
	response at: 'items' put: (BagSerializer bag: cartItems) asDictionaryArray .
	aRequest send200Response: (WebUtils jsonEncode: response).!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:16:22'!
            handleCheckOutCartRequest: aRequest
	| cartId cced ccedSplitted ccn cco creditCard response |
	
	cartId _ (aRequest fields at: 'cartId') asNumber .
	ccn _ aRequest fields at: 'ccn' .
	ccedSplitted _ (aRequest fields at: 'cced') findTokens: '/'.
	cco _ aRequest fields at: 'cco'.
	cced _ GregorianMonthOfYear 
		yearNumber: (ccedSplitted at: 2) asNumber
		monthNumber: (ccedSplitted at: 1) asNumber. 
	creditCard _ CreditCard number: ccn owner: cco expiration: cced.

	shop checkOut: cartId payingWith: creditCard.

	response _ Dictionary new.
	response at: 'response' put: 'OK'.
	aRequest send200Response: (WebUtils jsonEncode: response).


! !
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:16:22' prior: 50339421!
                 configRoutes
	
	
	self addService: '/createCart' action: [ :request | 
		self handleCreateCartRequest: request.
	].

	self addService: '/addToCart' action: [ :request | 
		self handleAddToCartRequest: request.
	].

	self addService: '/listCart' action: [ :request |
		self handleListCartRequest: request.
	].

	self addService: '/checkOutCart' action: [ :request | 
		self handleCheckOutCartRequest: request.
	].

	self addService: '/listPurchases' action: [ :request | 
		self handleListPurchasesRequest: request.
	].


! !

!methodRemoval: TusLibrosRestInterface #handleCheckOutCart: stamp: 'AW 6/29/2021 00:16:22'!
handleCheckOutCart: aRequest
	| cartId cced ccedSplitted ccn cco creditCard response |
	
	cartId _ (aRequest fields at: 'cartId') asNumber .
	ccn _ aRequest fields at: 'ccn' .
	ccedSplitted _ (aRequest fields at: 'cced') findTokens: '/'.
	cco _ aRequest fields at: 'cco'.
	cced _ GregorianMonthOfYear 
		yearNumber: (ccedSplitted at: 2) asNumber
		monthNumber: (ccedSplitted at: 1) asNumber. 
	creditCard _ CreditCard number: ccn owner: cco expiration: cced.

	shop checkOut: cartId payingWith: creditCard.

	response _ Dictionary new.
	response at: 'response' put: 'OK'.
	aRequest send200Response: (WebUtils jsonEncode: response).


!

TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!
!TusLibrosRestInterface methodsFor: 'as yet unclassified' stamp: 'AW 6/29/2021 00:17:58' prior: 50338987!
                   handleListPurchasesRequest: aRequest
	| clientId password purchases response |
	
	self halt.
	clientId _ (aRequest fields at: 'clientId') asNumber.
	password _ aRequest fields at: 'password'.
	
	purchases _ shop listPurchasesOf: clientId with: password.
	
	response _ Dictionary new.
	response at: 'purchases' put: (self serializePurchases: purchases).
	aRequest send200Response: (WebUtils jsonEncode: response).


! !

TusLibrosRestInterface allInstances do: [ :x | x destroy ].!

----QUIT----(29 June 2021 00:20:52) CuisUniversity-4532.image priorSource: 124493!

----STARTUP---- (1 July 2021 17:16:08) as /home/awolfsdorf/Dropbox/CSCOM/IngeSoft1/Inge1-ejercicios/20-TusLibros-Iteracion-4/CuisUniversity-4532.image!


Panel subclass: #WordsClientWindow
	instanceVariableNames: 'sentenceTextBoxMorph wordsListMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!

!classDefinition: #WordsClientWindow category: 'WordsClientDemo' stamp: 'AW 7/1/2021 17:51:33'!
ProtoObject subclass: #WordsClientWindow
	instanceVariableNames: 'sentenceTextBoxMorph wordsListMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!
!WordsClientWindow methodsFor: 'initialization' stamp: 'NR 6/22/2021 08:25:04'!
                               defaultExtent

	^ 1035@485
	! !
!WordsClientWindow methodsFor: 'initialization' stamp: 'NR 6/23/2021 06:54:42'!
                initializeWith: aTitle

	self titleMorph showButtonsNamed: #( close collapse ).
	self setLabel: aTitle.
	self model: (WordsClientWindowModel new).
	self morphExtent: (self defaultExtent).
	self buildMorphicWindow.
	self openInWorld.
	self yourself.
			
	self model when: #newWordsArrived send: #refreshListOfWords to: self.! !
!WordsClientWindow methodsFor: 'access' stamp: 'NR 6/23/2021 06:58:02'!
                 refreshListOfWords
	
	wordsListMorph updateList.
	wordsListMorph setSelectionIndex: 0.
	! !
!WordsClientWindow methodsFor: 'GUI building' stamp: 'NR 6/28/2021 19:01:09'!
                      build1stColumn2ndRow
	| firstColumnLayoutMorphOfSecondRow |
	
	wordsListMorph := PluggableListMorph model: self model listGetter: #words indexGetter: #wordsListIndex indexSetter: #wordsListIndex:.
	wordsListMorph  borderColor: Color skyBlue; borderWidth: 1; morphWidth:300.
		
	firstColumnLayoutMorphOfSecondRow := LayoutMorph newColumn.
	firstColumnLayoutMorphOfSecondRow separation: 5; 
	axisEdgeWeight: 0.5;
	addMorph: (LabelMorph contents:'Results');
	addMorph: wordsListMorph.
	
	"Dos opciones para jugar con los layouts... ¿Qué diferencia hay?"
	firstColumnLayoutMorphOfSecondRow layoutSpec fixedWidth: 390.
	"wordsListMorph layoutSpec proportionalWidth: 100.
	wordsListMorph layoutSpec proportionalHeight: 100."
		
	^firstColumnLayoutMorphOfSecondRow.
	! !
!WordsClientWindow methodsFor: 'GUI building' stamp: 'NR 6/28/2021 18:34:12'!
                      build1stRow
	| sendRequestButtonMorph firstRowLayoutMorph |
	
	sendRequestButtonMorph := PluggableButtonMorph model: self model stateGetter: nil action: #sendWordsFromSentenceRequest  label: 'Send Request To Server'.
	
	sentenceTextBoxMorph := TextModelMorph textProvider: self model textGetter: #sentenceText textSetter: #sentenceText:. 
	sentenceTextBoxMorph textMorph setProperty: #keyStroke: toValue: [ :key | sentenceTextBoxMorph textMorph acceptContents ] .
	sentenceTextBoxMorph  borderWidth: 1; borderColor: Color skyBlue; morphWidth: 300. 
		
	firstRowLayoutMorph := LayoutMorph newRow.
	firstRowLayoutMorph separation: 25;
	axisEdgeWeight: 0.5;
	addMorph: (LabelMorph contents:'Enter sentence:');
	addMorph: sentenceTextBoxMorph;
 	addMorph: sendRequestButtonMorph.
	
	^firstRowLayoutMorph.! !
!WordsClientWindow methodsFor: 'GUI building' stamp: 'NR 6/23/2021 06:37:31'!
              build2ndRow
	| showInTranscriptButtonMorph secondRowLayoutMorph |
	
	showInTranscriptButtonMorph := PluggableButtonMorph model: self model stateGetter: nil  action: #showWordInTranscript label: 'Show Selected Word In Transcript'.	
	
	secondRowLayoutMorph := LayoutMorph newRow.
	secondRowLayoutMorph separation: 25;
	axisEdgeWeight: 0.5;
	addMorph: self build1stColumn2ndRow;
	addMorph: showInTranscriptButtonMorph.
	
	^secondRowLayoutMorph.
	! !
!WordsClientWindow methodsFor: 'GUI building' stamp: 'NR 6/22/2021 05:23:32'!
                   buildMorphicWindow
		
	self layoutMorph beColumn;
	separation: 15;
	axisEdgeWeight: 0;
	addMorph: self build1stRow;
	addMorph: self build2ndRow.
	! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

WordsClientWindow class
	instanceVariableNames: ''!

!classDefinition: 'WordsClientWindow class' category: 'WordsClientDemo' stamp: 'AW 7/1/2021 17:51:33'!
WordsClientWindow class
	instanceVariableNames: ''!
!WordsClientWindow class methodsFor: 'instance creation' stamp: 'NR 6/23/2021 06:32:18'!
     open
	
	^self new initializeWith: 'Words-Service Client Window'.! !

Object subclass: #WordsClientWindowModel
	instanceVariableNames: 'sentence words selectedIndex restInterface'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!

!classDefinition: #WordsClientWindowModel category: 'WordsClientDemo' stamp: 'AW 7/1/2021 17:51:33'!
Object subclass: #WordsClientWindowModel
	instanceVariableNames: 'sentence words selectedIndex restInterface'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!
!WordsClientWindowModel methodsFor: 'PluggableListSelectors' stamp: 'NR 6/23/2021 06:56:13'!
    words
	
	^words.
! !
!WordsClientWindowModel methodsFor: 'PluggableListSelectors' stamp: 'NR 6/23/2021 06:56:37'!
              wordsListIndex
	
	^selectedIndex.! !
!WordsClientWindowModel methodsFor: 'PluggableListSelectors' stamp: 'NR 6/23/2021 06:56:49'!
                              wordsListIndex: anIndex
	
	selectedIndex := anIndex.! !
!WordsClientWindowModel methodsFor: 'initialization' stamp: 'NR 6/23/2021 07:56:07' overrides: 16896425!
                               initialize

	words := OrderedCollection new.
	sentence := ''.
	selectedIndex := 0.
	restInterface := WordsRestInterface new.! !
!WordsClientWindowModel methodsFor: 'TextModelMorphSelectors' stamp: 'NR 6/25/2019 21:43:32'!
  sentenceText
	
	^sentence.! !
!WordsClientWindowModel methodsFor: 'TextModelMorphSelectors' stamp: 'NR 6/23/2021 07:08:56'!
    sentenceText: aSentence

	sentence := aSentence.
	^true.! !
!WordsClientWindowModel methodsFor: 'PluggableButtonSelectors' stamp: 'NR 6/23/2021 07:56:07'!
     sendWordsFromSentenceRequest
		
	words := restInterface sendRequest: sentence.
	
	self triggerEvent: #newWordsArrived with: self.
	! !
!WordsClientWindowModel methodsFor: 'PluggableButtonSelectors' stamp: 'NR 6/23/2021 06:51:02'!
                          showWordInTranscript
	
	(selectedIndex = 0) ifFalse: 
		[TranscriptWindow openTranscript.
		Transcript clear.
		Transcript show: 'The word selected is: '.
		Transcript show: (words at: selectedIndex).
		Transcript show: ' '.].
! !

Object subclass: #WordsRestInterface
	instanceVariableNames: 'port'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!

!classDefinition: #WordsRestInterface category: 'WordsClientDemo' stamp: 'AW 7/1/2021 17:51:34'!
Object subclass: #WordsRestInterface
	instanceVariableNames: 'port'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!
!WordsRestInterface methodsFor: 'sending requests' stamp: 'NR 6/25/2019 22:25:36'!
   correctlyEncodeSpacesForUrlRequestParameter: aParameter
	
	^ aParameter copyReplaceAll: ' ' with: '%20'. ! !
!WordsRestInterface methodsFor: 'sending requests' stamp: 'NR 6/23/2021 07:54:44'!
sendRequest: sentence

	| fieldDict resp urlEncodedSentence |

	urlEncodedSentence := self correctlyEncodeSpacesForUrlRequestParameter: sentence.	
	fieldDict := Dictionary newFromPairs: {'sentence'. urlEncodedSentence.}.		
	
	resp:= WebClient htmlSubmit: (self url,'/words') fields: fieldDict.
	
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection .] 
		ifFalse:[^self error: resp content].! !
!WordsRestInterface methodsFor: 'initialization' stamp: 'NR 6/25/2019 22:15:16'!
                      port
	
	^port ifNil: [port:=8080].! !
!WordsRestInterface methodsFor: 'initialization' stamp: 'NR 6/24/2019 06:52:37'!
         url
	
	^'http://localhost:', self port asString! !

----End fileIn of /home/awolfsdorf/Dropbox/CSCOM/IngeSoft1/2021-1c/20-TusLibros/Iteracion 4/WordsClientDemo.st----!

CodePackage subclass: #ColorExtrasPackage
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Color-Extras'!

!classDefinition: #ColorExtrasPackage category: 'Color-Extras' stamp: 'Install-Color-Extras 7/1/2021 17:56:58'!
CodePackage subclass: #ColorExtrasPackage
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Color-Extras'!

ColorExtrasPackage class
	instanceVariableNames: ''!

!classDefinition: 'ColorExtrasPackage class' category: 'Color-Extras' stamp: 'Install-Color-Extras 7/1/2021 17:56:58'!
ColorExtrasPackage class
	instanceVariableNames: ''!

'From Cuis 5.0 [latest update: #4520] on 8 January 2021 at 3:11:05 pm'!

'Description '!

SystemOrganization addCategory: 'Color-Extras'!

CodePackage subclass: #ColorExtrasPackage
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Color-Extras'!

!classDefinition: #ColorExtrasPackage category: 'Color-Extras' stamp: 'Install-Color-Extras 7/1/2021 17:56:59'!
CodePackage subclass: #ColorExtrasPackage
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Color-Extras'!

ColorExtrasPackage class
	instanceVariableNames: ''!

!classDefinition: 'ColorExtrasPackage class' category: 'Color-Extras' stamp: 'Install-Color-Extras 7/1/2021 17:56:59'!
ColorExtrasPackage class
	instanceVariableNames: ''!
!ColorExtrasPackage class methodsFor: 'installing' stamp: 'jmv 6/1/2018 20:58:19' overrides: 50576174!
    postPackageInstall
	"This gets called after installing all the package code"

	Color initializeColorExtras! !
!ColorExtrasPackage class methodsFor: 'installing' stamp: 'jmv 6/1/2018 20:57:48' overrides: 50576180!
           prePackageInstall
	"This gets called after creating the package class and installing its code, but before installing the rest of the package code"

	Color classPool declare: #ColorNamesDict from: Undeclared! !

ColorExtrasPackage prePackageInstall!
!Color methodsFor: '*color-extras-named colors' stamp: 'KenD 12/8/2013 14:59'!
                        closestAssocFrom: aColorDict
	"Answer closest associated color in aColorDict"
"
	((Color r: 0.3 g: 0.2 b: 0.8) closestAssocFrom: (Color colorNamesDict)) explore.
"
	"Filter values for those close in hue (cheap test) then use rgbDistance"
	| closeInHue isClose close distance myHue |
	closeInHue := OrderedCollection new.
	myHue := self hue.
	isClose := [ :assoc | | delta |
		delta := ((assoc value hue) - myHue) abs.
		(delta < 20) or: [ delta > 340 ] "hues within 20 degrees"
	].
	aColorDict  associationsDo:  [ :assoc |
		(isClose value: assoc) ifTrue: [ closeInHue add: assoc ]
	].

	close := nil.
	distance := 1000. "big"
	(closeInHue size > 0)
		ifFalse: [ "fallback -- no color really close"
			aColorDict  associationsDo:  [ :assoc | | dist |
				dist := self rgbDistance: (assoc value). 
				(dist < distance)  ifTrue: [distance := dist. close := assoc]
				]
		]
		ifTrue: [ closeInHue do: [ :assoc | | dist |
				dist := self rgbDistance: (assoc value). 
				(dist < distance)  ifTrue: [distance := dist. close := assoc]
				]
		].
	
	^ close! !
!Color methodsFor: '*color-extras-named colors' stamp: 'KenD 1/26/2013 16:33'!
                closestColor
	"Answer the closest matching color in the colorNames dictionary"

"
	(Color red lighter lighter) closestColor explore.
"
	^ self closestColorFrom: (Color colorNamesDict)! !
!Color methodsFor: '*color-extras-named colors' stamp: 'KenD 1/26/2013 16:36'!
                      closestColorAssociation
	"Answer this color's closest name->color match."

"
	(Color blue lighter lighter) closestColorAssociation explore.
"	
	^ self closestAssocFrom: (Color colorNamesDict)! !
!Color methodsFor: '*color-extras-named colors' stamp: 'KenD 1/25/2013 14:31'!
              closestColorFrom: aColorDict
	"Answer closest associated color"
"
	((Color lightBlue) closestColorFrom: (Color css2NamedColors)) explore..
"
	^(self closestAssocFrom: aColorDict) value! !
!Color methodsFor: '*color-extras-named colors' stamp: 'KenD 1/26/2013 16:36'!
                     closestColorName
	"Answer the name symbol of the closest matching color in the colorNames dictionary"
"
	(Color red lighter lighter) closestColor name.
"
	
	^ self closestNameFrom: (Color colorNamesDict)! !
!Color methodsFor: '*color-extras-named colors' stamp: 'KenD 1/26/2013 16:36'!
  closestNameFrom: aColorDict
	"Answer closest associated color name"
"
	((Color lightBlue) closestNameFrom: (Color namedColors)) print.
"
	^(self closestAssocFrom: aColorDict) key! !
!Color methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 16:37'!
                              isBlueGreen
	"Am I considered BlueGreen ?"

	^self green > self red 
		and: [self red < 0.3]
			and: [(self green - self blue) abs < 0.1]! !
!Color methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 16:50'!
       isBright
	"Am I considered a Bright color ?"

	^self brightness > 0.6! !
!Color methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 16:40'!
           isBrown
	"Am I considered Brown ?"

	^self red >= self green  
		and: [self green > self blue]					
			and: [(self red - self green) < 0.5]	
				and: [(self green - self blue) < 0.3]! !
!Color methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 16:50'!
                          isDark
	"Am I considered a Dark color ?"

	^self brightness < 0.5! !
!Color methodsFor: '*color-extras-selection' stamp: 'jmv 12/17/2018 10:45:56'!
            isGray
	"Am I considered Gray  ?"

	^ self saturation < 0.03! !
!Color methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:40'!
                    isGrey
	"Am I considered Grey  ?"

	^self isGray! !
!Color methodsFor: '*color-extras-selection' stamp: 'jmv 4/19/2013 17:06'!
 isLight
	"Am I considered a Light color ?"

	^self brightness > 0.6! !
!Color methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 16:44'!
             isOrange
	"Am I considered Orange ?"

	^self red > ((self green max: self blue) + 0.2)  
		and: [self green > (self blue + 0.2)]! !
!Color methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 16:45'!
                isPastel
	"Am I considered Pastel ?"

	^self saturation < 0.4! !
!Color methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 16:46'!
                   isPink
	"Am I considered Pink ?"

	^self red > ((self green max: self blue) + 0.3)  
		and: [self blue > (self green + 0.2)]! !
!Color methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 16:55'!
                    isSaturated
	"Am I considered to be a Saturated color ?"

	^self saturation > 0.6! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 14:58'!
                       aqua

	^ ColorNamesDict at: #aqua! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 14:58'!
       beige

	^ ColorNamesDict at: #beige! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:26'!
       blueColorDict
	"Answer a dictionary of named colors considered Blue"
"
	Color blueColorDict explore.
"
	^self blueColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:24'!
                               blueColorDict: aColorDict
	"Answer a dictionary of named colors considered Blue"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBlue)
				or: [assoc key asString asLowercase includesSubString: 'blue'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:28'!
     blueGreenColorDict
	"Answer a dictionary of named colors considered Blue"
"
	Color blueGreenColorDict explore.
"
	^self blueGreenColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:29'!
                blueGreenColorDict: aColorDict
	"Answer a dictionary of named colors considered Blue"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBlueGreen)
				or: [assoc key asString asLowercase includesSubString: 'bluegreen'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:31'!
                      brightColorDict
	"Answer a dictionary of named colors considered Bright"
"
	Color brightColorDict explore.
"
	^self brightColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:31'!
                       brightColorDict: aColorDict
	"Answer a dictionary of named colors considered Bright"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isBright) ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 14:58'!
     brightGreen

	^ ColorNamesDict at: #brightGreen! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:34'!
                           brownColorDict
	"Answer a dictionary of named colors considered Brown"
"
	Color brownColorDict explore.
"
	^self brownColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:33'!
                           brownColorDict: aColorDict
	"Answer a dictionary of named colors considered Brown"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isBrown)
				or: [assoc key asString asLowercase includesSubString: 'brown'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: '*color-extras-color name lookup' stamp: 'KenD 1/26/2013 20:13'!
                         colorNames
	"Answer the current dictionary of  name->color associations."

	^ColorNamesDict keys! !
!Color class methodsFor: '*color-extras-cached state access' stamp: 'jmv 3/27/2018 10:51:21'!
                              colorNamesDict
	"Answer the current dictionary of  name->color associations."
"
	Color colorNamesDict explore.
"
	^ColorNamesDict! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 14:59'!
       darkBlue

	^ ColorNamesDict at: #darkBlue! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:36'!
 darkColorDict
	"Answer a dictionary of named colors considered Dark"
"
	Color darkColorDict explore.
"
	^self darkColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:37'!
                               darkColorDict: aColorDict
	"Answer a dictionary of named colors considered Dark"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isDark) ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 14:59'!
           darkGreen

	^ ColorNamesDict at: #darkGreen! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 14:59'!
                             darkPink

	^ ColorNamesDict at: #darkPink! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 14:59'!
                               darkPurple

	^ ColorNamesDict at: #darkPurple! !
!Color class methodsFor: '*color-extras-color name lookup' stamp: 'KenD 1/28/2013 20:34'!
                     defaultColorNamesDictionary
	"Answer a amall but  useful name->color dictionary"
	
	| defaultDict |
	"Meld most used xkcd colors into traditional colors."
	defaultDict := (self traditionalColorNamesDictionary addAll: 
					self xkcdFirst48ColorNamesDictionary; 
					yourself).
		
	"Override traditional names existing in extended XKCD naming"
	defaultDict at: #lightYellow    put: (Color r: 1.0 g: 0.996 b: 0.478).
	defaultDict at: #lightOrange   put: (Color r: 0.992 g: 0.667 b: 0.283).
	defaultDict at: #lightCyan        put: (Color r: 0.674 g: 1.0 b: 0.988).
	defaultDict at: #lightRed          put: (Color r: 1.0 g: 0.279 b: 0.298).
	defaultDict at: #lightMagenta put: (Color r: 0.98 g: 0.372 b: 0.969).
	
	^defaultDict! !
!Color class methodsFor: '*color-extras-color name lookup' stamp: 'KenD 2/1/2013 14:39' overrides: 16881366!
                           doesNotUnderstand: aMessage
	"Some code takes
		 Color colorNames 
	and does
		Color perform: aColorname.
		
	Make this work."

	^(Color colorNamesDict) 
		at: (aMessage selector)
		ifAbsent: [super doesNotUnderstand: aMessage]! !
!Color class methodsFor: '*color-extras-color name lookup' stamp: 'KenD 1/26/2013 20:51'!
                               exactColorNamed: aColorName

	"Answer color matching name or nil 
	from my ColorName->Color Dictionary"
	
	^ ColorNamesDict at: (aColorName asSymbol) ifAbsent: [nil]! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 14:59'!
   forestGreen

	^ ColorNamesDict at: #forestGreen! !
!Color class methodsFor: '*color-extras-instance creation' stamp: 'jmv 1/8/2021 13:07:21'!
                  fromString: aString
	"For HTML color spec: #FFCCAA. Also support named colors.
	See http://www.w3schools.com/cssref/css_colors_legal.asp"
	"
	Color fromString: '#FFCCAA'.
	Color fromString: 'white'.
	Color fromString: 'orange'
	Color fromString: 'rgb(255,0,98)'
	"
	(self fromHexString: aString) ifNotNil: [ :color |
		^ color ].

	(aString beginsWith: 'rgb')
		ifTrue: [|values r g b|
				values := (aString allButFirst: 4) allButLast findTokens: ','.
				r  := (values first includes: $%)
						ifTrue: [(values first asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values first asNumber min: 255 max: 0) / 255.0].
				g := (values second includes: $%)
						ifTrue: [(values second asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values second asNumber min: 255 max: 0) / 255.0].
				b := (values third includes: $%)
						ifTrue: [(values third asNumber min: 100 max: 0) / 100.0]
						ifFalse: [(values third asNumber min: 255 max: 0) / 255.0].
				^self r: r g: g b: b].

	^self exactColorNamed: aString! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:41'!
                 grayColorDict: aColorDict
	"Answer a dictionary of named colors considered Grey"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGrey)
				or: [assoc key asString asLowercase includesSubString: 'grey'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:38'!
     greenColorDict
	"Answer a dictionary of named colors considered Green"
"
	Color greenColorDict explore.
"
	^self greenColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:38'!
                           greenColorDict: aColorDict
	"Answer a dictionary of named colors considered Green"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGreen)
				or: [assoc key asString asLowercase includesSubString: 'green'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 14:59'!
                               grey

	^ ColorNamesDict at: #grey! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:41'!
         greyColorDict
	"Answer a dictionary of named colors considered Grey"
"
	Color greyColorDict explore.
"
	^self greyColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:40'!
                               greyColorDict: aColorDict
	"Answer a dictionary of named colors considered Grey"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isGrey)
				or: [assoc key asString asLowercase includesSubString: 'grey'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 14:59'!
   hotPink

	^ ColorNamesDict at: #hotPink! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 14:59'!
 indigo

	^ ColorNamesDict at: #indigo! !
!Color class methodsFor: '*color-extras-initialization' stamp: 'jmv 3/27/2018 10:52:59'!
                              initializeColorExtras

	ColorNamesDict ifNil: [
		self setColorNamesDict: self defaultColorNamesDictionary ]! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 14:59'!
                            lavender

	^ ColorNamesDict at: #lavender! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:44'!
 lightColorDict
	"Answer a dictionary of named colors considered light"
"
	Color lightColorDict explore.
"
	^self lightColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:43'!
                           lightColorDict: aColorDict
	"Answer a dictionary of named colors considered Liight"

	^self brightColorDict: aColorDict! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:00'!
                 lightPink

	^ ColorNamesDict at: #lightPink! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:00'!
                             lightPurple

	^ ColorNamesDict at: #lightPurple! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:00'!
                         lilac

	^ ColorNamesDict at: #lilac! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:00'!
     lime

	^ ColorNamesDict at: #lime! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:00'!
       limeGreen

	^ ColorNamesDict at: #limeGreen! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:00'!
                             maroon

	^ ColorNamesDict at: #maroon! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:00'!
   mauve

	^ ColorNamesDict at: #mauve! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:00'!
     mustard

	^ ColorNamesDict at: #mustard! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:00'!
 navyBlue

	^ ColorNamesDict at: #navyBlue! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:00'!
                               olive

	^ ColorNamesDict at: #olive! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:00'!
     oliveGreen

	^ ColorNamesDict at: #oliveGreen! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:46'!
                             orangeColorDict
	"Answer a dictionary of named colors considered Orange"
"
	Color orangeColorDict explore.
"
	^self orangeColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:46'!
                       orangeColorDict: aColorDict
	"Answer a dictionary of named colors considered Orange"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isOrange)
				or: [assoc key asString asLowercase includesSubString: 'orange'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:00'!
                           paleGreen

	^ ColorNamesDict at: #paleGreen! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:48'!
                               pastelColorDict
	"Answer a dictionary of named colors considered Pastel"
"
	Color pastelColorDict explore.
"
	^self pastelColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:48'!
                       pastelColorDict: aColorDict
	"Answer a dictionary of named colors considered Bright"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isPastel) ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:00'!
     peach

	^ ColorNamesDict at: #peach! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:00'!
     periwinkle

	^ ColorNamesDict at: #periwinkle! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:50'!
                             pinkColorDict
	"Answer a dictionary of named colors considered Pink"
"
	Color pinkColorDict explore.
"
	^self pinkColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:50'!
                               pinkColorDict: aColorDict
	"Answer a dictionary of named colors considered Pink"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isPink)
				or: [assoc key asString asLowercase includesSubString: 'pink'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:52'!
     purpleColorDict
	"Answer a dictionary of named colors considered Purple"
"
	Color purpleColorDict explore.
"
	^self purpleColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:52'!
                       purpleColorDict: aColorDict
	"Answer a dictionary of named colors considered Pink"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc key asString asLowercase includesSubString: 'purple')
				or: [assoc key asString asLowercase includesSubString: 'violet'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:54'!
                         redColorDict
	"Answer a dictionary of named colors considered Red"
"
	Color redColorDict explore.
"
	^self redColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:53'!
   redColorDict: aColorDict
	"Answer a dictionary of named colors considered Red"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isRed)
				or: [assoc key asString asLowercase includesSubString: 'red'])
			ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:01'!
       royalBlue

	^ ColorNamesDict at: #royalBlue! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:01'!
                             salmon

	^ ColorNamesDict at: #salmon! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:56'!
     saturatedColorDict
	"Answer a dictionary of named colors considered Saturated"
"
	Color saturatedColorDict explore.
"
	^self saturatedColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:55'!
           saturatedColorDict: aColorDict
	"Answer a dictionary of named colors considered Saturated"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			(assoc value isSaturated) ifTrue: [dict add: assoc]
		].
	^dict! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:01'!
                            seaGreen

	^ ColorNamesDict at: #seaGreen! !
!Color class methodsFor: '*color-extras-color name lookup' stamp: 'KenD 7/25/2014 21:22'!
                         setColorNamesDict: aNameColorDictionary
	"Answer the current dictionary of  name->color associations."
	
	"Note: This is a non-standard name because this is a non-standard action!!
	Do this if you really, really know what you are doing."
	
	"Some Colors are required for proper system operation"
	Color defaultColorNamesDictionary keysAndValuesDo: [ :colorName :colorValue |
		aNameColorDictionary at: colorName ifAbsentPut: colorValue
	].

	ColorNamesDict := aNameColorDictionary! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:01'!
        skyBlue

	^ ColorNamesDict at: #skyBlue! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:01'!
 teal

	^ ColorNamesDict at: #teal! !
!Color class methodsFor: '*color-extras-color name lookup' stamp: 'jmv 3/10/2018 20:42:11'!
                               traditionalColorNamesDictionary
	"Answer a dictionary of Squeak traditional name->color associations.."

	| nameDict |
	nameDict _ Dictionary new.
	nameDict at: #black put: `Color r: 0 g: 0 b: 0`.
	nameDict at: #veryVeryDarkGray put: `Color r: 0.125 g: 0.125 b: 0.125`.
	nameDict at: #veryDarkGray put: `Color r: 0.25 g: 0.25 b: 0.25`.
	nameDict at: #darkGray put: `Color r: 0.375 g: 0.375 b: 0.375`.
	nameDict at: #gray put: `Color r: 0.5 g: 0.5 b: 0.5`.
	nameDict at: #lightGray put: `Color r: 0.625 g: 0.625 b: 0.625`.
	nameDict at: #veryLightGray put: `Color r: 0.75 g: 0.75 b: 0.75`.
	nameDict at: #veryVeryLightGray put: `Color r: 0.875 g: 0.875 b: 0.875`.
	nameDict at: #white put: `Color r: 1.0 g: 1.0 b: 1.0`.
	nameDict at: #red put: `Color r: 1.0 g: 0 b: 0`.
	nameDict at: #yellow put: `Color r: 1.0 g: 1.0 b: 0`.
	nameDict at: #green put: `Color r: 0 g: 1.0 b: 0`.
	nameDict at: #cyan put: `Color r: 0 g: 1.0 b: 1.0`.
	nameDict at: #blue put: `Color r: 0 g: 0 b: 1.0`.
	nameDict at: #magenta put: `Color r: 1.0 g: 0 b: 1.0`.
	nameDict at: #brown put: `Color r: 0.6 g: 0.2 b: 0`.
	nameDict at: #orange put: `Color r: 1.0 g: 0.6 b: 0`.
	nameDict at: #lightRed put: `Color r: 1.0 g: 0.8 b: 0.8`.
	nameDict at: #lightYellow put: `Color r: 1.0 g: 1.0 b: 0.8`.
	nameDict at: #lightGreen put: `Color r: 0.8 g: 1.0 b: 0.6`.
	nameDict at: #lightCyan put: `Color r: 0.4 g: 1.0 b: 1.0`.
	nameDict at: #lightBlue put: `Color r: 0.8 g: 1.0 b: 1.0`.
	nameDict at: #lightMagenta put: `Color r: 1.0 g: 0.8 b: 1.0`.
	nameDict at: #lightBrown put: `Color r: 1.0 g: 0.6 b: 0.2`.
	nameDict at: #lightOrange put: `Color r: 1.0 g: 0.8 b: 0.4`.
	nameDict at: #transparent put: `TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.0`.
	
	^nameDict
! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:01'!
      turquoise

	^ ColorNamesDict at: #turquoise! !
!Color class methodsFor: '*color-extras-named colors' stamp: 'jmv 4/17/2015 15:01'!
                             violet

	^ ColorNamesDict at: #violet! !
!Color class methodsFor: '*color-extras-color name lookup' stamp: 'jmv 6/30/2014 15:22'!
                              xkcdFirst48ColorNamesDictionary
	"XKCD color names are based on a survey oc colors people call by the same name.
	 http://blog.xkcd.com/2010/05/03/color-survey-results/"

	"Answer a dictionary of the most agreed upon first 48 xkcd colors"
"
	Color xkcdFirst48ColorNamesDictionary explore.
"	
	| xkcdDict |
	xkcdDict := Dictionary new
	at: #lightPink put: (Color fromString: '#ffd1df') ;
	at: #mustard put: (Color fromString: '#ceb301') ;
	at: #indigo put: (Color fromString: '#380282') ;
	at: #lime put: (Color fromString: '#aaff32') ;
	at: #seaGreen put: (Color fromString: '#53fca1') ;
	at: #periwinkle put: (Color fromString: '#8e82fe') ;
	at: #darkPink put: (Color fromString: '#cb416b') ;
	at: #oliveGreen put: (Color fromString: '#677a04') ;
	at: #peach put: (Color fromString: '#ffb07c') ;
	at: #paleGreen put: (Color fromString: '#c7fdb5') ;
	at: #lightBrown put: (Color fromString: '#ad8150') ;
	at: #hotPink put: (Color fromString: '#ff028d') ;
	at: #black put: (Color fromString: '#000000') ;
	at: #lilac put: (Color fromString: '#cea2fd') ;
	at: #navyBlue put: (Color fromString: '#001146') ;
	at: #royalBlue put: (Color fromString: '#0504aa') ;
	at: #beige put: (Color fromString: '#e6daa6') ;
	at: #salmon put: (Color fromString: '#ff796c') ;
	at: #olive put: (Color fromString: '#6e750e') ;
	at: #maroon put: (Color fromString: '#650021') ;
	at: #brightGreen put: (Color fromString: '#01ff07') ;
	at: #darkPurple put: (Color fromString: '#35063e') ;
	at: #mauve put: (Color fromString: '#ae7181') ;
	at: #forestGreen put: (Color fromString: '#06470c') ;
	at: #aqua put: (Color fromString: '#13eac9') ;
	at: #cyan put: (Color fromString: '#00ffff') ;
	at: #tan put: (Color fromString: '#d1b26f') ;
	at: #darkBlue put: (Color fromString: '#00035b') ;
	at: #lavender put: (Color fromString: '#c79fef') ;
	at: #turquoise put: (Color fromString: '#06c2ac') ;
	at: #darkGreen put: (Color fromString: '#033500') ;
	at: #violet put: (Color fromString: '#9a0eea') ;
	at: #lightPurple put: (Color fromString: '#bf77f6') ;
	at: #limeGreen put: (Color fromString: '#89fe05') ;
	at: #grey put: (Color fromString: '#929591') ;
	at: #skyBlue put: (Color fromString: '#75bbfd') ;
	at: #yellow put: (Color fromString: '#ffff14') ;
	at: #magenta put: (Color fromString: '#c20078') ;
	at: #lightGreen put: (Color fromString: '#96f97b') ;
	at: #orange put: (Color fromString: '#f97306') ;
	at: #teal put: (Color fromString: '#029386') ;
	at: #lightBlue put: (Color fromString: '#95d0fc') ;
	at: #red put: (Color fromString: '#e50000') ;
	at: #brown put: (Color fromString: '#653700') ;
	at: #pink put: (Color fromString: '#ff81c0') ;
	at: #blue put: (Color fromString: '#0343df') ;
	at: #green put: (Color fromString: '#15b01a') ;
	at: #purple put: (Color fromString: '#7e1e9c') ;
  	yourself.

	^xkcdDict

! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:26'!
                        yellowColorDict
	"Answer a dictionary of named colors considered Yellow"
"
	Color yellowColorDict explore.
"
	^self yellowColorDict: ColorNamesDict! !
!Color class methodsFor: '*color-extras-selection' stamp: 'KenD 1/30/2013 17:19'!
                       yellowColorDict: aColorDict
	"Answer a dictionary of named colors considered Yellow"

	| dict |
	dict := Dictionary new.
	aColorDict associationsDo: 
		 [ :assoc |
			((assoc value isYellow)
				or: [assoc key asString asLowercase includesSubString: 'yellow'])
			ifTrue: [dict add: assoc]
		].
	^dict! !

ColorExtrasPackage postPackageInstall!

----End fileIn of /opt/Cuis/Packages/Features/Color-Extras.pck.st----!

'From Cuis 5.0 [latest update: #4519] on 5 January 2021 at 3:00:42 pm'!

'Description Please enter a description for this package'!

SystemOrganization addCategory: 'Morphic-Widgets-Extras'!

SystemOrganization addCategory: 'Morphic-Widgets-Extras-Tests'!

Editor subclass: #SimpleEditor
	instanceVariableNames: 'string pointIndex markIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

!classDefinition: #SimpleEditor category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
Editor subclass: #SimpleEditor
	instanceVariableNames: 'string pointIndex markIndex'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

SimpleEditor class
	instanceVariableNames: ''!

!classDefinition: 'SimpleEditor class' category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
SimpleEditor class
	instanceVariableNames: ''!

TextModelMorph subclass: #LimitedHeightTextMorph
	instanceVariableNames: 'maxHeight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

!classDefinition: #LimitedHeightTextMorph category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
TextModelMorph subclass: #LimitedHeightTextMorph
	instanceVariableNames: 'maxHeight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

LimitedHeightTextMorph class
	instanceVariableNames: ''!

!classDefinition: 'LimitedHeightTextMorph class' category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
LimitedHeightTextMorph class
	instanceVariableNames: ''!

WidgetMorph subclass: #DragAndDropAreaMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

!classDefinition: #DragAndDropAreaMorph category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
WidgetMorph subclass: #DragAndDropAreaMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

DragAndDropAreaMorph class
	instanceVariableNames: ''!

!classDefinition: 'DragAndDropAreaMorph class' category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
DragAndDropAreaMorph class
	instanceVariableNames: ''!

DragAndDropAreaMorph subclass: #PartsBinMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

!classDefinition: #PartsBinMorph category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
DragAndDropAreaMorph subclass: #PartsBinMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

PartsBinMorph class
	instanceVariableNames: ''!

!classDefinition: 'PartsBinMorph class' category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
PartsBinMorph class
	instanceVariableNames: ''!

WidgetMorph subclass: #EllipseMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

!classDefinition: #EllipseMorph category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
WidgetMorph subclass: #EllipseMorph
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

EllipseMorph class
	instanceVariableNames: ''!

!classDefinition: 'EllipseMorph class' category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
EllipseMorph class
	instanceVariableNames: ''!

EllipseMorph subclass: #HandleMorph
	instanceVariableNames: 'pointBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

!classDefinition: #HandleMorph category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
EllipseMorph subclass: #HandleMorph
	instanceVariableNames: 'pointBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

HandleMorph class
	instanceVariableNames: ''!

!classDefinition: 'HandleMorph class' category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
HandleMorph class
	instanceVariableNames: ''!

WidgetMorph subclass: #FrameRateMorph
	instanceVariableNames: 'lastStepDelta meanStepDelta'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

!classDefinition: #FrameRateMorph category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
WidgetMorph subclass: #FrameRateMorph
	instanceVariableNames: 'lastStepDelta meanStepDelta'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

FrameRateMorph class
	instanceVariableNames: ''!

!classDefinition: 'FrameRateMorph class' category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
FrameRateMorph class
	instanceVariableNames: ''!

WidgetMorph subclass: #FunctionGraphMorph
	instanceVariableNames: 'xMin xMax yMin yMax functions colors yRangeInvalid'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

!classDefinition: #FunctionGraphMorph category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
WidgetMorph subclass: #FunctionGraphMorph
	instanceVariableNames: 'xMin xMax yMin yMax functions colors yRangeInvalid'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

FunctionGraphMorph class
	instanceVariableNames: ''!

!classDefinition: 'FunctionGraphMorph class' category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
FunctionGraphMorph class
	instanceVariableNames: ''!

WidgetMorph subclass: #MagnifierMorph
	instanceVariableNames: 'magnification trackPointer lastPos srcExtent auxCanvas magnifiedForm'
	classVariableNames: 'RecursionLock'
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

!classDefinition: #MagnifierMorph category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
WidgetMorph subclass: #MagnifierMorph
	instanceVariableNames: 'magnification trackPointer lastPos srcExtent auxCanvas magnifiedForm'
	classVariableNames: 'RecursionLock'
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

MagnifierMorph class
	instanceVariableNames: ''!

!classDefinition: 'MagnifierMorph class' category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
MagnifierMorph class
	instanceVariableNames: ''!

WidgetMorph subclass: #MinimalStringMorph
	instanceVariableNames: 'font emphasis contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

!classDefinition: #MinimalStringMorph category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
WidgetMorph subclass: #MinimalStringMorph
	instanceVariableNames: 'font emphasis contents'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

MinimalStringMorph class
	instanceVariableNames: ''!

!classDefinition: 'MinimalStringMorph class' category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
MinimalStringMorph class
	instanceVariableNames: ''!

WidgetMorph subclass: #OneLineEditorMorph
	instanceVariableNames: 'font emphasis contents editor showTextCursor pauseBlinking textCursorRect keyboardFocusWatcher crAction'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

!classDefinition: #OneLineEditorMorph category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
WidgetMorph subclass: #OneLineEditorMorph
	instanceVariableNames: 'font emphasis contents editor showTextCursor pauseBlinking textCursorRect keyboardFocusWatcher crAction'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

OneLineEditorMorph class
	instanceVariableNames: ''!

!classDefinition: 'OneLineEditorMorph class' category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
OneLineEditorMorph class
	instanceVariableNames: ''!

WidgetMorph subclass: #SamplePlotterMorph
	instanceVariableNames: 'domain sampleSequences colors yMax yMin'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

!classDefinition: #SamplePlotterMorph category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
WidgetMorph subclass: #SamplePlotterMorph
	instanceVariableNames: 'domain sampleSequences colors yMax yMin'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras'!

SamplePlotterMorph class
	instanceVariableNames: ''!

!classDefinition: 'SamplePlotterMorph class' category: 'Morphic-Widgets-Extras' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
SamplePlotterMorph class
	instanceVariableNames: ''!

TestCase subclass: #TextEditorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras-Tests'!

!classDefinition: #TextEditorTest category: 'Morphic-Widgets-Extras-Tests' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
TestCase subclass: #TextEditorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Widgets-Extras-Tests'!

TextEditorTest class
	instanceVariableNames: ''!

!classDefinition: 'TextEditorTest class' category: 'Morphic-Widgets-Extras-Tests' stamp: 'Install-Morphic-Widgets-Extras 7/1/2021 17:57:38'!
TextEditorTest class
	instanceVariableNames: ''!
!SimpleEditor commentStamp: '<historical>' prior: 0!
                  See comment in Editor!
!LimitedHeightTextMorph commentStamp: '<historical>' prior: 0!
          A TextMorph that will expand and contract vertically to adjust for the contents, but limited to a specific max height. If contents are larger, a scrollbar will be used.

LimitedHeightTextMorph new
	maxHeight: 48;
	model: (TextModel new contents: 'This is some text to test the morph.');
	openInWorld!
!DragAndDropAreaMorph commentStamp: '<historical>' prior: 0!
                      A simple morph that allows dragging submorphs, and dropping other morphs on it. It is provided as an example, and also as a reference of the methods you might need to implement in your morphs to handle drag and drop.

| m |
m _ DragAndDropAreaMorph new.
m openInWorld.
m addMorph: WidgetMorph new.
m morphExtent: 320@240!
!PartsBinMorph commentStamp: '<historical>' prior: 0!
        Like DragAndDropAreaMorph, but when submorphs are dragged, get a copy and not the original one.

| m |
m _ PartsBinMorph new.
m openInWorld.
m addMorph: EllipseMorph new.
m morphExtent: 120@240!
!EllipseMorph commentStamp: '<historical>' prior: 0!
        A round bordered Morph. Supports borderWidth and borderColor. 

EllipseMorph new borderWidth:10; borderColor: Color green; openInWorld.
!
!HandleMorph commentStamp: '<historical>' prior: 0!
  A HandleMorph provides mouse-up control behavior.!
!FrameRateMorph commentStamp: 'jmv 6/11/2012 10:14' prior: 0!
               A very simple morph to demo stepping, and for knowing about stepping (and world update) frame rates.

FrameRateMorph new openInHand!
!FunctionGraphMorph commentStamp: 'jmv 4/21/2020 20:52:08' prior: 0!
                      For continuous functions on a real domain.

| g d |
d _ -1.
g _ FunctionGraphMorph new.
g domain: (-4 to: 4).
g addFunction: [ :x | x \\ d ] color: Color green.
g addFunction: [ :x | x // d ] color: Color red.
(g embeddedInMorphicWindowLabeled: 'graph') openInWorld

| g d |
d _ -1.
g _ FunctionGraphMorph new.
g domain: (-4 to: 4).
g addFunction: [ :x | x rem: d ] color: Color green.
g addFunction: [ :x | x quo: d ] color: Color red.
g openInWorld

| g d |
d _ -1.
g _ FunctionGraphMorph new.
g domain: (-4 to: 4).
g addFunction: [ :x | x mod: d ] color: Color green.
g addFunction: [ :x | x div: d ] color: Color red.
g openInWorld

| g |
g _ FunctionGraphMorph new.
g domain: (-30 to: 30 count: 2000).
g domain: (-30 to: 30).
g yRange: (-200 to: 200).
g addFunction: [ :x | ((3* x *x)) / (x+2) ] color: Color red.
g addFunction: [ :x | ((3* x *x*x) - (6*x*x)) / (x squared -4) ] color: Color green.
(g embeddedInMorphicWindowLabeled: 'graph') openInWorld.
!
!MagnifierMorph commentStamp: '<historical>' prior: 0!
      Provides a magnifying glass. Magnifies the morphs below (if grabbed) or the area around the mouse pointer.!
!MinimalStringMorph commentStamp: 'jmv 4/1/2009 21:43' prior: 0!
                   A greatly reduced StringMorph. May be of some use.!
!OneLineEditorMorph commentStamp: '<historical>' prior: 0!
                 A plain text editor for Morphic. Handles only one line. Does not handle fonts/styles, alignment, Smalltalk utilities and any other advanced stuff in TextModelMorph. Just a simple text editor.

Can optionally include a crAction: a zero argument closure, to be evaluated on Cr keystroke.!
!SamplePlotterMorph commentStamp: '<historical>' prior: 0!
      | h r p |

h _ Histogram binCount: 200 minValue: -10.0 maxValue: 10.0.
r _ NormalProbabilityDistribution new.
10000 timesRepeat: [ h addValue: r nextRandomNumber  ].
h plot.


h domain.
p _ SamplePlotterMorph new.
p domain: h domain.
p addSamples: h counts color: Color green.
(p embeddedInMorphicWindowLabeled: 'graph') openInWorld.

Would be cool to add other interpolators. So far, we only have Nearest Neighbor.

Check SignalProcessing.pck.st for other 1D interpolators: Linear, Cubic, Splines, Beziers, Lanczos...
!
!LimitedHeightTextMorph class methodsFor: 'instance creation' stamp: 'jmv 11/14/2011 16:32' overrides: 16877229!
      initializedInstance
	^self new
		maxHeight: 48;
		model: (TextModel new contents: 'This is some text to test the morph.')! !
!FunctionGraphMorph class methodsFor: 'instance creation' stamp: 'jmv 7/20/2016 10:00:31' overrides: 16877229!
                    initializedInstance
	"
	self  initializedInstance openInWorld
	"
	| g |
	g _ FunctionGraphMorph new.
	g domain: (-4 to: 4).
	g addFunction: [ :x | x cos ] color: Color green.
	g addFunction: [ :x | (x + 1) squared - 3 ] color: Color red. "parabola with vertex at (-1,-3)"
	^ g! !
!SimpleEditor methodsFor: 'typing support' stamp: 'jmv 12/19/2011 12:24'!
                              addString: aString
	"Think of a better name"

	self replaceSelectionWith: aString! !
!SimpleEditor methodsFor: 'typing support' stamp: 'jmv 12/19/2011 12:24'!
 backTo: startIndex
	"During typing, backspace to startIndex."

	self markIndex: startIndex.
	self replaceSelectionWith: ''.
	self markIndex: self pointIndex! !
!SimpleEditor methodsFor: 'typing support' stamp: 'jmv 6/10/2012 11:14'!
                       dispatchOn: aKeyboardEvent
	"Carry out the action associated with this character, if any."
	| asciiValue |
	asciiValue _ aKeyboardEvent keyValue.
	"Control keys are handled by #shortcuts even if they have any modifiers"
	(asciiValue >= 32 and: [
		aKeyboardEvent commandAltKeyPressed ]) ifTrue: [
		^self perform: (self cmdShortcuts at: asciiValue + 1) with: aKeyboardEvent ].

	"We don't support multiple lines. Therefore, we don't process return as a #normalCharacter:"
	aKeyboardEvent isReturnKey ifTrue: [
		^ true].

	^ self perform: (self shortcuts at: asciiValue + 1) with: aKeyboardEvent! !
!SimpleEditor methodsFor: 'typing support' stamp: 'jmv 1/5/2021 14:34:14'!
                              processKeystrokeEvent: aKeyboardEvent

	"Key struck on the keyboard. Find out which one and, if special, carry 
	out the associated special action. Otherwise, add the character to the 
	stream of characters."

	(self dispatchOn: aKeyboardEvent) ifTrue: [
		^self].
	self markIndex: self pointIndex! !
!SimpleEditor methodsFor: 'initialization' stamp: 'jmv 11/4/2008 13:08'!
          changeString: aString
	"Install aString as the one to be edited by the receiver."

	string _ aString.
	self resetState! !
!SimpleEditor methodsFor: 'initialization' stamp: 'jmv 11/4/2008 13:42' overrides: 16896425!
         initialize
	"Initialize the state of the receiver. Subclasses should include 'super 
	initialize' when redefining this message to insure proper initialization."

	super initialize.
	self changeString: ''! !
!SimpleEditor methodsFor: 'initialization' stamp: 'jmv 10/16/2013 22:37'!
       resetState 
	"Establish the initial conditions for editing the paragraph: place text cursor 
	before first character, set the emphasis to that of the first character,
	and save the paragraph for purposes of canceling."

	pointIndex _ 1.	"Like pointBlock in TextEditor"
	markIndex _ 1.	"Like markBlock in TextEditor"! !
!SimpleEditor methodsFor: 'events' stamp: 'jmv 8/21/2012 08:42'!
clickAndHalf

	| here |
	here _ self pointIndex.
	(here between: 2 and: string size)
		ifTrue: [ self selectWord ]
		ifFalse: [
			"if at beginning or end, select entire string"
			self selectAll ].! !
!SimpleEditor methodsFor: 'events' stamp: 'jmv 12/29/2011 14:51'!
                    mouseDown: evt index: index

	evt shiftPressed
		ifFalse: [
			self markIndex: index pointIndex: index ]
		ifTrue: [
			self mouseMove: evt index: index ]! !
!SimpleEditor methodsFor: 'events' stamp: 'jmv 5/27/2011 15:23'!
 mouseMove: evt index: index
	"Change the selection in response to mouse-down drag"

	self pointIndex: index! !
!SimpleEditor methodsFor: 'menu messages' stamp: 'jmv 10/16/2013 22:37'!
        copySelection
	"Copy the current selection and store it in the Clipboard, unless empty."

	self lineSelectAndEmptyCheck: [^ self].
	self clipboardTextPut: self selection! !
!SimpleEditor methodsFor: 'menu messages' stamp: 'jmv 9/22/2011 17:09'!
           cut
	"Cut out the current selection and redisplay the paragraph if necessary."

	| selection |
	self lineSelectAndEmptyCheck: [^ self].
	selection _ self selection.
	self replaceSelectionWith: ''. 
	self clipboardTextPut: selection! !
!SimpleEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 9/19/2011 09:12'!
 cursorEnd: aKeyboardEvent
	"Private - Move cursor end of current line."

	self
		moveCursor: [ :dummy | self endOfText ]
		forward: true
		event: aKeyboardEvent.
	^ true.! !
!SimpleEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 9/17/2010 13:42'!
                              cursorHome: aKeyboardEvent 

	"Private - Move cursor from position in current line to beginning of
	current line. If control key is pressed put cursor at beginning of text"

	self
		moveCursor:  [ :dummy | self beginningOfText ]
		forward: false
		event: aKeyboardEvent.
	^true! !
!SimpleEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 12/19/2011 12:24'!
                      forwardDelete: aKeyboardEvent
	"Delete forward over the next character."

	| startIndex stopIndex |
	startIndex _ self markIndex.
	startIndex > string size ifTrue: [
		^ false].
	self hasSelection ifTrue: [
		"there was a selection"
		self replaceSelectionWith: ''.
		^ false].
	"Null selection - do the delete forward"
	stopIndex := startIndex.
	(aKeyboardEvent keyValue = 127 and: [ aKeyboardEvent shiftPressed ])
		ifTrue: [ stopIndex := (self nextWordStart: stopIndex) - 1 ].
	self selectFrom: startIndex to: stopIndex.
	self replaceSelectionWith: ''.
	self deselectAndPlaceCursorAt: startIndex.
	^false! !
!SimpleEditor methodsFor: 'accessing-selection' stamp: 'jmv 10/16/2013 22:17'!
              hasSelection
	^markIndex ~= pointIndex! !
!SimpleEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 13:57'!
        markIndex
	^markIndex! !
!SimpleEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/5/2008 11:41'!
                         markIndex: anIndex
	markIndex _ anIndex min: string size + 1 max: 1! !
!SimpleEditor methodsFor: 'accessing-selection' stamp: 'jmv 5/27/2011 15:25'!
           markIndex: anIndex pointIndex: anotherIndex
	markIndex _ anIndex min: string size + 1 max: 1.
	pointIndex _ anotherIndex min: string size + 1 max: 1! !
!SimpleEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 13:57'!
                          pointIndex
	^ pointIndex! !
!SimpleEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/5/2008 11:41'!
                      pointIndex: anIndex
	pointIndex _ anIndex min: string size + 1 max: 1! !
!SimpleEditor methodsFor: 'accessing-selection' stamp: 'jmv 1/31/2013 21:09'!
         selection

	| firstIndex lastIndex |
	firstIndex _ self startIndex.
	lastIndex _ self stopIndex - 1.

	(firstIndex = 1 and: [ lastIndex = string size ])
		ifTrue: [ ^string ].

	^string copyFrom: firstIndex to: lastIndex! !
!SimpleEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 13:55'!
                  startIndex
	^ pointIndex min: markIndex! !
!SimpleEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 13:55'!
       stopIndex
	^ pointIndex max: markIndex! !
!SimpleEditor methodsFor: 'testing' stamp: 'jmv 11/17/2008 17:01'!
                   isAtEnd
	^pointIndex = (string size + 1)! !
!SimpleEditor methodsFor: 'testing' stamp: 'jmv 11/17/2008 17:01'!
                 isAtStart
	^pointIndex = 1! !
!SimpleEditor methodsFor: 'editing keys' stamp: 'jmv 9/2/2009 12:40'!
                            makeCapitalized: aKeyboardEvent
	"Force the current selection to uppercase.  Triggered by Cmd-X."
	| prev |
	prev _ $-.  "not a letter"
	self replaceSelectionWith:
		(self selection collect: [:c |
			prev _ prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]]).
	^ true! !
!SimpleEditor methodsFor: 'editing keys' stamp: 'jmv 12/19/2011 12:22'!
                            makeLowercase: aKeyboardEvent
	"Force the current selection to lowercase.  Triggered by Cmd-X."

	self replaceSelectionWith: self selection asLowercase.
	^ true! !
!SimpleEditor methodsFor: 'editing keys' stamp: 'jmv 12/19/2011 12:22'!
                    makeUppercase: aKeyboardEvent
	"Force the current selection to uppercase.  Triggered by Cmd-Y."

	self replaceSelectionWith: self selection asUppercase.
	^ true! !
!SimpleEditor methodsFor: 'private' stamp: 'jmv 9/20/2011 08:46'!
                          privateCurrentString
	"Answer the string I'm editing. Private. Just for internal Editor use."

	^string! !
!SimpleEditor methodsFor: 'private' stamp: 'jmv 3/16/2011 10:44' overrides: 16836846!
                               sameColumn: start newLine: lineBlock forward: isForward
	"See comment in other implementors."
	^start! !
!SimpleEditor methodsFor: 'accessing' stamp: 'jmv 9/6/2017 10:02:17'!
                 replaceSelectionWith: aString
	"Deselect, and replace the selection text by aText."

	| start stop |
	morph disablesEditing ifTrue: [
		^ self ].
	start _ self startIndex.
	stop _ self stopIndex.
	(start = stop and: [aString size = 0]) ifFalse: [
		string _ string copyReplaceFrom: start to: stop-1 with: aString.	
		self deselectAndPlaceCursorAt:  start + aString size.
		self userHasEdited  " -- note text now dirty" ]! !
!SimpleEditor methodsFor: 'accessing' stamp: 'jmv 9/22/2011 16:52'!
                    string
	^string! !
!SimpleEditor methodsFor: 'new selection' stamp: 'jmv 9/19/2011 09:12'!
     selectFrom: start to: stop

	"Select the specified characters inclusive."
	self selectInvisiblyFrom: start to: stop! !
!SimpleEditor methodsFor: 'new selection' stamp: 'jmv 10/16/2013 22:10'!
selectLine
	"Make the receiver's selection, if currently empty, encompass the current line."
	self hasSelection ifTrue:[^self].
	self selectAll! !
!SimpleEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 6/10/2012 11:07' overrides: 50625132!
cmdShortcutsSpec
	"
	Editor initialize
	"
	"arranged in QWERTY keyboard order"
	^#(
		#(		$a 	#selectAll:				'Select all')

		#(		$x 	#cut:						'Cut selection and store it in the Clipboard')
		#(		$c 	#copySelection:			'Copy selection to the Clipboard')
		#(		$v 	#paste:					'Paste Clipboard contents')
		#(		$ 	#selectWord:			'Select the current word as with double clicking')
	)! !
!LimitedHeightTextMorph methodsFor: 'initialization' stamp: 'jmv 8/21/2012 21:59' overrides: 50729722!
                       initialize
	super initialize.
	extent _  200 @ 120! !
!LimitedHeightTextMorph methodsFor: 'geometry' stamp: 'jmv 12/12/2011 14:20' overrides: 16934089!
        innerHeight: aNumber
	"Adjust height and scrollbar to the new contents height."
	self morphHeight: (aNumber + 10 min: maxHeight)! !
!LimitedHeightTextMorph methodsFor: 'geometry' stamp: 'jmv 7/20/2014 10:12' overrides: 50721202!
                           privateExtent: aPoint

	^ (super privateExtent: aPoint)
		ifTrue: [
			maxHeight _ extent y ]; yourself! !
!LimitedHeightTextMorph methodsFor: 'accessing' stamp: 'jmv 11/14/2011 16:32'!
      maxHeight: aNumber
	maxHeight _ aNumber! !
!DragAndDropAreaMorph methodsFor: 'drag and drop us' stamp: 'jmv 1/24/2013 22:53' overrides: 50729542!
              aboutToBeGrabbedBy: aHand
	"The receiver is being grabbed by a hand.
	Perform necessary adjustments (if any) and return the actual morph
	that should be added to the hand.
	Answer nil to reject the drag."
	"This message is sent to the dragged morph, not to the owner.
	It is included here just for reference."

	^self "Grab me"! !
!DragAndDropAreaMorph methodsFor: 'drag and drop us' stamp: 'jmv 1/24/2013 22:53' overrides: 16874378!
              justDroppedInto: newOwnerMorph event: anEvent 
	"This message is sent to a dropped morph after it has been dropped on -- and been accepted by -- a drop-sensitive morph"
	"This message is sent to the dragged morph, not to the owner.
	It is included here just for reference."

	^super justDroppedInto: newOwnerMorph event: anEvent ! !
!DragAndDropAreaMorph methodsFor: 'drag and drop us' stamp: 'jmv 1/24/2013 22:53' overrides: 16874387!
            justGrabbedFrom: formerOwner
	"The receiver was just grabbed from its former owner and is now attached to the hand."
	"This message is sent to the dragged morph, not to the owner.
	It is included here just for reference."! !
!DragAndDropAreaMorph methodsFor: 'drag and drop us' stamp: 'jmv 1/24/2013 22:53' overrides: 16874422!
                        wantsToBeDroppedInto: aMorph
	"Return true if it's okay to drop the receiver into aMorph. This check is symmetric to #wantsDroppedMorph:event: to give both parties a chance of figuring out whether they like each other."
	"This message is sent to the dragged morph, not to the owner.
	It is included here just for reference."

	^true! !
!DragAndDropAreaMorph methodsFor: 'drag and drop other morphs' stamp: 'jmv 1/24/2013 22:52' overrides: 16874692!
                               allowsMorphDrop
	"Answer whether we accept dropping morphs. Redefined to answer true."

	^ true! !
!DragAndDropAreaMorph methodsFor: 'drag and drop other morphs' stamp: 'jmv 1/24/2013 22:52' overrides: 16874701!
            allowsSubmorphDrag
	"Answer whether our morphs can just be grabbed with the hand, instead of requiring the use of the halo. Redefined to answer true."

	^ true! !
!DragAndDropAreaMorph methodsFor: 'drag and drop other morphs' stamp: 'jmv 1/24/2013 22:52' overrides: 16874409!
            wantsDroppedMorph: aMorph event: evt
	"Return true if the receiver wishes to accept the given morph, which is being dropped by a hand in response to the given event. Note that for a successful drop operation both parties need to agree. The symmetric check is done automatically via aMorph wantsToBeDroppedInto: self.
	This method just answers super. It is included here to say it is relevant to D&D behavior."

	^super wantsDroppedMorph: aMorph event: evt! !
!PartsBinMorph methodsFor: 'dropping/grabbing' stamp: 'jmv 2/22/2013 12:49' overrides: 16874368!
                    aboutToGrab: aMorph
	"submorph is being grabbed by a hand.
	Perform necessary adjustments (if any) and return the actual morph
	that should be added to the hand.
	Answer nil to reject the drag."

	^aMorph copy! !
!EllipseMorph methodsFor: 'drawing' stamp: 'jmv 4/9/2015 09:43' overrides: 50721109!
                      drawOn: aCanvas 

	| rx ry |
	self revisar. "The morph should be specified better!!"
	rx _ extent x //2.
	ry _ extent y // 2.
	aCanvas ellipseCenterX: rx y: ry rx: rx ry: ry borderWidth: borderWidth borderColor: borderColor fillColor: color! !
!EllipseMorph methodsFor: 'geometry testing' stamp: 'jmv 10/7/2009 23:21' overrides: 50721214!
             isOrthoRectangularMorph
	^false! !
!EllipseMorph methodsFor: 'geometry testing' stamp: 'pb 3/17/2020 13:36:07' overrides: 50721227!
                            morphContainsPoint: aLocalPoint

	| radius other delta xOverY |
	(self morphLocalBounds containsPoint: aLocalPoint) ifFalse: [^ false].  "quick elimination"
	extent > `1@1`
		ifFalse: [^ true].  "Degenerate case -- code below fails by a bit"

	radius _ extent y asFloat / 2.
	other _ extent x asFloat / 2.
	delta _ aLocalPoint - (other@radius).
	xOverY _ extent x asFloat / extent y asFloat.
	^ (delta x asFloat / xOverY) squared + delta y squared <= radius squared! !
!EllipseMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:37' overrides: 50721091!
              defaultBorderWidth
	"answer the default border width for the receiver"
	^ 1! !
!EllipseMorph methodsFor: 'visual properties' stamp: 'jmv 3/10/2018 22:24:29' overrides: 50721096!
              defaultColor
	"Return the default fill style for the receiver"
	^ `Color yellow`! !
!EllipseMorph class methodsFor: 'new-morph participation' stamp: 'pb 6/8/2017 23:50:14' overrides: 50721301!
                               categoryInNewMorphMenu
	^ 'Basic'! !
!HandleMorph methodsFor: 'events' stamp: 'jmv 3/12/2018 15:51:54' overrides: 50624438!
    keyStroke: aKeyboardEvent
	"Check for cursor keys"
	| keyValue |
	(owner is: #HandMorph) ifFalse: [ ^self ].
	keyValue _ aKeyboardEvent keyValue.
	keyValue = 28 ifTrue: [ ^self morphPosition: self morphPosition - `1@0` ].
	keyValue = 29 ifTrue: [ ^self morphPosition: self morphPosition + `1@0` ].
	keyValue = 30 ifTrue: [ ^self morphPosition: self morphPosition - `0@1` ].
	keyValue = 31 ifTrue: [ ^self morphPosition: self morphPosition + `0@1` ].
	"Special case for return"
	aKeyboardEvent isReturnKey ifTrue:[
		"Drop the receiver and be done"
	self flag: #arNote. "Probably unnecessary"
		owner releaseKeyboardFocus: self.
		self delete ]! !
!HandleMorph methodsFor: 'initialization' stamp: 'di 11/3/97 16:34'!
                    forEachPointDo: aBlock
	pointBlock _ aBlock! !
!HandleMorph methodsFor: 'initialization' stamp: 'jmv 3/12/2018 15:51:51' overrides: 50721101!
                  initialize
	"initialize the state of the receiver"
	super initialize.
	extent _ `12@12`! !
!HandleMorph methodsFor: 'stepping and presenter' stamp: 'jmv 7/22/2020 23:08:01' overrides: 50722820!
                              stepAt: millisecondSinceLast

	pointBlock value: self displayBounds center! !
!HandleMorph methodsFor: 'testing' stamp: 'jmv 6/11/2012 23:32' overrides: 16877010!
                             stepTime
	"Update very often. Very short steptimes should only be used for morphs that are not stepping all the time!!"
	^ 20! !
!HandleMorph class methodsFor: 'new-morph participation' stamp: 'jmv 4/3/2011 22:43' overrides: 16877245!
                     includeInNewMorphMenu
	"Return true for all classes that can be instantiated from the menu"
	^ false! !
!FrameRateMorph methodsFor: 'drawing' stamp: 'jmv 6/11/2020 16:49:32' overrides: 50721109!
                             drawOn: aCanvas
	super drawOn: aCanvas.
	meanStepDelta ifNotNil: [
		aCanvas drawString: lastStepDelta rounded printString at: 0@0 font: FontFamily defaultFamilyAndPointSize color: Color black.
		aCanvas drawString: meanStepDelta rounded printString at: 0@14 font: FontFamily defaultFamilyAndPointSize color: Color black.
		"aCanvas drawString: lastStepStamp printString at: bounds topLeft + (0@28) font: FontFamily defaultFamilyAndPointSize color: Color black "
		]! !
!FrameRateMorph methodsFor: 'stepping' stamp: 'jmv 2/27/2016 19:52' overrides: 50722820!
                 stepAt: millisecondSinceLast

	| n |
	lastStepDelta _ millisecondSinceLast.
	"This factor is a damper, to show a sort of mean of the n latest step deltas"
	meanStepDelta
		ifNil: [ meanStepDelta _ 0. n _ 0 ]
		ifNotNil: [
"			n _ (meanStepDelta / lastStepDelta between: 0.5 and: 2)
				ifTrue: [ 10 ]
				ifFalse: [10 ]."
			n _ 20 ].
	meanStepDelta _ meanStepDelta * n + lastStepDelta / (n+1).
	self redrawNeeded! !
!FrameRateMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 23:34' overrides: 16877010!
      stepTime

	^20! !
!FrameRateMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 09:20' overrides: 16876574!
                     wantsSteps
	"Return true if the receiver wants to its #step or #stepAt: methods be run"

	^true! !
!FunctionGraphMorph methodsFor: 'accessing' stamp: 'jmv 11/18/2014 08:52'!
                  addFunction: aOneArgBlock color: aColor

	functions add: aOneArgBlock.
	colors add: aColor! !
!FunctionGraphMorph methodsFor: 'accessing' stamp: 'jmv 3/9/2018 16:06:11'!
                      domain: anInterval

	xMin _ anInterval first asFloat.
	xMax _ anInterval last asFloat.

	yMin _ nil.
	yMax _ nil.! !
!FunctionGraphMorph methodsFor: 'accessing' stamp: 'jmv 4/21/2020 20:44:35'!
                              yRange: anInterval

	yMin _ anInterval first asFloat.
	yMax _ anInterval last asFloat.
	yRangeInvalid := false.! !
!FunctionGraphMorph methodsFor: 'drawing' stamp: 'jmv 6/11/2020 16:49:39' overrides: 50721109!
              drawOn: aCanvas
	"
	| g |
	g _ FunctionGraphMorph new.
	g domain: (-4 to: 4).
	g addFunction: [ :x | x mod: 1 ] color: Color green.
	g addFunction: [ :x | x div: 1 ] color: Color red.
	g openInWorld
	"
	| r fontToUse xtra p prevP |
	yRangeInvalid ifTrue: [
		yMin _ Float infinity.
		yMax _ Float negativeInfinity.
		self iterate: [ :x :y :c |
			y notNil ifTrue: [
				yMin _ yMin min: y.
				yMax _ yMax max: y ]].
		yMax = yMin ifTrue: [
			yMin _ yMin min: 0.
			yMax _ yMax max: 0 ].
		xtra _ yMax-yMin/50.
		yMin _ yMin - xtra.
		yMax _ yMax + xtra.
		yRangeInvalid := false.
		].
			
	r _ 40@0 corner: extent - (0@20).
	aCanvas
		frameAndFillRectangle: r fillColor: (Color gray: 0.9)
		borderWidth: 0.05 borderColor: Color white.
	(0 between: xMin and: xMax) ifTrue: [
		aCanvas line: (self toMorphic:0@yMin)-(0@2) to: (self toMorphic: 0 @ yMax)+(0@2) width: 2 color: Color darkGray ].
	(0 between: yMin and: yMax) ifTrue: [
		aCanvas line: (self toMorphic: xMin@0)+(2@0) to: (self toMorphic: xMax@0)-(2@0) width: 2 color: Color darkGray ].

	"To plot lines"
	functions with: colors do: [ :f :c |
		prevP _ nil.
		xMin asFloat to: xMax count: extent x do: [ :x | | y |
			y _ [ f value: x ] on: Error do: [].
			(y notNil and: [
					p _ (self xToMorphic: x)@(self yToMorphic: y).
					(r containsPoint: p) ])
				ifFalse: [
					prevP _ nil]
				ifTrue: [
					prevP notNil ifTrue: [
						aCanvas line: prevP to: p width: 2 color: c ].
					prevP _ p ]]].

	"To plot just the points"
	"self iterate: [ :x :y :c |
		(y between: yMin and: yMax) ifTrue: [
			r2 _ (self xToMorphic: x)@(self yToMorphic: y) extent: 2.5.
			(r containsRect: r2) ifTrue: [
				aCanvas
					fillRectangle: r2
					color: c ]]]."

	fontToUse _ FontFamily defaultFamilyAndPointSize.
	aCanvas drawString: xMin printString at: 40@(extent y - 16) font: fontToUse color: Color black.
	aCanvas drawString: xMax printString at: extent -(32@16) font: fontToUse color: Color black.
	aCanvas drawString: yMin printString at: 4@(extent y - 32) font: fontToUse color: Color black.
	aCanvas drawString: yMax printString at: 4@4 font: fontToUse color: Color black.! !
!FunctionGraphMorph methodsFor: 'drawing' stamp: 'jmv 4/21/2020 20:25:25'!
                           iterate: aBlock

	| y |
	functions with: colors do: [ :f :c |
		xMin asFloat to: xMax count: extent x do: [ :x |
			y _ [ f value: x ] on: Error do: [].
			aBlock value: x value: y asFloat value: c ]]! !
!FunctionGraphMorph methodsFor: 'initialization' stamp: 'pb 5/27/2019 18:19:57' overrides: 50721101!
               initialize
	super initialize.
	extent _ 320@240.
	functions _ OrderedCollection new.
	colors _ OrderedCollection new.
	yRangeInvalid := true! !
!FunctionGraphMorph methodsFor: 'initialization' stamp: 'pb 5/27/2019 18:19:17'!
                               invalidateYRange
	yRangeInvalid := true! !
!FunctionGraphMorph methodsFor: 'geometry' stamp: 'jmv 5/17/2015 09:20'!
            toMorphic: aPoint
	^(self xToMorphic: aPoint x) @ (self yToMorphic: aPoint y)! !
!FunctionGraphMorph methodsFor: 'geometry' stamp: 'jmv 11/25/2016 11:03:22'!
  xToMorphic: x
	^x - xMin / (xMax - xMin ) * (extent x-40)+40! !
!FunctionGraphMorph methodsFor: 'geometry' stamp: 'jmv 11/25/2016 11:03:27'!
                   yToMorphic: y
	^yMax - y / (yMax - yMin ) * (extent y-20)! !
!MagnifierMorph methodsFor: 'menu' stamp: 'di 9/28/1999 23:06' overrides: 16876144!
               addCustomMenuItems: aCustomMenu hand: aHandMorph
	super addCustomMenuItems: aCustomMenu hand: aHandMorph.
	aCustomMenu
		addLine;
		add: 'magnification...' action: #chooseMagnification;
		addUpdating: #trackingPointerString action: #toggleTrackingPointer;
		addUpdating: #toggleRoundString action: #toggleRoundness.! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 8/21/2012 21:53'!
chooseMagnification
	| result |
	result _ (SelectionMenu selections: #(1.5 2 4 8))
		startUpWithCaption: 'Choose magnification
(currently ', magnification printString, ')'.
	(result == nil or: [ result = magnification ]) ifTrue: [ ^ self ].
	magnification _ result.
	self morphExtent: extent. "round to new magnification"
	self redrawNeeded. "redraw even if extent wasn't changed"! !
!MagnifierMorph methodsFor: 'menu' stamp: 'jmv 9/22/2012 15:35'!
                               chooseMagnification: evt
	| handle origin aHand currentMag |
	currentMag _ magnification.
	aHand _ evt ifNil: [ self world activeHand ] ifNotNil: [evt hand].
	origin _ aHand morphPosition y.
	handle _ HandleMorph new forEachPointDo:
		[ :newPoint | self magnification: (newPoint y - origin) / 8.0 + currentMag ].
	aHand attachMorph: handle.
	handle startStepping.
	self redrawNeeded. ! !
!MagnifierMorph methodsFor: 'menu' stamp: 'bf 9/20/1999 15:48'!
                            toggleTrackingPointer
	trackPointer _ trackPointer not! !
!MagnifierMorph methodsFor: 'menu' stamp: 'bf 9/20/1999 15:49'!
      trackingPointerString
	^trackPointer
		ifTrue: ['stop tracking pointer']
		ifFalse: ['start tracking pointer']! !
!MagnifierMorph methodsFor: 'geometry' stamp: 'jmv 12/16/2011 10:28' overrides: 50729216!
                    borderWidth: anInteger
	"Grow outwards preserving innerBounds"
	| c |  
	c _ self referencePosition.
	super borderWidth: anInteger.
	super morphExtent: self defaultExtent.
	self referencePosition: c.! !
!MagnifierMorph methodsFor: 'geometry' stamp: 'bf 9/21/1999 09:22'!
                 defaultExtent
	^(srcExtent * magnification) truncated + (2 * borderWidth)! !
!MagnifierMorph methodsFor: 'geometry' stamp: 'jmv 6/6/2014 18:06' overrides: 50721202!
                           privateExtent: aPoint
	"Round to multiples of magnification"

	srcExtent _ (aPoint - (2 * borderWidth)) // magnification.
	^ super privateExtent: self defaultExtent! !
!MagnifierMorph methodsFor: 'initialization' stamp: 'jmv 12/2/2011 10:20' overrides: 50721091!
                         defaultBorderWidth
	"answer the default border width for the receiver"
	^ 1! !
!MagnifierMorph methodsFor: 'initialization' stamp: 'jmv 9/13/2013 10:02' overrides: 50721101!
                  initialize
	super initialize.
	trackPointer _ true.
	magnification _ 2.
	self morphExtent: 128@128! !
!MagnifierMorph methodsFor: 'drawing' stamp: 'jmv 10/15/2020 15:44:41' overrides: 50721109!
                              drawOn: aCanvas
	RecursionLock == self ifFalse: [
		super drawOn: aCanvas.		"border and fill"
		self magnifiedForm ifNotNil: [ :f |
			aCanvas image: f at: borderWidth@borderWidth ]]! !
!MagnifierMorph methodsFor: 'event handling testing' stamp: 'jmv 1/17/2013 17:27' overrides: 16874721!
                               handlesMouseDown: aMouseButtonEvent

	^aMouseButtonEvent mouseButton2Pressed! !
!MagnifierMorph methodsFor: 'round view' stamp: 'jmv 12/10/2010 09:25'!
        isRound

	^ "owner isMemberOf: ScreeningMorph" false! !
!MagnifierMorph methodsFor: 'round view' stamp: 'di 9/28/1999 23:17'!
  toggleRoundString
	^ self isRound
		ifTrue: ['be square']
		ifFalse: ['be round']! !
!MagnifierMorph methodsFor: 'round view' stamp: 'jmv 12/11/2011 23:35'!
   toggleRoundness
	| |
"	w _ self world.
	self isRound
		ifTrue: [owner delete.
				w addMorph: self]
		ifFalse: [sm _ ScreeningMorph new position: self zzposition.
				sm addMorph: self.
				sm addMorph: (EllipseMorph newBounds: self bounds).
				w addMorph: sm]
			"! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 12/16/2011 10:28'!
          magnification: aNumber
	| c |  
	magnification _ aNumber min: 8 max: 0.5.
	magnification _ magnification roundTo:
		(magnification < 3 ifTrue: [0.5] ifFalse: [1]).
	srcExtent _ srcExtent min: (512@512) // magnification. "to prevent accidents"
	c _ self referencePosition.
	super morphExtent: self defaultExtent.
	self referencePosition: c.! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 10/15/2020 15:44:20'!
                              magnifiedForm
	| srcRect form neededExtent |
	self displayBounds ifNil: [ ^nil ].
	lastPos _ self sourcePoint.
	srcRect _ self sourceRectFrom: lastPos.
	((srcRect intersects: self displayBounds) and: [ RecursionLock == nil ])
		ifTrue: [
			RecursionLock _ self.
			"try to reuse form if appropriate"
			auxCanvas _ (auxCanvas notNil and: [ auxCanvas extent = srcExtent ])
				ifTrue: [
					"Just in case we go out of the Display"
					srcRect origin > (0@0) ifFalse: [
						auxCanvas form fillBlack ].
					BitBltCanvas on: auxCanvas form over: srcRect ]
				ifFalse: [ BitBltCanvas depth: 32 over: srcRect ].
			auxCanvas fullDraw: self world.
			form _ auxCanvas form.
			RecursionLock _ nil]
		ifFalse: [
			"cheaper method if the source is not occluded"
			form _ Display copy: srcRect].
	"smooth if non-integer scale"
	neededExtent _ (srcExtent * magnification ) truncated.
	(magnifiedForm isNil or: [ magnifiedForm extent ~=  neededExtent ])
		ifTrue: [ magnifiedForm _ Form extent: neededExtent depth: 32 ].
	(WarpBlt toForm: magnifiedForm)
		sourceForm: form;
		colorMap: (form colormapIfNeededFor: magnifiedForm);
		cellSize: (magnification isInteger ifTrue: [1] ifFalse: [2]);  "installs a new colormap if cellSize > 1"
		combinationRule: 3;
		copyQuad: form boundingBox innerCorners toRect: magnifiedForm boundingBox.
	^magnifiedForm.! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 10/15/2020 15:40:20'!
             sourcePoint
	"If we are being dragged use our center, otherwise use pointer position"
	(trackPointer not or: [owner notNil and: [owner is: #HandMorph]])
		ifTrue: [ self displayBounds ifNotNil: [ :r | ^r center ]].
	^self world activeHand morphPosition! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 8/4/2012 16:41'!
                          sourceRect
	"world global coordinates, etc"
	self flag: #jmvVer2.
	^self sourceRectFrom: self sourcePoint! !
!MagnifierMorph methodsFor: 'magnifying' stamp: 'jmv 8/17/2012 18:52'!
            sourceRectFrom: aPoint
	^ (aPoint extent: srcExtent) translatedBy: (srcExtent // -2) + 1.
! !
!MagnifierMorph methodsFor: 'events' stamp: 'jmv 1/14/2013 22:45' overrides: 16874571!
           mouseButton2Down: aMouseButtonEvent localPosition: localEventPosition

	self chooseMagnification: aMouseButtonEvent! !
!MagnifierMorph methodsFor: 'stepping' stamp: 'jmv 2/27/2016 19:53' overrides: 50722820!
                stepAt: millisecondSinceLast

	self redrawNeeded! !
!MagnifierMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 23:32' overrides: 16877010!
                   stepTime
	"Update very often. Very short steptimes should only be used for morphs that are not stepping all the time!!"
	^ 20! !
!MagnifierMorph methodsFor: 'stepping' stamp: 'jmv 6/11/2012 09:58' overrides: 16876574!
      wantsSteps
	"Return true if the receiver wants to its #step or #stepAt: methods be run ALL THE TIME.
	Morphs that send #startStepping and #stopStepping at appropriate times (i.e. when they are already in the world!!) don't need to answer true to this message"

	^true! !
!MinimalStringMorph methodsFor: 'accessing' stamp: 'jmv 6/6/2014 10:58'!
        contents: newContents 
	contents _ (newContents is: #Text)
		ifTrue: [
			emphasis := newContents emphasisAt: 1.
			 newContents string]
		ifFalse: [
			contents = newContents ifTrue: [^self].	"no substantive change"
			newContents].
	self fitContents.
	self redrawNeeded! !
!MinimalStringMorph methodsFor: 'accessing' stamp: 'jmv 1/1/2015 21:16'!
    fitContents
	"Measures contents later at #minimumExtent"
	self morphExtent: 0@0! !
!MinimalStringMorph methodsFor: 'accessing' stamp: 'jmv 6/11/2020 16:49:55'!
fontToUse
	| fontToUse |
	fontToUse := font ifNil: [FontFamily defaultFamilyAndPointSize].
	^(emphasis isNil or: [emphasis = 0]) 
		ifTrue: [fontToUse]
		ifFalse: [fontToUse emphasized: emphasis]! !
!MinimalStringMorph methodsFor: 'accessing' stamp: 'jmv 4/25/2019 10:09:59'!
            measureContents
	| f |
	f _ self fontToUse.
	^(((f widthOfString: contents) max: 3)  @ f lineSpacing).! !
!MinimalStringMorph methodsFor: 'initialization' stamp: 'cbr 12/3/2010 23:29' overrides: 50721096!
                   defaultColor
	"answer the default color/fill style for the receiver"
	^ Theme current text! !
!MinimalStringMorph methodsFor: 'initialization' stamp: 'jmv 9/10/2010 22:55'!
                   initWithContents: aString font: aFont emphasis: emphasisCode 
	self initialize.
	
	font _ aFont.
	emphasis _ emphasisCode.
	self contents: aString! !
!MinimalStringMorph methodsFor: 'initialization' stamp: 'jmv 9/10/2010 22:55' overrides: 50721101!
       initialize
	super initialize.
	font _ nil.
	emphasis _ 0! !
!MinimalStringMorph methodsFor: 'drawing' stamp: 'jmv 7/10/2014 22:41' overrides: 50721109!
        drawOn: aCanvas

	aCanvas drawString: contents at: 0@0 font: self fontToUse color: color! !
!MinimalStringMorph class methodsFor: 'instance creation' stamp: 'jmv 4/3/2011 22:34'!
             contents: aString
	" 'StringMorph contents: str' is faster than 'StringMorph new contents: str' 
	(MinimalStringMorph contents: 'Some string') openInWorld
	"
	^ self contents: aString font: nil! !
!MinimalStringMorph class methodsFor: 'instance creation' stamp: 'jmv 11/4/2008 12:56'!
   contents: aString font: aFont
	^ self basicNew initWithContents: aString font: aFont emphasis: 0! !
!MinimalStringMorph class methodsFor: 'instance creation' stamp: 'jmv 11/4/2008 12:56'!
    contents: aString font: aFont emphasis: emphasisCode
	^ self basicNew initWithContents: aString font: aFont emphasis: emphasisCode! !
!MinimalStringMorph class methodsFor: 'instance creation' stamp: 'jmv 4/3/2011 22:34' overrides: 16783533!
               new
	^self contents: 'some string'! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 6/11/2020 16:50:03'!
             baseFont

	font ifNil: [ font _ FontFamily defaultFamilyAndPointSize ].
	^font! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 3/16/2011 10:34'!
    contents
	^contents! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 3/16/2011 10:41'!
                               contents: newContents 
	contents _ (newContents is: #Text)
		ifTrue: [
			emphasis := newContents emphasisAt: 1.
			 newContents string]
		ifFalse: [
			contents = newContents ifTrue: [^self].	"no substantive change"
			newContents].
	editor _ nil.
	self fitContents.
	self redrawNeeded! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 1/5/2013 14:23'!
                     crAction
	"Answer the optional Cr action"
	^crAction! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 1/5/2013 14:24'!
                               crAction: aBlock
	
	crAction := aBlock! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 9/6/2017 10:02:09'!
          disableEditing
	self setProperty: #disablesEditing toValue: true.
	self stopBlinking! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 12/4/2011 22:25'!
                              editor
	"Return my current editor, or install a new one."
	editor ifNil: [ self installEditor ].
	^editor! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 1/1/2015 21:16'!
          fitContents
	"Measures contents later at #minimumExtent"
	self morphExtent: 0@0! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 11/5/2008 13:18'!
   fontToUse

	^ (emphasis isNil or: [emphasis = 0]) 
		ifTrue: [ self baseFont ]
		ifFalse: [ self baseFont emphasized: emphasis ]! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 3/17/2011 07:58'!
                  keyboardFocusWatcher: aMorph
	"We are usually used as a part of a bigger morph.
	Usually, that morph would be interested in us changing keyboard focus.
	An alternative implementation would be to define a new type of event, but:
		- I (jmv) prefer explicit message sends to registering in events.
		- There are too many evens already defined. It would be good to reduce that."
	keyboardFocusWatcher _ aMorph! !
!OneLineEditorMorph methodsFor: 'accessing' stamp: 'jmv 4/25/2019 10:10:16'!
                         measureContents
	| f |

	f _ self fontToUse.
	^((f widthOfString: contents) max: 3)  @ f lineSpacing.! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 4/25/2019 10:10:12'!
            characterIndexAtPoint: aPoint

	| line block f |
	f _ self fontToUse.
	
	line _ TextLine 
		start: 1
		stop: contents size
		internalSpaces: 0
		paddingWidth: 0.
	line
		rectangle: (0@0 extent: extent);
		lineHeight: f lineSpacing baseline: f ascent.
		
	block _ (CharacterBlockScanner new text: (contents asText font: f))
		defaultFont: f;
		characterBlockAtPoint: aPoint index: nil
		in: line.

	^ block stringIndex! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 10/16/2013 22:37'!
                  displayTextCursorAtX: x top: top bottom: bottom emphasis: anEmphasis on: aCanvas
	| textCursorColor x1 isBold isItalic x0 h w halfW r d |
	isBold _ anEmphasis allMask: 1.
	isItalic _ anEmphasis allMask: 2.
	textCursorColor _ Theme current textCursor.
	h _ bottom - top.
	w _ isBold
		ifTrue: [ h // 25 + 2 ]
		ifFalse: [ h // 30 + 1 ].
	halfW _ w // 2.
	isItalic
		ifTrue: [	
			"Keep tweaking if needed!!"
			d _ isBold ifTrue: [ 3 ] ifFalse: [ h // 24].
			x0 _ x- (h*5//24) + d.
			x1 _ x + d ]
		ifFalse: [
			x0 _ x.
			x1 _ x].
	x0 < halfW ifTrue: [
		x1 _ x1 - x0 + halfW.
		x0 _ halfW ].
	r _ extent x-halfW-1.
	r < x1 ifTrue: [
		x0 _ x0 + r - x1.
		x1 _ r ].
	textCursorRect _ x0-halfW-1@ top corner: x1+halfW+1+1 @ bottom.
	aCanvas
		line: x0+halfW@bottom to: x1+halfW@(top+w)
		width: w color: textCursorColor! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'KenD 10/23/2020 13:50:33' overrides: 50721109!
      drawOn: aCanvas
	self hasSelection ifTrue: [ self drawSelectionOn: aCanvas ].
	self hasTextCursor ifTrue: [ self drawTextCursorOn: aCanvas ].
	aCanvas
		drawString: contents
		at: 0@0 + borderWidth
		font: self fontToUse
		color: color.
	(borderWidth > 0) ifTrue: [
		aCanvas
			frameRectangle: (0@0 extent: extent)
			color: borderColor
			borderWidth: borderWidth
			borderStyleSymbol: #simple ]! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 4/25/2019 10:07:24'!
    drawSelectionOn: aCanvas
	| rightX leftX bottom |

	bottom _ self baseFont lineSpacing.
	leftX _ self fontToUse widthOfString: contents from: 1 to: editor startIndex-1.
	leftX _ leftX min: extent x.
	rightX _ self fontToUse widthOfString: contents from: 1 to: editor stopIndex-1.
	rightX _ rightX min: extent x.

	aCanvas
		fillRectangle: (leftX+1 @ 1 corner: (rightX + 2) @ (bottom + 2))
		color: (Theme current textHighlightFocused: self hasKeyboardFocus)! !
!OneLineEditorMorph methodsFor: 'drawing' stamp: 'jmv 4/25/2019 10:07:30'!
        drawTextCursorOn: aCanvas
	|  bottom x |

	showTextCursor ifTrue: [
		bottom _ self baseFont lineSpacing.
		x _ self fontToUse widthOfString: contents from: 1 to: editor startIndex-1.
		self displayTextCursorAtX: x top: 0 bottom: bottom emphasis: emphasis on: aCanvas ]! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 08:43'!
        clickAndHalf: aMouseButtonEvent localPosition: localEventPosition
	self handleInteraction: [ self editor clickAndHalf ]! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 1/5/2021 14:34:30' overrides: 50624438!
        keyStroke: aKeyboardEvent
	"Handle a keystroke event."

	(self focusKeyboardFor: aKeyboardEvent)
		ifTrue: [ ^ self ].

	"Return - check for special action
	Note: Code below assumes that this was some
	input field reacting on Return."
	aKeyboardEvent isReturnKey ifTrue: [
		crAction ifNotNil: [
			"Break the keyboard focus so that the receiver can be safely deleted."
			"Is this needed at all? (jmv)"
			"aKeyboardEvent hand newKeyboardFocus: nil."
			^crAction value ]].

	self pauseBlinking.
	self handleInteraction: [ self editor processKeystrokeEvent: aKeyboardEvent ].
	self updateFromContents.
	super keyStroke: aKeyboardEvent  "sends to keyStroke event handler, if any"! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 1/14/2013 22:27' overrides: 16874541!
                          mouseButton1Down: aMouseButtonEvent localPosition: localEventPosition
	"Make this TextMorph be the keyboard input focus, if it isn't already,
		and repond to the text selection gesture."

	aMouseButtonEvent hand newKeyboardFocus: self.

	self handleInteraction: [
		self editor mouseDown: aMouseButtonEvent index: (self characterIndexAtPoint: localEventPosition) ].

	aMouseButtonEvent hand
		waitForClicksOrDragOrSimulatedMouseButton2: self
		event: aMouseButtonEvent
		clkSel: nil
		clkNHalf: #clickAndHalf:localPosition:
		dblClkSel: nil
		dblClkNHalfSel: nil
		tripleClkSel: nil! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 1/14/2013 23:16' overrides: 16874556!
                           mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition

	super mouseButton1Up: aMouseButtonEvent localPosition: localEventPosition.
	self pauseBlinking
! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/20/2012 18:07' overrides: 16874629!
                            mouseEnter: event
	super mouseEnter: event.
	Preferences focusFollowsMouse
		ifTrue: [ event hand newKeyboardFocus: self ]! !
!OneLineEditorMorph methodsFor: 'events' stamp: 'jmv 8/21/2012 13:20' overrides: 16874651!
       mouseMove: aMouseMoveEvent localPosition: localEventPosition

	aMouseMoveEvent mouseButton1Pressed ifFalse: [ ^ self ].
	self handleInteraction: [
		self editor mouseMove: aMouseMoveEvent index: (self characterIndexAtPoint: localEventPosition) ]! !
!OneLineEditorMorph methodsFor: 'initialization' stamp: 'cbr 12/3/2010 23:29' overrides: 50721096!
    defaultColor
	"answer the default color/fill style for the receiver"
	^ Theme current text! !
!OneLineEditorMorph methodsFor: 'initialization' stamp: 'jmv 11/5/2008 12:15'!
                   initWithContents: aString font: aFont emphasis: emphasisCode 
	self initialize.
	
	font _ aFont.
	emphasis _ emphasisCode.
	self contents: aString! !
!OneLineEditorMorph methodsFor: 'initialization' stamp: 'jmv 10/16/2013 22:19' overrides: 50721101!
      initialize
	super initialize.
	contents _ ''.
	font _ nil.
	emphasis _ 0.
	showTextCursor _ false. "Should never be nil"! !
!OneLineEditorMorph methodsFor: 'event handling testing' stamp: 'jmv 9/6/2017 10:02:10'!
           disablesEditing

	^self hasProperty: #disablesEditing! !
!OneLineEditorMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:52' overrides: 16874712!
                            handlesKeyboard

	^self visible! !
!OneLineEditorMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:52' overrides: 16874721!
                  handlesMouseDown: aMouseButtonEvent
	^ true! !
!OneLineEditorMorph methodsFor: 'event handling testing' stamp: 'jmv 8/20/2012 18:52' overrides: 16874746!
      handlesMouseOver: evt
	"implements #mouseEnter: and/or #mouseLeave:"
	^true! !
!OneLineEditorMorph methodsFor: 'events-processing' stamp: 'jmv 12/28/2011 22:45' overrides: 50598908!
          focusKeyboardFor: aKeyboardEvent
	"If aKeyboardEvent tab or shift-tab use it to navigate keyboard focus.
	ctrl key ignored."
	aKeyboardEvent keyValue = 9
		ifTrue: [
			aKeyboardEvent shiftPressed
				ifFalse: [ aKeyboardEvent hand keyboardFocusNext ]
				ifTrue: [ aKeyboardEvent hand keyboardFocusPrevious ].
			^ true ].
	^super focusKeyboardFor: aKeyboardEvent! !
!OneLineEditorMorph methodsFor: 'events-processing' stamp: 'KenD 10/29/2015 20:43' overrides: 50726351!
        fontPreferenceChanged

	font := nil.
	self baseFont.! !
!OneLineEditorMorph methodsFor: 'events-processing' stamp: 'jmv 3/6/2015 08:59' overrides: 16875216!
   keyboardFocusChange: aBoolean 
	aBoolean
		ifTrue: [
			"A hand is wanting to send us characters..."
			editor ifNil: [ self editor ].	"Forces install"
			self selectAll.
			self showsBlinkingCursor ifTrue: [
				self startBlinking ]]
		ifFalse: [
			self stopBlinking.
			keyboardFocusWatcher ifNotNil: [
				keyboardFocusWatcher lostFocus: self ]].
	self redrawNeeded! !
!OneLineEditorMorph methodsFor: 'editing' stamp: 'jmv 10/16/2013 21:03'!
  handleInteraction: interactionBlock
	"Perform the changes in interactionBlock, noting any change in selection
	and possibly a change in the size of the composition"

	"Also couple the editor to Morphic keyboard events"

	| oldEditor oldContents |
	oldEditor _ editor.
	oldContents _ contents.
	interactionBlock value.
	oldContents == contents 
		ifTrue: [ "this will not work if the composition changed"
			editor _ oldEditor	"since it may have been changed while in block"].
	self redrawNeeded! !
!OneLineEditorMorph methodsFor: 'testing' stamp: 'jmv 11/5/2008 12:41'!
      hasSelection

	^editor notNil and: [editor hasSelection]! !
!OneLineEditorMorph methodsFor: 'testing' stamp: 'jmv 10/16/2013 22:18'!
                           hasTextCursor

	^ self hasKeyboardFocus and: [editor notNil and: [editor hasSelection not]]! !
!OneLineEditorMorph methodsFor: 'unaccepted edits' stamp: 'jmv 3/14/2011 09:21'!
                hasUnacceptedEdits: aBoolean
	"Set the hasUnacceptedEdits flag to the given value. "
	
	self flag: #jmv.
	"Not used in this morph, as it doesn't do accept / cancel"
	self redrawNeeded! !
!OneLineEditorMorph methodsFor: 'private' stamp: 'jmv 12/4/2011 22:25'!
                             installEditor
	"Install an editor for my contents.  This constitutes 'hasFocus'.
	If priorEditor is not nil, then initialize the new editor from its state.
	We may want to rework this so it actually uses the prior editor."

	editor _ SimpleEditor new morph: self.
	editor changeString: contents.
	self redrawNeeded.
	^editor! !
!OneLineEditorMorph methodsFor: 'private' stamp: 'jmv 12/29/2011 15:05'!
               updateFromContents

	"O contents deberia ser un StringHolder????"
	contents _ self editor string.
	self redrawNeeded! !
!OneLineEditorMorph methodsFor: 'geometry' stamp: 'KenD 10/26/2020 12:18:58' overrides: 50674733!
      minimumExtent

	^ self measureContents + self extentBorder ! !
!OneLineEditorMorph methodsFor: 'blink cursor' stamp: 'jmv 7/18/2014 14:53'!
                    onBlinkCursor
	"Blink the cursor"
	showTextCursor _ showTextCursor not | pauseBlinking.
	pauseBlinking _ false.
	textCursorRect ifNotNil: [ :r | self invalidateLocalRect: r]! !
!OneLineEditorMorph methodsFor: 'blink cursor' stamp: 'jmv 3/6/2015 08:59'!
   pauseBlinking
	"Show a solid cursor (non blinking) for a short while"
	pauseBlinking _ true.
	self showsBlinkingCursor ifTrue: [
		"Show cursor right now if needed"
		showTextCursor ifFalse: [
			showTextCursor _ true.
			textCursorRect ifNotNil: [ :r | self invalidateLocalRect: r ]]]! !
!OneLineEditorMorph methodsFor: 'blink cursor' stamp: 'jmv 9/6/2017 10:02:15'!
                showsBlinkingCursor

	^self handlesKeyboard and: [ self disablesEditing not ]! !
!OneLineEditorMorph methodsFor: 'blink cursor' stamp: 'jmv 2/2/2014 22:20'!
   startBlinking
	"And show the cursor"
	pauseBlinking _ true.
	"Start blinking in a short while"
	showTextCursor _ true.
	self startStepping: #onBlinkCursor stepTime: 500! !
!OneLineEditorMorph methodsFor: 'blink cursor' stamp: 'jmv 7/18/2014 14:53'!
       stopBlinking
	"And do not show cursor anymore."
	self stopStepping: #onBlinkCursor.
	"Hide cursor right now if needed"
	showTextCursor ifTrue: [
		showTextCursor _ false.
		textCursorRect ifNotNil: [ :r | self invalidateLocalRect: r ]]! !
!OneLineEditorMorph methodsFor: 'typing/selecting keys' stamp: 'jmv 3/16/2011 10:45'!
                           selectAll
	self editor selectAll.
	self redrawNeeded! !
!OneLineEditorMorph class methodsFor: 'instance creation' stamp: 'jmv 3/16/2011 10:25'!
                contents: aString
	" 'StringMorph contents: str' is faster than 'StringMorph new contents: str' 
	(OneLineEditorMorph contents: 'Some string') openInWorld
	"
	^ self contents: aString font: nil! !
!OneLineEditorMorph class methodsFor: 'instance creation' stamp: 'jmv 11/4/2008 12:47'!
   contents: aString font: aFont
	^ self basicNew initWithContents: aString font: aFont emphasis: 0! !
!OneLineEditorMorph class methodsFor: 'instance creation' stamp: 'jmv 11/4/2008 12:47'!
    contents: aString font: aFont emphasis: emphasisCode
	^ self basicNew initWithContents: aString font: aFont emphasis: emphasisCode! !
!OneLineEditorMorph class methodsFor: 'instance creation' stamp: 'jmv 4/3/2011 22:35' overrides: 16783533!
               new
	^self contents: 'some string'! !
!SamplePlotterMorph methodsFor: 'accessing' stamp: 'jmv 9/3/2020 18:39:17'!
              addSamples: aCollection color: aColor

	sampleSequences add: aCollection asFloat32Array.
	colors add: aColor! !
!SamplePlotterMorph methodsFor: 'accessing' stamp: 'jmv 7/9/2017 20:01:57'!
    domain: aCollection
	"Usually an Interval"
	domain _ aCollection! !
!SamplePlotterMorph methodsFor: 'initialization' stamp: 'jmv 7/9/2017 20:04:21' overrides: 50721101!
                       initialize
	super initialize.
	extent _ 320@240.
	sampleSequences _ OrderedCollection new.
	colors _ OrderedCollection new! !
!SamplePlotterMorph methodsFor: 'geometry' stamp: 'jmv 7/9/2017 20:07:20'!
                       toMorphic: aPoint
	^(self xToMorphic: aPoint x) @ (self yToMorphic: aPoint y)! !
!SamplePlotterMorph methodsFor: 'geometry' stamp: 'jmv 7/9/2017 20:06:50'!
    xToMorphic: x
	^x - domain first / (domain last - domain first) * (extent x-40)+40! !
!SamplePlotterMorph methodsFor: 'geometry' stamp: 'jmv 7/9/2017 20:07:01'!
                               yToMorphic: y
	^yMax - y / (yMax - yMin ) * (extent y-20)! !
!SamplePlotterMorph methodsFor: 'drawing' stamp: 'jmv 6/11/2020 16:50:13' overrides: 50721109!
    drawOn: aCanvas

	| r xtra fontToUse r2 xMax xMin |
	yMin ifNil: [
		yMin _ Float infinity.
		yMax _ Float negativeInfinity.
		self iterate: [ :x :y :c |
			yMin _ yMin min: y.
			yMax _ yMax max: y ].
		yMax = yMin ifTrue: [
			yMin _ yMin min: 0.
			yMax _ yMax max: 0 ].
		xtra _ yMax-yMin/50.
		yMin _ yMin - xtra.
		yMax _ yMax + xtra
		].

	xMin _ domain first.
	xMax _ domain last.
	r _ 40@0 corner: extent - (0@20).
	aCanvas
		frameAndFillRectangle: r fillColor: (Color gray: 0.9)
		borderWidth: 0.05 borderColor: Color white.
	(0 between: xMin and: xMax) ifTrue: [
		aCanvas line: (self toMorphic:0@yMin)-(0@2) to: (self toMorphic: 0 @ yMax)+(0@2) width: 2 color: Color darkGray ].
	(0 between: yMin and: yMax) ifTrue: [
		aCanvas line: (self toMorphic: xMin@0)+(2@0) to: (self toMorphic: xMax@0)-(2@0) width: 2 color: Color darkGray ].

	self iterate2: [ :x :y :c |
		(y between: yMin and: yMax) ifTrue: [
			r2 _ (self xToMorphic: x)@(self yToMorphic: y) extent: 2.5.
			r2 _ (self xToMorphic: x)@(self yToMorphic: y) corner: (self xToMorphic: x)+1@(self yToMorphic: 0) .
			(r containsRect: r2) ifTrue: [
				aCanvas
					fillRectangle: r2
					color: c ]]].
	fontToUse _ FontFamily defaultFamilyAndPointSize.
	aCanvas drawString: xMin printString at: 40@(extent y - 16) font: fontToUse color: Color black.
	aCanvas drawString: xMax printString at: extent -(32@16) font: fontToUse color: Color black.
	aCanvas drawString: yMin printString at: 4@(extent y - 32) font: fontToUse color: Color black.
	aCanvas drawString: yMax printString at: 4@4 font: fontToUse color: Color black.! !
!SamplePlotterMorph methodsFor: 'drawing' stamp: 'jmv 3/9/2018 16:07:07'!
                            iterate2: aBlock
"inline..."
	| y |
	sampleSequences with: colors do: [ :seq :c |
		domain first asFloat to: domain last count: extent x do: [ :x |
			y _ seq at: (
				domain
					findBinaryIndex: [ :arg | x - arg]
					do: [ :i | i ]
					ifNone: [ :a :b | a = 0 ifFalse: [ a] ifTrue: [b]]
				).
			aBlock value: x value: y value: c ]]! !
!SamplePlotterMorph methodsFor: 'drawing' stamp: 'jmv 7/9/2017 20:22:21'!
iterate: aBlock
"inline..."
	sampleSequences with: colors do: [ :seq :c |
		domain with: seq do: [ :x :y |
			aBlock value: x value: y value: c ]]! !
!TextEditorTest methodsFor: 'as yet unclassified' stamp: 'jmv 12/28/2017 16:11:57'!
                      testSimpleEditor
	"
	TextEditorTest new testSimpleEditor
	"
	| m |
	self shouldnt: [
		m _ OneLineEditorMorph new.
		m editor offerMenuFromEsc:
			(KeyboardEvent new
				setType: #keystroke
				buttons: 0
				position: 0@0
				keyValue: 65
				hand: UISupervisor ui activeHand
				stamp: 0)
	] raise: Exception! !
!TextEditorTest methodsFor: 'testing' stamp: 'jmv 4/19/2016 10:22'!
  testUndoRedo
	"
	TextEditorTest new testUndoRedo
	"
	| editor model textComposition m text1 text0 text2 |
	text0 _ ''.
	model _ TextModel withText: text0 copy.
	editor _ TextEditor new.
	m _ InnerTextMorph new.
	m privateOwner: TextModelMorph new.
	m model: model.
	editor morph: m.
	editor instVarNamed: 'emphasisHere' put: Array new.
	editor model: model.
	textComposition _ TextComposition new.
	textComposition
		setModel: model;
		extentForComposing: 300@300.
	editor textComposition: textComposition.
	textComposition editor: editor.
	textComposition composeAll.

	text1 _ 'some words' asText.
	editor addString: text1.
	self assert: model actualContents = text1.
	editor undo.
	self assert: model actualContents = text0.
	editor redo.
	self assert: model actualContents = text1.

	text2 _ ' additional inserted stuff' asText.
	editor addString: text2.
	self assert: model actualContents = (text1, text2).
	editor undo.
	self assert: model actualContents = text1.
	editor undo.
	self assert: model actualContents = text0.
	editor redo.
	self assert: model actualContents = text1.
	editor redo.
	self assert: model actualContents = (text1, text2).! !

----End fileIn of /opt/Cuis/Packages/Morphic/Morphic-Widgets-Extras.pck.st----!

CodePackage subclass: #MorphicMisc1Package
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Misc1'!

!classDefinition: #MorphicMisc1Package category: 'Morphic-Misc1' stamp: 'Install-Morphic-Misc1 7/1/2021 17:57:52'!
CodePackage subclass: #MorphicMisc1Package
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Misc1'!
!MorphicMisc1Package commentStamp: '<historical>' prior: 0!
                          My purpose in life is to check that any base image methods overridden have not been updated.
See #MorphMisc1Package class>>prePackageInstall!

MorphicMisc1Package class
	instanceVariableNames: ''!

!classDefinition: 'MorphicMisc1Package class' category: 'Morphic-Misc1' stamp: 'Install-Morphic-Misc1 7/1/2021 17:57:52'!
MorphicMisc1Package class
	instanceVariableNames: ''!

'From Cuis 5.0 [latest update: #4519] on 5 January 2021 at 3:01:24 pm'!

'Description Various basic morphs used by several packages -- KenD'!

SystemOrganization addCategory: 'Morphic-Misc1'!

CodePackage subclass: #MorphicMisc1Package
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Misc1'!

!classDefinition: #MorphicMisc1Package category: 'Morphic-Misc1' stamp: 'Install-Morphic-Misc1 7/1/2021 17:57:53'!
CodePackage subclass: #MorphicMisc1Package
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Misc1'!

MorphicMisc1Package class
	instanceVariableNames: ''!

!classDefinition: 'MorphicMisc1Package class' category: 'Morphic-Misc1' stamp: 'Install-Morphic-Misc1 7/1/2021 17:57:53'!
MorphicMisc1Package class
	instanceVariableNames: ''!
!MorphicMisc1Package commentStamp: '<historical>' prior: 50342838!
         My purpose in life is to check that any base image methods overridden have not been updated.
See #MorphMisc1Package class>>prePackageInstall!
!MorphicMisc1Package class methodsFor: 'installing' stamp: 'KenD 3/13/2020 14:01:21' overrides: 50576180!
        prePackageInstall

	"Check that any method in base image that I wish to override has not changed"
	
	"Morph>>changeColor
	 Last updated   2013-03-05T13:29:00+00:00 @@"
	self assert:
		(Morph methodDictionary at: #changeColor) dateAndTime =
			(DateAndTime
				year: 2013
				month: 3
				day: 5
				hour: 13
				minute: 29
				second: 0).
! !

MorphicMisc1Package prePackageInstall!

!classRemoval: #WordsClientWindow stamp: 'AW 7/1/2021 17:59:00'!
ProtoObject subclass: #WordsClientWindow
	instanceVariableNames: 'sentenceTextBoxMorph wordsListMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!

!classRemoval: #WordsRestInterface stamp: 'AW 7/1/2021 17:59:00'!
Object subclass: #WordsRestInterface
	instanceVariableNames: 'port'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!

!classRemoval: #WordsClientWindowModel stamp: 'AW 7/1/2021 17:59:01'!
Object subclass: #WordsClientWindowModel
	instanceVariableNames: 'sentence words selectedIndex restInterface'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!

!classRemoval: #MorphicMisc1Package stamp: 'AW 7/1/2021 17:59:14'!
CodePackage subclass: #MorphicMisc1Package
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Misc1'!

CodePackage subclass: #MorphicMisc1Package
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Misc1'!

!classDefinition: #MorphicMisc1Package category: 'Morphic-Misc1' stamp: 'Install-Morphic-Misc1 7/1/2021 18:00:21'!
CodePackage subclass: #MorphicMisc1Package
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Misc1'!
!MorphicMisc1Package commentStamp: '<historical>' prior: 0!
                   My purpose in life is to check that any base image methods overridden have not been updated.
See #MorphMisc1Package class>>prePackageInstall!

MorphicMisc1Package class
	instanceVariableNames: ''!

!classDefinition: 'MorphicMisc1Package class' category: 'Morphic-Misc1' stamp: 'Install-Morphic-Misc1 7/1/2021 18:00:21'!
MorphicMisc1Package class
	instanceVariableNames: ''!

'From Cuis 5.0 [latest update: #4519] on 5 January 2021 at 3:01:24 pm'!

'Description Various basic morphs used by several packages -- KenD'!

SystemOrganization addCategory: 'Morphic-Misc1'!

CodePackage subclass: #MorphicMisc1Package
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Misc1'!

!classDefinition: #MorphicMisc1Package category: 'Morphic-Misc1' stamp: 'Install-Morphic-Misc1 7/1/2021 18:00:21'!
CodePackage subclass: #MorphicMisc1Package
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Misc1'!

MorphicMisc1Package class
	instanceVariableNames: ''!

!classDefinition: 'MorphicMisc1Package class' category: 'Morphic-Misc1' stamp: 'Install-Morphic-Misc1 7/1/2021 18:00:21'!
MorphicMisc1Package class
	instanceVariableNames: ''!
!MorphicMisc1Package commentStamp: '<historical>' prior: 50342942!
         My purpose in life is to check that any base image methods overridden have not been updated.
See #MorphMisc1Package class>>prePackageInstall!
!MorphicMisc1Package class methodsFor: 'installing' stamp: 'KenD 3/13/2020 14:01:21' overrides: 50576180!
        prePackageInstall

	"Check that any method in base image that I wish to override has not changed"
	
	"Morph>>changeColor
	 Last updated   2013-03-05T13:29:00+00:00 @@"
	self assert:
		(Morph methodDictionary at: #changeColor) dateAndTime =
			(DateAndTime
				year: 2013
				month: 3
				day: 5
				hour: 13
				minute: 29
				second: 0).
! !

MorphicMisc1Package prePackageInstall!

CodePackage subclass: #MorphicMisc1Package
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Misc1'!

!classDefinition: #MorphicMisc1Package category: 'Morphic-Misc1' stamp: 'Install-Morphic-Misc1 7/1/2021 18:00:39'!
CodePackage subclass: #MorphicMisc1Package
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Misc1'!
!MorphicMisc1Package commentStamp: '<historical>' prior: 50342982!
         My purpose in life is to check that any base image methods overridden have not been updated.
See #MorphMisc1Package class>>prePackageInstall!

MorphicMisc1Package class
	instanceVariableNames: ''!

!classDefinition: 'MorphicMisc1Package class' category: 'Morphic-Misc1' stamp: 'Install-Morphic-Misc1 7/1/2021 18:00:39'!
MorphicMisc1Package class
	instanceVariableNames: ''!

'From Cuis 5.0 [latest update: #4519] on 5 January 2021 at 3:01:24 pm'!

'Description Various basic morphs used by several packages -- KenD'!

SystemOrganization addCategory: 'Morphic-Misc1'!

CodePackage subclass: #MorphicMisc1Package
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Misc1'!

!classDefinition: #MorphicMisc1Package category: 'Morphic-Misc1' stamp: 'Install-Morphic-Misc1 7/1/2021 18:00:39'!
CodePackage subclass: #MorphicMisc1Package
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Morphic-Misc1'!

MorphicMisc1Package class
	instanceVariableNames: ''!

!classDefinition: 'MorphicMisc1Package class' category: 'Morphic-Misc1' stamp: 'Install-Morphic-Misc1 7/1/2021 18:00:39'!
MorphicMisc1Package class
	instanceVariableNames: ''!
!MorphicMisc1Package commentStamp: '<historical>' prior: 50343017!
         My purpose in life is to check that any base image methods overridden have not been updated.
See #MorphMisc1Package class>>prePackageInstall!
!MorphicMisc1Package class methodsFor: 'installing' stamp: 'KenD 3/13/2020 14:01:21' prior: 50342990 overrides: 50576180!
                        prePackageInstall

	"Check that any method in base image that I wish to override has not changed"
	
	"Morph>>changeColor
	 Last updated   2013-03-05T13:29:00+00:00 @@"
	self assert:
		(Morph methodDictionary at: #changeColor) dateAndTime =
			(DateAndTime
				year: 2013
				month: 3
				day: 5
				hour: 13
				minute: 29
				second: 0).
! !

MorphicMisc1Package prePackageInstall!

Panel subclass: #WordsClientWindow
	instanceVariableNames: 'sentenceTextBoxMorph wordsListMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!

!classDefinition: #WordsClientWindow category: 'WordsClientDemo' stamp: 'AW 7/1/2021 18:02:18'!
ProtoObject subclass: #WordsClientWindow
	instanceVariableNames: 'sentenceTextBoxMorph wordsListMorph'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!
!WordsClientWindow methodsFor: 'initialization' stamp: 'NR 6/22/2021 08:25:04'!
               defaultExtent

	^ 1035@485
	! !
!WordsClientWindow methodsFor: 'initialization' stamp: 'NR 6/23/2021 06:54:42'!
                initializeWith: aTitle

	self titleMorph showButtonsNamed: #( close collapse ).
	self setLabel: aTitle.
	self model: (WordsClientWindowModel new).
	self morphExtent: (self defaultExtent).
	self buildMorphicWindow.
	self openInWorld.
	self yourself.
			
	self model when: #newWordsArrived send: #refreshListOfWords to: self.! !
!WordsClientWindow methodsFor: 'access' stamp: 'NR 6/23/2021 06:58:02'!
                 refreshListOfWords
	
	wordsListMorph updateList.
	wordsListMorph setSelectionIndex: 0.
	! !
!WordsClientWindow methodsFor: 'GUI building' stamp: 'NR 6/28/2021 19:01:09'!
                      build1stColumn2ndRow
	| firstColumnLayoutMorphOfSecondRow |
	
	wordsListMorph := PluggableListMorph model: self model listGetter: #words indexGetter: #wordsListIndex indexSetter: #wordsListIndex:.
	wordsListMorph  borderColor: Color skyBlue; borderWidth: 1; morphWidth:300.
		
	firstColumnLayoutMorphOfSecondRow := LayoutMorph newColumn.
	firstColumnLayoutMorphOfSecondRow separation: 5; 
	axisEdgeWeight: 0.5;
	addMorph: (LabelMorph contents:'Results');
	addMorph: wordsListMorph.
	
	"Dos opciones para jugar con los layouts... ¿Qué diferencia hay?"
	firstColumnLayoutMorphOfSecondRow layoutSpec fixedWidth: 390.
	"wordsListMorph layoutSpec proportionalWidth: 100.
	wordsListMorph layoutSpec proportionalHeight: 100."
		
	^firstColumnLayoutMorphOfSecondRow.
	! !
!WordsClientWindow methodsFor: 'GUI building' stamp: 'NR 6/28/2021 18:34:12'!
                      build1stRow
	| sendRequestButtonMorph firstRowLayoutMorph |
	
	sendRequestButtonMorph := PluggableButtonMorph model: self model stateGetter: nil action: #sendWordsFromSentenceRequest  label: 'Send Request To Server'.
	
	sentenceTextBoxMorph := TextModelMorph textProvider: self model textGetter: #sentenceText textSetter: #sentenceText:. 
	sentenceTextBoxMorph textMorph setProperty: #keyStroke: toValue: [ :key | sentenceTextBoxMorph textMorph acceptContents ] .
	sentenceTextBoxMorph  borderWidth: 1; borderColor: Color skyBlue; morphWidth: 300. 
		
	firstRowLayoutMorph := LayoutMorph newRow.
	firstRowLayoutMorph separation: 25;
	axisEdgeWeight: 0.5;
	addMorph: (LabelMorph contents:'Enter sentence:');
	addMorph: sentenceTextBoxMorph;
 	addMorph: sendRequestButtonMorph.
	
	^firstRowLayoutMorph.! !
!WordsClientWindow methodsFor: 'GUI building' stamp: 'NR 6/23/2021 06:37:31'!
              build2ndRow
	| showInTranscriptButtonMorph secondRowLayoutMorph |
	
	showInTranscriptButtonMorph := PluggableButtonMorph model: self model stateGetter: nil  action: #showWordInTranscript label: 'Show Selected Word In Transcript'.	
	
	secondRowLayoutMorph := LayoutMorph newRow.
	secondRowLayoutMorph separation: 25;
	axisEdgeWeight: 0.5;
	addMorph: self build1stColumn2ndRow;
	addMorph: showInTranscriptButtonMorph.
	
	^secondRowLayoutMorph.
	! !
!WordsClientWindow methodsFor: 'GUI building' stamp: 'NR 6/22/2021 05:23:32'!
                   buildMorphicWindow
		
	self layoutMorph beColumn;
	separation: 15;
	axisEdgeWeight: 0;
	addMorph: self build1stRow;
	addMorph: self build2ndRow.
	! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

WordsClientWindow class
	instanceVariableNames: ''!

!classDefinition: 'WordsClientWindow class' category: 'WordsClientDemo' stamp: 'AW 7/1/2021 18:02:18'!
WordsClientWindow class
	instanceVariableNames: ''!
!WordsClientWindow class methodsFor: 'instance creation' stamp: 'NR 6/23/2021 06:32:18'!
     open
	
	^self new initializeWith: 'Words-Service Client Window'.! !

Object subclass: #WordsClientWindowModel
	instanceVariableNames: 'sentence words selectedIndex restInterface'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!

!classDefinition: #WordsClientWindowModel category: 'WordsClientDemo' stamp: 'AW 7/1/2021 18:02:18'!
Object subclass: #WordsClientWindowModel
	instanceVariableNames: 'sentence words selectedIndex restInterface'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!
!WordsClientWindowModel methodsFor: 'PluggableListSelectors' stamp: 'NR 6/23/2021 06:56:13'!
    words
	
	^words.
! !
!WordsClientWindowModel methodsFor: 'PluggableListSelectors' stamp: 'NR 6/23/2021 06:56:37'!
              wordsListIndex
	
	^selectedIndex.! !
!WordsClientWindowModel methodsFor: 'PluggableListSelectors' stamp: 'NR 6/23/2021 06:56:49'!
                              wordsListIndex: anIndex
	
	selectedIndex := anIndex.! !
!WordsClientWindowModel methodsFor: 'initialization' stamp: 'NR 6/23/2021 07:56:07' overrides: 16896425!
                               initialize

	words := OrderedCollection new.
	sentence := ''.
	selectedIndex := 0.
	restInterface := WordsRestInterface new.! !
!WordsClientWindowModel methodsFor: 'TextModelMorphSelectors' stamp: 'NR 6/25/2019 21:43:32'!
  sentenceText
	
	^sentence.! !
!WordsClientWindowModel methodsFor: 'TextModelMorphSelectors' stamp: 'NR 6/23/2021 07:08:56'!
    sentenceText: aSentence

	sentence := aSentence.
	^true.! !
!WordsClientWindowModel methodsFor: 'PluggableButtonSelectors' stamp: 'NR 6/23/2021 07:56:07'!
     sendWordsFromSentenceRequest
		
	words := restInterface sendRequest: sentence.
	
	self triggerEvent: #newWordsArrived with: self.
	! !
!WordsClientWindowModel methodsFor: 'PluggableButtonSelectors' stamp: 'NR 6/23/2021 06:51:02'!
                          showWordInTranscript
	
	(selectedIndex = 0) ifFalse: 
		[TranscriptWindow openTranscript.
		Transcript clear.
		Transcript show: 'The word selected is: '.
		Transcript show: (words at: selectedIndex).
		Transcript show: ' '.].
! !

Object subclass: #WordsRestInterface
	instanceVariableNames: 'port'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!

!classDefinition: #WordsRestInterface category: 'WordsClientDemo' stamp: 'AW 7/1/2021 18:02:18'!
Object subclass: #WordsRestInterface
	instanceVariableNames: 'port'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WordsClientDemo'!
!WordsRestInterface methodsFor: 'sending requests' stamp: 'NR 6/25/2019 22:25:36'!
   correctlyEncodeSpacesForUrlRequestParameter: aParameter
	
	^ aParameter copyReplaceAll: ' ' with: '%20'. ! !
!WordsRestInterface methodsFor: 'sending requests' stamp: 'NR 6/23/2021 07:54:44'!
sendRequest: sentence

	| fieldDict resp urlEncodedSentence |

	urlEncodedSentence := self correctlyEncodeSpacesForUrlRequestParameter: sentence.	
	fieldDict := Dictionary newFromPairs: {'sentence'. urlEncodedSentence.}.		
	
	resp:= WebClient htmlSubmit: (self url,'/words') fields: fieldDict.
	
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection .] 
		ifFalse:[^self error: resp content].! !
!WordsRestInterface methodsFor: 'initialization' stamp: 'NR 6/25/2019 22:15:16'!
                      port
	
	^port ifNil: [port:=8080].! !
!WordsRestInterface methodsFor: 'initialization' stamp: 'NR 6/24/2019 06:52:37'!
         url
	
	^'http://localhost:', self port asString! !

----End fileIn of /home/awolfsdorf/Dropbox/CSCOM/IngeSoft1/2021-1c/20-TusLibros/Iteracion 4/WordsClientDemo.st----!

'From Cuis 5.0 [latest update: #4532] on 23 June 2021 at 9:17:24 pm'!

'Description Description - This package is a port and refactoring of WebClient from http://ss3.gemstone.com/ss/WebClient.html with moderate changes by David Graham and Juan Vuletich.
	- WebClient-Core-ul.100
	- WebClient-Help-ar.10
	- WebClient-Tests-topa.48
- Hernan Wilkinson: 
  - Added useDebugErrorHandler and debugErrorHandler to be able to debug a http request
  - Changed exampleDoIt to support Smalltalk expresions in the URL using GET'!

SystemOrganization addCategory: 'WebClient-Core'!

SystemOrganization addCategory: 'WebClient-SqueakSSL-Core'!

ReadStream subclass: #WebChunkedStream
	instanceVariableNames: 'sourceStream chunkSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebChunkedStream category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
ReadStream subclass: #WebChunkedStream
	instanceVariableNames: 'sourceStream chunkSize'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

WebChunkedStream class
	instanceVariableNames: ''!

!classDefinition: 'WebChunkedStream class' category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebChunkedStream class
	instanceVariableNames: ''!

Error subclass: #SqueakSSLCertificateError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

!classDefinition: #SqueakSSLCertificateError category: 'WebClient-SqueakSSL-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
Error subclass: #SqueakSSLCertificateError
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

SqueakSSLCertificateError class
	instanceVariableNames: ''!

!classDefinition: 'SqueakSSLCertificateError class' category: 'WebClient-SqueakSSL-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
SqueakSSLCertificateError class
	instanceVariableNames: ''!

Exception subclass: #WebAuthRequired
	instanceVariableNames: 'client request response authParams message'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebAuthRequired category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
Exception subclass: #WebAuthRequired
	instanceVariableNames: 'client request response authParams message'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

WebAuthRequired class
	instanceVariableNames: ''!

!classDefinition: 'WebAuthRequired class' category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebAuthRequired class
	instanceVariableNames: ''!

Socket subclass: #SecureSocket
	instanceVariableNames: 'ssl decoded readBuf sendBuf'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

!classDefinition: #SecureSocket category: 'WebClient-SqueakSSL-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
Socket subclass: #SecureSocket
	instanceVariableNames: 'ssl decoded readBuf sendBuf'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

SecureSocket class
	instanceVariableNames: ''!

!classDefinition: 'SecureSocket class' category: 'WebClient-SqueakSSL-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
SecureSocket class
	instanceVariableNames: ''!

SocketStream subclass: #SecureSocketStream
	instanceVariableNames: 'ssl sendBuf readBuf decoded certIssues'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

!classDefinition: #SecureSocketStream category: 'WebClient-SqueakSSL-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
SocketStream subclass: #SecureSocketStream
	instanceVariableNames: 'ssl sendBuf readBuf decoded certIssues'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

SecureSocketStream class
	instanceVariableNames: ''!

!classDefinition: 'SecureSocketStream class' category: 'WebClient-SqueakSSL-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
SecureSocketStream class
	instanceVariableNames: ''!

Object subclass: #WebClient
	instanceVariableNames: 'flags server scheme timeout stream cookies proxyServer lastScheme lastServer lastPort maxRedirect redirections userAgent authParams proxyParams accessLog debugLog'
	classVariableNames: 'DebugLog FlagAcceptCookies FlagAllowAuth FlagAllowRedirect ProxyHandler'
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebClient category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
Object subclass: #WebClient
	instanceVariableNames: 'flags server scheme timeout stream cookies proxyServer lastScheme lastServer lastPort maxRedirect redirections userAgent authParams proxyParams accessLog debugLog'
	classVariableNames: 'DebugLog FlagAcceptCookies FlagAllowAuth FlagAllowRedirect ProxyHandler'
	poolDictionaries: ''
	category: 'WebClient-Core'!

WebClient class
	instanceVariableNames: ''!

!classDefinition: 'WebClient class' category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebClient class
	instanceVariableNames: ''!

Object subclass: #WebCookie
	instanceVariableNames: 'name value path domain expiry version secure httpOnly comment'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebCookie category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
Object subclass: #WebCookie
	instanceVariableNames: 'name value path domain expiry version secure httpOnly comment'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

WebCookie class
	instanceVariableNames: ''!

!classDefinition: 'WebCookie class' category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebCookie class
	instanceVariableNames: ''!

Object subclass: #WebMessage
	instanceVariableNames: 'stream protocol headers content'
	classVariableNames: 'StatusCodes'
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebMessage category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
Object subclass: #WebMessage
	instanceVariableNames: 'stream protocol headers content'
	classVariableNames: 'StatusCodes'
	poolDictionaries: ''
	category: 'WebClient-Core'!

WebMessage class
	instanceVariableNames: ''!

!classDefinition: 'WebMessage class' category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebMessage class
	instanceVariableNames: ''!

WebMessage subclass: #WebRequest
	instanceVariableNames: 'method request rawUrl server'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebRequest category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebMessage subclass: #WebRequest
	instanceVariableNames: 'method request rawUrl server'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

WebRequest class
	instanceVariableNames: ''!

!classDefinition: 'WebRequest class' category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebRequest class
	instanceVariableNames: ''!

WebMessage subclass: #WebResponse
	instanceVariableNames: 'request status code url'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebResponse category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebMessage subclass: #WebResponse
	instanceVariableNames: 'request status code url'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

WebResponse class
	instanceVariableNames: ''!

!classDefinition: 'WebResponse class' category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebResponse class
	instanceVariableNames: ''!

Object subclass: #WebServer
	instanceVariableNames: 'listenerSocket listenerProcess interface port mutex connections entryPoints vault logAction nonceCache sessions serverString errorHandler accessLog certName siteUrl'
	classVariableNames: 'Default Registry'
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebServer category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
Object subclass: #WebServer
	instanceVariableNames: 'listenerSocket listenerProcess interface port mutex connections entryPoints vault logAction nonceCache sessions serverString errorHandler accessLog certName siteUrl'
	classVariableNames: 'Default Registry'
	poolDictionaries: ''
	category: 'WebClient-Core'!

WebServer class
	instanceVariableNames: ''!

!classDefinition: 'WebServer class' category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebServer class
	instanceVariableNames: ''!

Object subclass: #WebSocket
	instanceVariableNames: 'name process stream handlers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebSocket category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
Object subclass: #WebSocket
	instanceVariableNames: 'name process stream handlers'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

WebSocket class
	instanceVariableNames: ''!

!classDefinition: 'WebSocket class' category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebSocket class
	instanceVariableNames: ''!

WebSocket subclass: #WebSocket00
	instanceVariableNames: 'frameType frameData'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebSocket00 category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebSocket subclass: #WebSocket00
	instanceVariableNames: 'frameType frameData'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

WebSocket00 class
	instanceVariableNames: ''!

!classDefinition: 'WebSocket00 class' category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebSocket00 class
	instanceVariableNames: ''!

WebSocket subclass: #WebSocket07
	instanceVariableNames: 'frameType frameData closing masking'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebSocket07 category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebSocket subclass: #WebSocket07
	instanceVariableNames: 'frameType frameData closing masking'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

WebSocket07 class
	instanceVariableNames: ''!

!classDefinition: 'WebSocket07 class' category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebSocket07 class
	instanceVariableNames: ''!

Object subclass: #WebUtils
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

!classDefinition: #WebUtils category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
Object subclass: #WebUtils
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-Core'!

WebUtils class
	instanceVariableNames: 'currentProxyServer'!

!classDefinition: 'WebUtils class' category: 'WebClient-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
WebUtils class
	instanceVariableNames: 'currentProxyServer'!

Object subclass: #SqueakSSL
	instanceVariableNames: 'handle readBlock writeBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

!classDefinition: #SqueakSSL category: 'WebClient-SqueakSSL-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
Object subclass: #SqueakSSL
	instanceVariableNames: 'handle readBlock writeBlock'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'WebClient-SqueakSSL-Core'!

SqueakSSL class
	instanceVariableNames: ''!

!classDefinition: 'SqueakSSL class' category: 'WebClient-SqueakSSL-Core' stamp: 'Install-WebClient 7/1/2021 18:05:24'!
SqueakSSL class
	instanceVariableNames: ''!
!WebChunkedStream commentStamp: 'ar 1/31/2012 14:00' prior: 50888086!
         Can process chunked data.!
!WebAuthRequired commentStamp: 'ar 2/10/2012 12:39' prior: 50888089!
Exception signaled when authentication is required.!
!SecureSocketStream commentStamp: 'ar 7/25/2010 14:19' prior: 50888093!
   A variant on SocketStream supporting SSL/TLS encryption via SqueakSSL.
!
!WebClient commentStamp: 'jmv 6/25/2017 22:23:28' prior: 50888098!
                    WebClient provides a simple yet complete HTTP client implementation.

To retrieve the contents of a web page:
(WebClient httpGet: 'http://www.cuis-smalltalk.org/') content

INTRO
-------

The simplest form to use WebClient is by one of its convenience APIs:

	WebClient httpGet: 'http://www.squeak.org/'.
	WebClient httpPost: 'http://www.squeak.org/' content:'Hello Squeak' type: 'text/plain'.

For more elaborate use of headers and some other options in the request, a client can utilize modified variants:

	WebClient new httpGet: 'http://www.squeak.org/' do: [ :req|
		"Set an if-modified-since header"
		req headerAt: 'If-Modified-Since' put: 'Sat, 29 Oct 1994 19:43:31 GMT'.
		"Add several accept headers"
		req addHeader: 'Accept' value: 'text/plain'.
		req addHeader: 'Accept' value: 'application/x-foo-bar'.
		req addHeader: 'Accept' value: 'image/jpg'.
	].

The set of utility methods is limited to a few useful ones but it is easy to do the setup on your own:

	| url client request data |
	data := 'Hello Squeak'.								"POST data"
	url := 'http://www.squeak.org/'.						"POST url"
	client := WebClient new initializeFromUrl: url. 		"sets host etc"
	request := client requestWithUrl: url. 				"sets path etc"
	request method: 'POST'.							"sets method"
	request headerAt: 'Content-Length' put: data size.
	request headerAt: 'Content-Type' put: 'text/plain'.
	"... any other headers required ..."
	^client sendRequest: request 
		content: data readStream
		size: data size.

The utility methods like httpGet: etc. are similarly simple requests.

RESPONSES
--------------

The WebClient request methods return a WebResponse that the client can process:

	| resp |
	resp := WebClient httpGet: 'http://www.squeak.org/'.
	resp isSuccess ifFalse: [^self error: resp status].
	"Process the content from the response"
	^resp content

In addition, content can be streamed from the response so that it does not need to be downloaded all at once:

	| client resp |
	client := WebClient new.
	[
		resp := client httpGet: 'http://www.squeak.org/'.
		resp isSuccess ifFalse:[^self error: resp status].
		"Stream the content from the response"
		'page.html' asFileEntry forceWriteStreamDo: [ :file |
			resp streamTo: file 
				size: resp contentLength
				progress: [ :total :amount ]].
	] ensure: [ client close].

The progress block in the above can be omitted but has been included in this example to illustrate its usage. The block takes a total length (which can be nil if the length is not known) and the amount that has been loaded.

MULTIPLE REQUESTS
-------------------------

WebClient can and should be used for multiple requests to the same host. This will ensure persistent connections as well as having cookies processed properly within one session:

	| client resp |
	client := WebClient new.
	resp := client httpGet: 'http://www.squeak.org/'.
	resp := client httpGet: 'http://www.squeak.org/Download'.
	resp := client httpGet: 'http://www.squeak.org/Features'.
	client close.

One important issue to keep in mind is that because WebClient is optimized for persistent connections, you need to close it when you are done. That is not true for WebClient's class-side convenience APIs, which prefetch the response and close the socket. Generally speaking, whenever you say 'WebClient new' you need to close the client when you're done (however, you can do so by sending #close to a response you've received). For example:

	"Convenience API. Don't need to close, but prefetches result."
	WebClient httpGet: 'http://www.squeak.org'.

	| client resp |
	"Regular use. Create WebClient, return after header is read ..."
	client := WebClient new.
	[response := client httpGet: 'http://www.squeak.org/'.
	"... then fetch (or stream) the content ..."
	response content.
	] ensure:[
		"... and close the client when done."
		client close.
	].

AUTHENTICATION
---------------------

WebClient supports basic and digest authentication by default. WebClient delegates the retrieval of username/password to WebUtils which prompts the user for credentials. 

WebClient can either be supplied with specific credentials to be used or custom credentials handlers, for example:

	| client |
	client := WebClient new.
	client username: 'squeak'.
	client password: 'squeak'.
	client httpGet: 'http://www.squeak.org/protected'.

Proxy authentication works the same way as authentication but operates on a different authentication context to allow different sets of credentials to work.
!
!WebCookie commentStamp: 'jmv 6/25/2017 19:47:45' prior: 50888240!
                              WebCookie represents an http cookie for use by WebClient.!
!WebMessage commentStamp: 'ar 2/23/2010 10:37' prior: 50888244!
     A common base class for WebRequest and WebResponse.!
!WebRequest commentStamp: 'ar 2/23/2010 10:38' prior: 50888248!
           Represents an HTTP request for WebClient/WebServer.!
!WebResponse commentStamp: 'ar 2/23/2010 10:39' prior: 50888252!
          Represents an HTTP response for WebClient/WebServer.!
!WebServer commentStamp: '<historical>' prior: 50888256!
                 WebServer provides a simple yet complete HTTP server implementation.

Example:
(WebServer new listenOn: 8080) addService: '/hello' action: [ :req | req send200Response: 'Hello World!!']!
!WebSocket commentStamp: '<historical>' prior: 50888264!
            A wrapper object for the WebSocket API.!
!WebSocket00 commentStamp: 'ar 7/8/2010 18:21' prior: 50888268!
                       A wrapper object for the WebSocket API.!
!WebSocket07 commentStamp: '<historical>' prior: 50888271!
                            A wrapper object for the WebSocket API.!
!WebUtils commentStamp: 'ar 2/23/2010 10:39' prior: 50888274!
                         WebUtils contains a number of utility methods used by WebClient/WebServer.!
!SqueakSSL commentStamp: 'ar 7/16/2010 23:14' prior: 50888279!
                     SqueakSSL provides an interface to the platforms SSL/TLS facilities.
!
!WebClient methodsFor: 'printing' stamp: 'ar 8/9/2010 08:50' prior: 50888284 overrides: 50683280!
                       printOn: aStream
	"Print the receiver on aStream"

	aStream nextPutAll: self class name.
	aStream nextPut: $(.
	(stream notNil and:[stream isConnected]) ifTrue:[
		aStream nextPutAll: 'Connected: '.
	].
	scheme ifNotNil:[aStream nextPutAll: scheme, '://'].
	server ifNotNil:[aStream nextPutAll: server].
	aStream nextPut:$).
! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 8/5/2010 18:22' prior: 50888297!
        comment
	"Cookie comment"

	^comment! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 8/5/2010 18:22' prior: 50888301!
         comment: aString
	"Cookie comment"

	comment := aString! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05' prior: 50888306 overrides: 16882612!
 name
	"The name of the cookie"

	^name! !
!WebCookie methodsFor: 'printing' stamp: 'jmv 6/25/2017 19:15:34' prior: 50888311 overrides: 50683280!
               printOn: aStream
	"Creates the string representation for this cookie"

	aStream nextPutAll: name, '=', value asString.
	expiry ifNotNil:[ 
		aStream nextPutAll:'; expires='.
		aStream nextPutAll: expiry dayOfWeekName ,  ', '.
		expiry date printOn: aStream format: #(1 2 3 $- 2 2 2 ).
		aStream nextPutAll: ' ', expiry time print24,' GMT'.
	].
	path ifNotNil:[
		aStream nextPutAll:'; path=', (WebUtils quote: path).
	].
	domain ifNotNil:[
		aStream nextPutAll:'; domain=', (WebUtils quote: domain).
	].
	version ifNotNil:[
		aStream nextPutAll:'; version=', version asString.
	].
	secure ifTrue:[
		aStream nextPutAll: '; secure'.
	].
	httpOnly ifTrue:[
		aStream nextPutAll: '; HttpOnly'.
	].
! !
!WebMessage methodsFor: 'printing' stamp: 'ar 2/20/2010 11:05' prior: 50888336 overrides: 50683280!
 printOn: aStream
	"Prints the receiver"

	aStream nextPutAll: self class name.
	aStream nextPut: $(.
	self writeOn: aStream.
	aStream nextPut: $).! !
!WebSocket methodsFor: 'private' stamp: 'ar 7/8/2010 21:48' prior: 50888344 overrides: 50683280!
         printOn: aStream
	"Print the receiver"

	aStream nextPutAll: self class name.
	aStream nextPutAll: '(', name, ')'.! !
!WebChunkedStream methodsFor: 'testing' stamp: 'ar 1/31/2012 14:26' prior: 50888351 overrides: 50332155!
 atEnd
	^chunkSize = 0 and:[super atEnd]! !
!WebChunkedStream methodsFor: 'accessing' stamp: 'ar 1/31/2012 14:09' prior: 50888356 overrides: 50332161!
          next
	"Answer the next decompressed object in the Stream represented by the
	receiver."

	<primitive: 65>
	position >= readLimit
		ifTrue: [^self pastEndRead]
		ifFalse: [^collection at: (position := position + 1)]! !
!WebChunkedStream methodsFor: 'accessing' stamp: 'ar 1/31/2012 14:25' prior: 50888366 overrides: 16897981!
                           next: anInteger 
	"Answer the next anInteger elements of my collection.  overriden for simplicity"

	[(position + anInteger >= readLimit) and:[chunkSize ~= 0]] 
		whileTrue:[self nextChunk].

	^super next: anInteger
! !
!WebChunkedStream methodsFor: 'accessing' stamp: 'DSG 5/29/2012 13:40' prior: 50888376 overrides: 16891826!
                        nextChunk
	"Answer the next chunk from a message using chunked transfer encoding."

	| chunk |
	chunkSize = 0 ifTrue:[^'']. "read last chunk"
	chunkSize := Integer readFrom: (sourceStream upToAll: String crlfString) asString base: 16.
	chunkSize = 0 ifFalse:[chunk := sourceStream next: chunkSize].
	sourceStream skip: 2. "CrLf"
	(chunkSize + readLimit - position) <= collection size ifTrue:[
		collection replaceFrom: 1 to: (readLimit-position) with: collection startingAt: position+1.
		readLimit := readLimit - position.
		position := 0.
		collection replaceFrom: readLimit+1 to: readLimit + chunkSize with: chunk startingAt: 1.
		readLimit := readLimit + chunkSize.
	] ifFalse:[
		collection := collection, chunk.
		readLimit := readLimit + chunkSize.
	].
	^chunk
! !
!WebChunkedStream methodsFor: 'accessing' stamp: 'ar 1/31/2012 14:11' prior: 50888403!
     pastEndRead
	"Need more data"

	self nextChunk.
	^self next! !
!WebChunkedStream methodsFor: 'initialize' stamp: 'ar 1/31/2012 14:24' prior: 50888408 overrides: 16891868!
                     on: aStream

	sourceStream := aStream.
	collection := (aStream isBinary ifTrue:[ByteArray] ifFalse:[String]) new.
	position := readLimit := 0.! !
!SqueakSSLCertificateError methodsFor: 'testing' stamp: 'ar 8/16/2011 19:18' prior: 50888416 overrides: 16839225!
                            isResumable
	"Determine whether an exception is resumable."

	^true! !
!WebAuthRequired methodsFor: 'accessing' stamp: 'ar 2/10/2012 13:14' prior: 50888421!
   client
	"The client causing the exception"

	^client! !
!WebAuthRequired methodsFor: 'accessing' stamp: 'ar 2/10/2012 13:49' prior: 50888425!
                  message
	"Answer a default message for the user to ask for input"

	self isProxyAuth ifTrue:[
		^'The proxy server at "', client proxyServerName, '" requires authentication.'.
	].

	^'The server at "', client serverName, '" requires authentication.'.! !
!WebAuthRequired methodsFor: 'accessing' stamp: 'ar 2/10/2012 13:04' prior: 50888436!
            request
	"The request object causing the exception"

	^request! !
!WebAuthRequired methodsFor: 'accessing' stamp: 'ar 2/10/2012 13:05' prior: 50888441!
        response
	"The response object causing the exception"

	^response! !
!WebAuthRequired methodsFor: 'initialize' stamp: 'ar 2/10/2012 13:06' prior: 50888446!
    client: aWebClient request: aWebRequest response: aWebResponse
	"Initializes the exception"

	client := aWebClient.
	request := aWebRequest.
	response := aWebResponse.
! !
!WebAuthRequired methodsFor: 'initialize' stamp: 'ar 2/10/2012 13:13' prior: 50888454!
                             username: username password: password
	"Use the given username/password as credentials"

	| params retry |
	params := self isProxyAuth ifTrue:[client proxyParams] ifFalse:[client authParams].
	retry := false.
	(params at: #username ifAbsent:[nil]) = username ifFalse:[
		params at: #username put: username.
		retry := true.
	].
	(params at: #password ifAbsent:[nil]) = password ifFalse:[
		params at: #password put: password.
		retry := true.
	].
	retry ifTrue:[self resume: true].
! !
!WebAuthRequired methodsFor: 'defaults' stamp: 'ar 2/10/2012 13:14' prior: 50888472 overrides: 16839987!
                 defaultAction

	self resume: false.! !
!WebAuthRequired methodsFor: 'defaults' stamp: 'ar 2/10/2012 13:07' prior: 50888476 overrides: 16839966!
                defaultResumeValue
	"Resume with false by default"

	^false! !
!WebAuthRequired methodsFor: 'testing' stamp: 'ar 2/10/2012 13:09' prior: 50888481!
             isProxyAuth
	"Return true if proxy authorization is required"

	^response code = 407! !
!WebAuthRequired methodsFor: 'testing' stamp: 'ar 2/10/2012 13:09' prior: 50888486!
                    isUnauthorized
	"Return true if authorization is required"

	^response code = 401! !
!WebAuthRequired class methodsFor: 'instance creation' stamp: 'ar 2/10/2012 13:16' prior: 50888492!
       client: aWebClient request: aWebRequest response: aWebResponse
	"Creates a new exception"

	^(self new)
		client: aWebClient 
		request: aWebRequest 
		response: aWebResponse! !
!SecureSocket methodsFor: 'accessing' stamp: 'ar 6/17/2012 11:07' prior: 50888500!
                           certState
	^ssl ifNotNil:[ssl certState]! !
!SecureSocket methodsFor: 'accessing' stamp: 'ar 6/17/2012 11:07' prior: 50888505 overrides: 50885120!
             peerName
	^ssl ifNotNil:[ssl peerName]! !
!SecureSocket methodsFor: 'accessing' stamp: 'ar 6/17/2012 11:05' prior: 50888509!
   ssl
	"Answer the SqueakSSL instance"
	^ssl! !
!SecureSocket methodsFor: 'primitives' stamp: 'ar 6/17/2012 12:00' prior: 50888513!
                              decodeData
	"Receive data from the given socket into the given array starting at the given index. Return the number of bytes read or zero if no data is available."
	| total bytesRead |
	decoded atEnd ifFalse:[^self].

	"Decrypt more data if available"
	bytesRead := 0.
	[total := ssl decrypt: readBuf from: 1 to: bytesRead into: decoded originalContents.
	total < 0 ifTrue:[^self error: 'SSL error, code: ', total].
	bytesRead := 0.
	total = 0 ifTrue:[
		bytesRead := super primSocket: socketHandle receiveDataInto: readBuf startingAt: 1 count: readBuf size.
	].
	bytesRead = 0] whileFalse.

	"Update for number of bytes decoded"
	decoded setFrom: 1 to: total.
! !
!SecureSocket methodsFor: 'primitives' stamp: 'ar 6/19/2012 21:12' prior: 50888537 overrides: 50884992!
                               isConnected
	"Return true if this socket is connected."
	"We mustn't return false if there is data available"

	^super isConnected or:[self dataAvailable]! !
!SecureSocket methodsFor: 'primitives' stamp: 'ar 6/17/2012 12:00' prior: 50888545 overrides: 50885230!
                          primSocket: socketID receiveDataInto: buffer startingAt: index count: count
	"Receive data from the given socket into the given array starting at the given index. Return the number of bytes read or zero if no data is available."
	| total |

	ssl ifNil:[^super primSocket: socketID receiveDataInto: buffer startingAt: index count: count].

	self decodeData.

	"Push data from decoded into the result buffer"
	total := (decoded size - decoded position) min: (buffer size - index + 1).
	(decoded readInto: buffer startingAt: index count: total) = total 
		ifFalse:[self error: 'Unexpected read failure'].
	^total
! !
!SecureSocket methodsFor: 'primitives' stamp: 'ar 6/17/2012 11:00' prior: 50888567 overrides: 50885258!
                  primSocket: socketID sendData: buffer startIndex: start count: amount
	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."
	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."

	| count |
	ssl ifNil:[^super primSocket: socketID sendData: buffer startIndex: start count: amount].

	count := ssl encrypt: buffer from: start to: start+amount-1 into: sendBuf.
	count < 0 ifTrue:[self error: 'SSL Error: ', count].
	^super primSocket: socketID sendData: sendBuf startIndex: 1 count: count! !
!SecureSocket methodsFor: 'primitives' stamp: 'ar 6/17/2012 12:01' prior: 50888598 overrides: 50885513!
                     primSocketReceiveDataAvailable: socketID
	"Return true if data may be available for reading from the current socket."

	ssl ifNil:[^super primSocketReceiveDataAvailable: socketID].
	self decodeData.
	^decoded atEnd not! !
!SecureSocket methodsFor: 'initialize' stamp: 'ar 6/17/2012 11:08' prior: 50888608 overrides: 50884854!
                          destroy
	ssl ifNotNil:[
		ssl destroy.
		ssl := nil
	].
	super destroy.! !
!SecureSocket methodsFor: 'initialize' stamp: 'ar 6/17/2012 11:11' prior: 50888614 overrides: 16896425!
             initialize

	super initialize.
	decoded := ReadStream on: (ByteArray new: 20000) from: 1 to: 0.
	sendBuf := ByteArray new: 4096.
	readBuf := ByteArray new: 4096.
! !
!SecureSocket methodsFor: 'connect' stamp: 'ar 6/17/2012 11:05' prior: 50888622!
         sslAccept: certName
	"Perform the SSL server handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete."

	| squeakSSL result inbuf |
	inbuf := ''.
	squeakSSL := SqueakSSL new.
	squeakSSL certName: certName.

	"Perform the server handshake"
	[[squeakSSL isConnected] whileFalse:[
		"Read input"
		inbuf := self receiveData.
		result := squeakSSL accept: inbuf from: 1 to: inbuf size into: sendBuf.

		"Check for errors first"
		result < -1 ifTrue:[^self error: 'SSL accept failed with code: ', result].

		"If a token has been produced in the handshake, send it to the remote"
		result > 0 ifTrue:[self sendData: (sendBuf copyFrom: 1 to: result)].
	].
	"We are connected. From here on, encryption will take place."
	ssl := squeakSSL.
	] ifCurtailed:[
		"Make sure we destroy the platform handle if the handshake gets interrupted"
		squeakSSL destroy.
	].
! !
!SecureSocket methodsFor: 'connect' stamp: 'ul 10/15/2014 19:27' prior: 50888656!
     sslConnect
	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete."

	self sslConnectTo: nil! !
!SecureSocket methodsFor: 'connect' stamp: 'ul 10/15/2014 19:27' prior: 50888667!
    sslConnectTo: serverName
	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete. If serverName is not nil, then try to use it for SNI."

	| inbuf squeakSSL result |
	inbuf := ''.
	squeakSSL := SqueakSSL new.
	serverName ifNotNil: [ squeakSSL serverName: serverName ].
	"Perform the SSL handshake"
	[[result := squeakSSL connect: inbuf from: 1 to: inbuf size into: sendBuf.
	result = 0] whileFalse:[
		"Check for errors first"
		result < -1 ifTrue:[^self error: 'SSL connect failed with code: ', result].

		"If a token has been produced in the handshake, send it to the remote"
		result > 0 ifTrue:[self sendData: (sendBuf copyFrom: 1 to: result)].

		"Read more input and repeat"
		inbuf := self receiveData.
	].
	"We are connected. From here on, encryption will take place."
	ssl := squeakSSL.
	] ifCurtailed:[
		"Make sure we destroy the platform handle if the handshake gets interrupted"
		squeakSSL destroy.
	].
! !
!SecureSocket class methodsFor: 'examples' stamp: 'jmv 6/26/2017 18:57:14' prior: 50888704!
 google: query
	"An example HTTPS query to encrypted.google.com.
	Example:
		SecureSocket google: 'squeak'.
		SecureSocket google: 'SqueakSSL'.
	"

	| hostName address socket |

	"Change the host name to try an https request to some other host"
	hostName := 'encrypted.google.com'.

	address := NetNameResolver addressForName: hostName.
	socket := SecureSocket newTCP.

	"Connect the TCP socket"
	socket connectTo: address port: 443.
	socket waitForConnectionFor: 10.

	["Handle the client handshake"
	socket sslConnectTo: hostName.

	"Verify that the cert is valid"
	socket certState = 0 ifFalse:[
		self error: 'The certificate is invalid (code: ', socket certState,')'.
	].

	"If the certificate is valid, make sure we're were we wanted to go"
	(socket peerName match: hostName) ifFalse:[
		self error: 'Host name mismatch: ', socket peerName.
	].

	"Send encrypted data"
	socket sendData:
		'GET /search?q=', query,' HTTP/1.0', String crlfString,
		'Host: ', hostName, String crlfString,
		'Connection: close', String crlfString,
		String crlfString.

	"Wait for the response"
	^String streamContents:[:s|
		[[true] whileTrue:[s nextPutAll: socket receiveData]]
			on: ConnectionClosed, ConnectionTimedOut do:[:ex| ex return].
	]] ensure:[socket destroy].
! !
!SecureSocketStream methodsFor: 'accessing' stamp: 'ar 7/25/2010 16:31' prior: 50888747 overrides: 50886776!
    ascii
	"Switch to ASCII"

	super ascii.
	decoded := (ReadStream 
		on: decoded originalContents asString 
		from: 1 to: decoded size)
			position: decoded position;
			yourself.
! !
!SecureSocketStream methodsFor: 'accessing' stamp: 'ar 11/9/2010 11:09' prior: 50888756 overrides: 50886837!
                             binary
	"Switch to binary"

	super binary.
	decoded := (ReadStream 
		on: decoded originalContents asByteArray 
		from: 1 to: decoded size)
			position: decoded position;
			yourself.
! !
!SecureSocketStream methodsFor: 'accessing' stamp: 'ar 7/25/2010 16:31' prior: 50888765!
           certState
	"Returns the certificate verification bits. The returned value indicates
	whether the certificate is valid. The two standard values are:

		0 - The certificate is valid.
		-1 - No certificate has been provided by the peer.

	Otherwise, the result is a bit mask of the following values:

		1 - If set, there is an unspecified issue with the cert (generic error)
		2 - If set, the root CA is untrusted (usually a self-signed cert)
		4 - If set, the certificate is expired.
		8 - If set, the certificate is used for the wrong purpose
		16 - If set, the CN of the certificate is invalid.
		32 - If set, the certificate was revoked.

	"

	^ssl ifNotNil:[ssl certState]! !
!SecureSocketStream methodsFor: 'accessing' stamp: 'ar 7/25/2010 16:31' prior: 50888789!
 ignoredCertIssues
	"Answer the mask of 'acceptable issues' with certs. To completely ignore all cert issues use -1 which still ensures privacy (encryption) to the remote host, but does not guard against a man-in-the-middle attack (i.e., you cannot be sure that the remote host is what he says he is). The reasons are a bit mask consisting of the following values:
		1 - If set, there is an unspecified issue with the cert (generic error)
		2 - If set, the root CA is untrusted (usually a self-signed cert)
		4 - If set, the certificate is expired.
		8 - If set, the certificate is used for the wrong purpose
		16 - If set, the CN of the certificate is invalid.
		32 - If set, the certificate was revoked.
	"

	^certIssues! !
!SecureSocketStream methodsFor: 'accessing' stamp: 'ar 7/25/2010 16:31' prior: 50888814!
                  ignoredCertIssues: reasonsMask
	"Set the mask of 'acceptable issues' with certs. To completely ignore all cert issues use -1 which still ensures privacy (encryption) to the remote host, but does not guard against a man-in-the-middle attack (i.e., you cannot be sure that the remote host is what he says he is). The reasons are a bit mask consisting of the following values:
		1 - If set, there is an unspecified issue with the cert (generic error)
		2 - If set, the root CA is untrusted (usually a self-signed cert)
		4 - If set, the certificate is expired.
		8 - If set, the certificate is used for the wrong purpose
		16 - If set, the CN of the certificate is invalid.
		32 - If set, the certificate was revoked.
	"

	certIssues := reasonsMask! !
!SecureSocketStream methodsFor: 'accessing' stamp: 'ar 7/25/2010 14:45' prior: 50888840!
                          peerName
	"Returns the certificate name of the remote peer.
	The method only returns a name if the certificate has been verified."

	^ssl ifNotNil:[ssl peerName]! !
!SecureSocketStream methodsFor: 'accessing' stamp: 'ar 7/25/2010 16:32' prior: 50888848!
  ssl
	"The SqueakSSL instance"

	^ssl! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 11/23/2010 15:03' prior: 50888853 overrides: 50886786!
     atEnd
	"Pre Squeak 4.2 compatibility"

	self receiveAvailableData.
	^super atEnd! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 7/25/2010 17:33' prior: 50888859 overrides: 50886905!
                          flush
	"Pre-Squeak 4.2 compatibility"

	((outNextToWrite > 1) and: [socket isOtherEndClosed not])
		ifTrue: [
			[self sendData: outBuffer count: outNextToWrite - 1]
				on: ConnectionTimedOut
				do: [:ex | shouldSignal ifFalse: ["swallow"]].
			outNextToWrite := 1]
! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 11/23/2010 15:03' prior: 50888871 overrides: 50886944!
                             isDataAvailable
	"Pre Squeak 4.2 compatibility"
 
	self isInBufferEmpty ifFalse: [^true].
	^self receiveAvailableData < inNextToWrite
! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 7/25/2010 17:35' prior: 50888879 overrides: 50887180!
    nextPutAllFlush: aCollection
	"Pre Squeak 4.2 compatibility"

	| toPut |
	toPut := binary ifTrue: [aCollection asByteArray] ifFalse: [aCollection asString].
	self flush. "first flush pending stuff, then directly send"
	socket isOtherEndClosed ifFalse: [
		[self sendData: toPut count: toPut size]
			on: ConnectionTimedOut
			do: [:ex | shouldSignal ifFalse: ["swallow"]]]
! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 7/25/2010 17:32' prior: 50888894 overrides: 50887313!
                     receiveAvailableData
	"Pre Squeak 4.2 compatibility"
	
	recentlyRead := self receiveDataInto: inBuffer startingAt: inNextToWrite.
	^self adjustInBuffer: recentlyRead
! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 11/23/2010 15:03' prior: 50888903 overrides: 50887331!
   receiveData: nBytes
	"Pre Squeak 4.2 compatibility"

	self receiveAvailableData.
	^super receiveData: nBytes.! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 7/25/2010 17:32' prior: 50888910 overrides: 50887355!
                             receiveDataIfAvailable
	"Pre Squeak 4.2 compatibility"

	^self receiveAvailableData
! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 11/23/2010 15:03' prior: 50888916 overrides: 50887571!
                     upToAll: aStringOrByteArray
	"Pre Squeak 4.2 compatibility"

	^self upToAll: aStringOrByteArray limit: 100000! !
!SecureSocketStream methodsFor: 'private-compat' stamp: 'ar 11/23/2010 15:03' prior: 50888923 overrides: 50887589!
                            upToAll: aStringOrByteArray limit: nBytes
	"Pre Squeak 4.2 compatibility"

	| index sz result searchedSoFar target |
	"Deal with ascii vs. binary"
	self isBinary
		ifTrue:[target := aStringOrByteArray asByteArray]
		ifFalse:[target := aStringOrByteArray asString].

	sz := target size.
	"Look in the current inBuffer first"
	index := inBuffer indexOfSubCollection: target
						startingAt: lastRead - sz + 2.
	(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"
		result := self nextInBuffer: index - lastRead - 1.
		self skip: sz.
		^ result
	].

	[searchedSoFar :=  self inBufferSize.
	"Receive more data"
	self receiveData.
	recentlyRead > 0] whileTrue:[

		"Data begins at lastRead + 1, we add searchedSoFar as offset and 
		backs up sz - 1 so that we can catch any borderline hits."

		index := inBuffer indexOfSubCollection: target
						startingAt: (lastRead + searchedSoFar - sz + 2 max: 1).
		(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"
			result := self nextInBuffer: index - lastRead - 1.
			self skip: sz.
			^ result
		].
		"Check if we've exceeded the max. amount"
		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 
			ifTrue:[^self nextAllInBuffer].
	].

	"not found and (non-signaling) connection was closed"
	^self nextAllInBuffer! !
!SecureSocketStream methodsFor: 'errors' stamp: 'ar 8/16/2011 10:21' prior: 50888966!
                     certError: errorString code: reason
	"Signal an issue with a certificate. If the reason code matches the acceptable cert issues, continue, otherwise signal an error."

	(certIssues allMask: reason) ifTrue:[^self].
	^SqueakSSLCertificateError signal: errorString, '(code: ', reason, ')'.
! !
!SecureSocketStream methodsFor: 'initialize' stamp: 'ar 7/25/2010 17:30' prior: 50888979 overrides: 50886867!
               close
	"Flush any data still not sent and take care of the socket."

	super close.
	ssl ifNotNil:[
		ssl destroy.
		ssl := nil.
	].! !
!SecureSocketStream methodsFor: 'initialize' stamp: 'ar 7/25/2010 17:34' prior: 50888987 overrides: 50886896!
           destroy
	"Destroy the receiver and its underlying socket. Does not attempt to flush the output buffers. For a graceful close use SocketStream>>close instead."

	"Pre-4.2 compatibility. Should be 'super destroy' instead of 'socket destroy'"
	socket ifNotNil:[
		socket destroy.
		socket := nil.
	].

	ssl ifNotNil:[
		ssl destroy.
		ssl := nil.
	].! !
!SecureSocketStream methodsFor: 'initialize' stamp: 'ar 7/25/2010 15:58' prior: 50889001 overrides: 50886930!
                   initialize
	"Initialize the receiver"
	
	"I think 16k is the max for SSL frames so use a tad more"
	decoded := ReadStream on: (ByteArray new: 20000) from: 1 to: 0.

	super initialize.

	sendBuf := ByteArray new: 4096.
	readBuf := ByteArray new: 4096.
	certIssues := 0.
! !
!SecureSocketStream methodsFor: 'initialize' stamp: 'ar 11/17/2011 17:10' prior: 50889012!
                    sslAccept: certName
	"Perform the SSL server handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete."

	| squeakSSL result inbuf |
	inbuf := ''.
	squeakSSL := SqueakSSL new.
	squeakSSL certName: certName.

	"Perform the server handshake"
	[[squeakSSL isConnected] whileFalse:[
		"Read input"
		self receiveData.
		inbuf := self nextAvailable.
		result := squeakSSL accept: inbuf from: 1 to: inbuf size into: sendBuf.

		"Check for errors first"
		result < -1 ifTrue:[^self error: 'SSL accept failed with code: ', result].

		"If a token has been produced in the handshake, send it to the remote"
		result > 0 ifTrue:[
			self nextPutAll: (sendBuf copyFrom: 1 to: result).
			self flush.
		].
	].
	"There should be no pending data at this point, ensure it is so.
	XXXX: If you ever see this problem, please inform me."
	self isInBufferEmpty ifFalse:[self error: 'Unexpected input data'].
	"We are connected. From here on, encryption will take place."
	ssl := squeakSSL.
	] ifCurtailed:[
		"Make sure we destroy the platform handle if the handshake gets interrupted"
		squeakSSL destroy.
	].
! !
!SecureSocketStream methodsFor: 'initialize' stamp: 'ul 10/15/2014 19:20' prior: 50889054!
              sslConnect
	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete."

	self sslConnectTo: nil! !
!SecureSocketStream methodsFor: 'initialize' stamp: 'jmv 6/26/2017 18:55:27' prior: 50889065!
                        sslConnectTo: serverName
	"Perform the SSL client handshake. This method uses all the common SocketStream methods to adhere to the various timeout/signalling settings of SocketStream. It only installs the SSL instance after the handshake is complete. If serverName is not nil, then try to use it for SNI."

	| inbuf squeakSSL result |
	inbuf := ''.
	squeakSSL := SqueakSSL new.
	serverName ifNotNil: [ squeakSSL serverName: serverName ].
	"Perform the SSL handshake"
	[[result := squeakSSL connect: inbuf from: 1 to: inbuf size into: sendBuf.
	result = 0] whileFalse:[
		"Check for errors first"
		result < -1 ifTrue:[^self error: 'SSL connect failed with code: ', result printString].

		"If a token has been produced in the handshake, send it to the remote"
		result > 0 ifTrue:[
			self nextPutAll: (sendBuf copyFrom: 1 to: result).
			self flush.
		].

		"Read more input and repeat"
		self receiveData.
		inbuf := self nextAvailable.
	].
	"There should be no pending data at this point, ensure it is so.
	XXXX: If you ever see this problem, please inform me."
	self isInBufferEmpty ifFalse:[self error: 'Unexpected input data'].
	"We are connected. From here on, encryption will take place."
	ssl := squeakSSL.
	] ifCurtailed:[
		"Make sure we destroy the platform handle if the handshake gets interrupted"
		squeakSSL destroy.
	].
! !
!SecureSocketStream methodsFor: 'initialize' stamp: 'ar 7/27/2010 21:09' prior: 50889110!
         verifyCert: hostName
	"Verifies the cert state and host name"

	| certFlags |
	certFlags := self certState.
	certFlags = -1 
		ifTrue:[^self certError: 'No certificate was provided' code: -1].
	certFlags = 0 
		ifFalse:[self certError: 'Invalid certificate' code: certFlags].
	(ssl peerName match: hostName) 
		ifFalse:[self certError: 'Host name mismatch' code: -1].! !
!SecureSocketStream methodsFor: 'private-socket' stamp: 'ar 11/15/2010 11:39' prior: 50889125 overrides: 50887327!
                          receiveData
	"This method drains the available decryption data before waiting for the socket"

	| pos |

	"Note: The loop here is necessary to catch cases where a TLS packet is
	split among TCP packets. In this case we would pull the first portion of
	the TLS packet here but receiveAvailableData would return nothing since
	the contents of the packet can't be decoded until the rest has come in."

	[pos := inNextToWrite.
	self receiveAvailableData.
	pos = inNextToWrite ifFalse:[^pos].

	"Pre-4.2 compatibility; should be 'super receiveData' instead."
	socket
		waitForDataFor: self timeout
		ifClosed: [self shouldSignal 
			ifTrue:[ConnectionClosed signal: 'Connection closed while waiting for data.']]
		ifTimedOut: [self shouldTimeout
			ifTrue:[ConnectionTimedOut signal: 'Data receive timed out.']].
	self isConnected] whileTrue.

	"Final attempt to read data if a non-signaling connection closes"
	^self receiveAvailableData.
! !
!SecureSocketStream methodsFor: 'private-socket' stamp: 'ar 11/17/2011 13:19' prior: 50889158 overrides: 50887361!
  receiveDataInto: buffer startingAt: index
	"Read and decrypt the data from the underlying socket. "

	| count bytesRead |
	"While in handshake, use the superclass version"
	ssl ifNil:[
		"Pre-4.2 compatibility; should be 'super receiveDataInto: buffer startingAt: index'"
		^socket  receiveAvailableDataInto: buffer startingAt: index.
	].

	"Only decode more data if all the decoded contents has been drained"
	decoded atEnd ifTrue:[
		"Decrypt more data if available"
		bytesRead := 0.
		[count := ssl decrypt: readBuf from: 1 to: bytesRead into: decoded originalContents.
		count < 0 ifTrue:[^self error: 'SSL error, code: ', count].
		bytesRead := 0.
		count = 0 ifTrue:[
			bytesRead := socket receiveAvailableDataInto: readBuf startingAt: 1.
		].
		bytesRead = 0] whileFalse.
		"Update for number of bytes decoded"
		decoded setFrom: 1 to: count.
	].

	"Push data from decoded into the result buffer"
	count := (decoded size - decoded position) min: (buffer size - index + 1).
	(decoded next: count into: buffer startingAt: index) size < count
		ifTrue:[^self error: 'Unexpected read failure'].
	^count
! !
!SecureSocketStream methodsFor: 'private-socket' stamp: 'ar 7/25/2010 17:37' prior: 50889196 overrides: 50887407!
                      sendData: buffer count: n
	"Encrypts the data before sending it on the underlying socket.
	Breaks large chunks into 2k components to fit safely into ssl frame."

	| remain start amount count |
	"While in handshake, use the superclass version"
	ssl ifNil:[
		"Pre-4.2 compatibility; should be 'super sendData: buffer count: n' instead"
		^socket sendData: buffer count: n
	].

	"Break the input into reasonable chunks and send them"
	remain := n. start := 1.
	[remain > 0] whileTrue:[
		amount := remain min: 2048.
		count := ssl encrypt: buffer from: start to: start+amount-1 into: sendBuf.
		socket sendData: sendBuf count: count.
		remain := remain - amount.
		start := start + amount.
	].! !
!WebClient methodsFor: 'cookies' stamp: 'ar 8/12/2010 21:40' prior: 50889220!
                           acceptCookie: aCookie host: reqHost path: path
	"Accept a cookie from a prior response"

	self acceptCookies ifTrue:[
		"Set the defaults per RFC 2109 section 4.3.1 "
	
		"Ensure the cookie domain is set"
		aCookie domain ifNil:[aCookie domain: reqHost].

		"Ensure the cookie path is set"
		aCookie path ifNil:[aCookie path: path].

		"Reject the cookie per RFC 2109 section 4.3.2"
		(path beginsWith: aCookie path) ifFalse:[^false].

		aCookie domain = reqHost ifFalse:[ | domain |
			domain := aCookie domain.
			"For misconfigured servers, insert the leading dot into the domain"
			domain first = $. ifFalse:[aCookie domain: (domain := '.', domain)].
			((domain count:[:ch| ch = $.]) >= 2) ifFalse:[^false].
			(reqHost endsWith: domain) ifFalse:[^false].
			((reqHost allButLast: domain size) includes: $.) ifTrue:[^false].
		].
	
		"Remove any old cookies"
		cookies := cookies reject:[:any| any = aCookie].
		
		"Remember the cookie if not expired"
		(aCookie expiry == nil or:[aCookie expiry > DateAndTime now])  ifTrue:[
			cookies add: aCookie.
			^true
		].
	].
	^false! !
!WebClient methodsFor: 'cookies' stamp: 'ar 4/1/2010 18:04' prior: 50889256!
                     acceptCookies
	"Whether we should accept cookies"

	^flags anyMask: FlagAcceptCookies! !
!WebClient methodsFor: 'cookies' stamp: 'ar 4/1/2010 18:05' prior: 50889261!
                          acceptCookies: aBool
	"Whether we should accept cookies"

	flags := aBool ifTrue:[flags bitOr: FlagAcceptCookies] ifFalse:[flags bitClear: FlagAcceptCookies].
! !
!WebClient methodsFor: 'accessing' stamp: 'ar 7/28/2010 20:49' prior: 50889269!
             accessLog
	"The standard access log. Can be either a stream or a string; if the access log
	is a string then the string is assumed to be a file name and the file will be opened 
	and closed for each request."

	^accessLog! !
!WebClient methodsFor: 'accessing' stamp: 'ar 7/28/2010 20:49' prior: 50889279!
               accessLog: aStreamOrFilename
	"The standard access log. Can be either a stream or a string; if the access log
	is a string then the string is assumed to be a file name and the file will be opened 
	and closed for each request."

	accessLog := aStreamOrFilename! !
!WebClient methodsFor: 'accessing' stamp: 'ar 4/1/2010 18:03' prior: 50889290!
         allowAuth
	"If true, WebClient will attempt to handle authorization requests"

	^flags anyMask: FlagAllowAuth! !
!WebClient methodsFor: 'accessing' stamp: 'ar 4/1/2010 18:02' prior: 50889296!
allowAuth: aBool
	"If true, WebClient will attempt to handle authorization requests"

	flags := aBool ifTrue:[flags bitOr: FlagAllowAuth] ifFalse:[flags bitClear: FlagAllowAuth].
! !
!WebClient methodsFor: 'accessing' stamp: 'ar 4/1/2010 18:01' prior: 50889304!
                          allowRedirect
	"If true, WebClient will attempt to handle redirect responses"

	^flags anyMask: FlagAllowRedirect! !
!WebClient methodsFor: 'accessing' stamp: 'ar 4/1/2010 18:02' prior: 50889310!
                            allowRedirect: aBool
	"If true, WebClient will attempt to handle redirect responses"

	flags := aBool ifTrue:[flags bitOr: FlagAllowRedirect] ifFalse:[flags bitClear: FlagAllowRedirect].
! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/10/2012 13:13' prior: 50889318!
                 authParams
	"The authentication parameters"

	^authParams! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/10/2012 13:13' prior: 50889322!
                   authParams: aDictionary
	"The authentication parameters"

	authParams := aDictionary! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/23/2010 10:31' prior: 50889327!
                        cookies
	"The cookies that have been set for this session"

	^cookies! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/23/2010 10:31' prior: 50889332!
       cookies: aCollection
	"The cookies that have been set for this session"

	cookies := aCollection.! !
!WebClient methodsFor: 'accessing' stamp: 'ar 8/12/2010 21:16' prior: 50889338!
           debugLog
	"If provided, WebClient will print all requests and responses to the debugLog,
	except from the content of the message. The debug log must be a stream of
	some sort; file names (like for the accessLog are not supported)."

	^debugLog! !
!WebClient methodsFor: 'accessing' stamp: 'ar 8/12/2010 21:17' prior: 50889348!
                         debugLog: aStream
	"If provided, WebClient will print all requests and responses to the debugLog,
	except from the content of the message. The debug log must be a stream of
	some sort; file names (like for the accessLog are not supported)."

	debugLog := aStream! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:12' prior: 50889359!
      maxRedirect
	"The max. number of redirects we allow for the SAME SITE before giving up.
	Redirects can happen for any number of reasons between any number of sites
	and we give up if we have seen the SAME SITE maxRedirect number of times."

	^maxRedirect! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:12' prior: 50889370!
              maxRedirect: aNumber
	"The max. number of redirects we allow for the SAME SITE before giving up.
	Redirects can happen for any number of reasons between any number of sites
	and we give up if we have seen the SAME SITE maxRedirect number of times."

	maxRedirect := aNumber! !
!WebClient methodsFor: 'accessing' stamp: 'ar 3/27/2010 12:01' prior: 50889381!
                           password
	"The password for remote authentication.
	The password should generally not be a plain-text
	version but rather a block that can retrieve the password
	when required."

	^authParams at: #password ifAbsent:[nil]! !
!WebClient methodsFor: 'accessing' stamp: 'ar 3/27/2010 01:32' prior: 50889390!
                password: aStringOrValuable
	"The password for remote authentication.
	The password should generally not be a plain-text
	version but rather a block that can retrieve the password
	when required."

	^authParams at: #password put: aStringOrValuable! !
!WebClient methodsFor: 'accessing' stamp: 'ar 8/5/2010 19:50' prior: 50889400!
                      scheme
	"The scheme used for the request (usually http or https)"

	^scheme! !
!WebClient methodsFor: 'accessing' stamp: 'ar 8/5/2010 19:50' prior: 50889405!
  scheme: aString
	"The scheme used for the request (usually http or https)"

	scheme := aString! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/21/2010 09:50' prior: 50889411!
              server
	"The server to use for connections.
	The server is specified as server:port if needed"

	^server! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/21/2010 09:50' prior: 50889417!
    server: aString
	"The server to use for connections.
	The server should be specified as server:port if needed"

	server := aString
! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/20/2010 19:22' prior: 50889424!
         serverName
	"Returns the name part of the server:port description"

	^server copyUpTo: $:! !
!WebClient methodsFor: 'accessing' stamp: 'NR 6/23/2021 07:02:22' prior: 50889429!
                serverPort
	"Returns the port of the server:port description"

	^(server copyAfter: $:) 
		ifEmpty:[self defaultPort]
		ifNotEmpty:[:portString| portString asNumber].
! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:12' prior: 50889437!
     timeout
	"Timeout for the http operations"

	^timeout! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:12' prior: 50889441!
                       timeout: aNumber
	"Timeout for the http operations"

	timeout := aNumber! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:16' prior: 50889446!
    userAgent
	"The User-Agent string sent to the server"

	^userAgent! !
!WebClient methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:17' prior: 50889451!
          userAgent: aString
	"The User-Agent string sent to the server. 
	If no user agent should be sent, this value can be set to nil"

	userAgent := aString! !
!WebClient methodsFor: 'accessing' stamp: 'ar 3/24/2010 16:05' prior: 50889458!
                      username
	"The username for remote authentication"

	^authParams at: #username ifAbsent:[nil]! !
!WebClient methodsFor: 'accessing' stamp: 'ar 3/24/2010 16:05' prior: 50889464!
               username: aString
	"The username for remote authentication"

	authParams at: #username put: aString! !
!WebClient methodsFor: 'authentication' stamp: 'ar 3/30/2010 20:45' prior: 50889470!
    authDispatch: request from: response header: authHeader params: params
	"Dispatch on an authentication method. 
	Subclasses can extend this method to support more auth methods."

	(authHeader copyUpTo: Character space) caseOf: {
		['Basic'] -> [self basicAuth: request from: response 
							header: authHeader params: params].
		['Digest'] -> [self digestAuth: request from: response 
							header: authHeader  params: params].
	} otherwise:["ignore"].
! !
!WebClient methodsFor: 'authentication' stamp: 'jmv 6/25/2017 20:43:27' prior: 50889487!
                            basicAuth: request from: response header: header params: params
	"Provide basic authentication for the request"

	| user pass args |
	authParams at: #authMethod ifPresent:[:method| ^self]. "do not retry repeatedly"
	authParams at: #authMethod put: 'Basic'.

	args := WebUtils parseAuthParams: header.
	args at: 'realm' ifPresent:[:realm| authParams at: #authRealm put: realm].
	
	user := (params at: #username ifAbsent:[nil]) ifNil:[^self].
	pass := (params at: #password ifAbsent:[nil]) ifNil:[^self].
	authParams at: #authResponse put: (user, ':', pass value) asUtf8 base64Encoded! !
!WebClient methodsFor: 'authentication' stamp: 'ar 8/26/2010 07:48' prior: 50889508!
 digestAuth: request from: response header: authHeader params: params
	"Perform digest authentication"

	| realm nonce ha1 ha2 nc cnonce qop header uri md5 key args user pass |
	params at: #authMethod ifPresent:[:method| ^self]. "do not retry repeatedly"
	params at: #authMethod put: 'Digest'.

	args := WebUtils parseAuthParams: authHeader.
	realm := args at: 'realm'.
	authParams at: #authRealm put: realm.

	user := (params at: #username ifAbsent:[nil]) ifNil:[^self].
	pass := (params at: #password ifAbsent:[nil]) ifNil:[^self].

	nonce := args at: 'nonce'.
	uri := request rawUrl.

	"VERY IMPORTANT NOTE: Some servers fail horribly if the nonce count
	isn't precisely eight digits and without quotes."
	nc := args at: 'nc' put: (args at: 'nc' ifAbsent:[0]) + 1.
	nc := nc asString padded: #left to: 8 with: $0.
	
	key := user, ':', realm, ':', pass value.
	ha1 := WebUtils md5Digest: key.
	ha2 := WebUtils md5Digest: request method, ':', uri.
	cnonce := UUID new hex.

	(args includesKey: 'qop') ifTrue:["use qop"
		qop := 'auth'. "the only qop we support"
		md5 := WebUtils md5Digest: ha1, ':', nonce, ':', nc, ':', cnonce, ':', qop, ':', ha2.
		header :=
			'username="', user, '"',
			', realm="', realm, '"',
			', nonce="', nonce, '"',
			', uri="', uri, '"',
			', response="', md5, '"',
			', qop="', qop,'"',
			', nc="', nc, '"',
			', cnonce="', cnonce, '"'.
	] ifFalse:["ignore qop"
		md5 := WebUtils md5Digest: ha1, ':', nonce, ':', ha2.
		header :=
			'username="', user, '"',
			', realm="', realm, '"',
			', nonce="', nonce, '"',
			', uri="', uri, '"',
			', response="', md5, '"'.
	].
	args at: 'opaque' ifPresent: [:opaque | 
		header := header, ', opaque="', opaque, '"'
	].
	params at: #authResponse put: header.! !
!WebClient methodsFor: 'authentication' stamp: 'ar 3/30/2010 20:46' prior: 50889565!
                             flushAuthState: params
	"Fliush authentication state that should not been preserved 
	inbetween failed attempts to authenticate. 
	Subclasses can extend this method to support more auth methods."

	params removeKey: #authMethod ifAbsent:[].
! !
!WebClient methodsFor: 'sending' stamp: 'ar 2/10/2012 13:12' prior: 50889575!
                             authenticate: request from: response
	"Authenticate after having received a 401/407 response.
	Returns true if we should retry, false if we fail here."

	"NOTE: The first time through we do NOT ask for credentials right away.
	Some authentication mechanisms (NTLM/Negotiate) can use the credentials
	of the currently logged on user. Consequently we only ask for credentials
	if we're unable to do so without asking. Methods that require credentials
	(basic, digest) test for their existence explicitly."

	| headers authHeader params |

	"Pick the right set of parameters"
	response code = 401 ifTrue:[
		params := authParams.
		headers := response headersAt: 'WWW-Authenticate'.
		"If the connection was closed, we need to flush the
		proxy params or we won't pick up prior credentials."
		self isConnected 
			ifFalse:[self flushAuthState: proxyParams].
	] ifFalse:[
		params := proxyParams.
		headers := response headersAt: 'Proxy-Authenticate'.
	].

	"Remove any old response"
	params removeKey: #authResponse ifAbsent:[].

	"Process the authentication header(s)"
	1 to: headers size do:[:i|
		authHeader := headers at: i.
		self authDispatch: request from: response header: authHeader params: params.
		"If we generated an authentication response for the header use it"
		params at: #authResponse ifPresent:[:resp|
			request headerAt: (response code = 401 
								ifTrue:['Authorization'] 
								ifFalse:['Proxy-Authorization'])
					put: (params at: #authMethod), ' ', resp.
			^true].
	].

	"If we fall through here this can have two reasons: One is that we don't have
	a suitable authentication method. Check for that first."
	params at: #authMethod ifAbsent:[^false].

	"The other possibility is that the credentials are wrong. 
	Clean out the previous auth state and go ask for credentials."
	self flushAuthState: params.

	"Clean out old authentication headers"
	response code = 401 
		ifTrue:[request removeHeader: 'Authorization'].
	"Always clean out the proxy auth header since we don't support pre-authentication"
	request removeHeader: 'Proxy-Authorization'.

	"Signal WebAuthRequired"
	(WebAuthRequired client: self request: request response: response)
		signal == true ifFalse:[^false].

	"And retry with the new credentials"
	^self authenticate: request from: response! !
!WebClient methodsFor: 'sending' stamp: 'ar 9/4/2010 11:10' prior: 50889649!
                            redirect: request from: response
	"Handle a 3xx redirect response"

	| location max |
	
	"Check if we handle the specific type of redirect here"
	(#(	301 
		302 "Found" 
		303 "See Other" 
		307 "Temporary Redirect")
			includes: response code) ifFalse:[^false].

	"RFC 2616 states that requests other than HEAD and GET MUST NOT be auto
	redirected for 302 and 307 responses"
	(request method = 'GET' or:[request method = 'HEAD']) ifFalse:[
		(response code = 302 or:[response code = 307]) ifTrue:[^false].
	].

	"Find the new location"
	location := response headerAt: 'location'.

	"Check if we've exceeded max redirections"
	max := redirections at: location ifAbsent:[0].
	max > self maxRedirect ifTrue:[^false].
	redirections at: location put: max+1.

	"Do the actual redirect, i.e., set us up for the new url"
	(location findString: '://') > 0 "do we have a scheme:// url?"
		ifTrue:[self initializeFromUrl: location].

	request initializeFromUrl: location.

	^true! !
!WebClient methodsFor: 'sending' stamp: 'ar 2/25/2010 22:16' prior: 50889682!
     sendRequest: request
	"Send an http request"

	^self sendRequest: request content: nil size: 0! !
!WebClient methodsFor: 'sending' stamp: 'DSG 5/25/2012 23:35' prior: 50889688!
               sendRequest: request content: contentStream size: streamSize
	"Send an http request"

	^self sendRequest: request contentBlock:[:aStream|
		contentStream ifNotNil:[
			"Upload content if provided"
			contentStream position: 0.
			request streamFrom: contentStream to: aStream size: streamSize 
				progress:[:total :amount|
					(ProgressBarMorph new) 
						progressValue: amount / total.
						]]].
! !
!WebClient methodsFor: 'sending' stamp: 'CK 11/24/2017 14:32:10' prior: 50889703!
                         sendRequest: request contentBlock: contentBlock
	"Send an http request"

	|  response repeatRedirect repeatAuth |

	"XXXX: Fixme. Pre-authenticate the request if we have valid auth credentials"

	redirections := Dictionary new.

	["The outer loop handles redirections"
	repeatRedirect := false.

	"Always update the host header due to redirect"
	request headerAt: 'Host' put: server.

		["The inner loop handles authentication"
		repeatAuth := false.

		"Connect can fail if SSL proxy CONNECT is involved"
		self connect ifNotNil:[:resp| ^resp].
		
		"Write the request to the debugLog if present"
		debugLog ifNotNil:[self writeRequest: request on: debugLog].

		"Send the request itself"
		self writeRequest: request on: stream.
		contentBlock value: stream.

		response := request newResponse readFrom: stream.
		response url: (scheme, '://', server, request rawUrl).

		debugLog ifNotNil:[
			response writeOn: debugLog.
			debugLog flush.
		].
		response setCookiesDo:[:cookie| 
			self acceptCookie: cookie host: self serverName path: request url.
		].
		accessLog ifNotNil:[
			WebUtils logRequest: request response: response on: accessLog
		].
		"Handle authentication if needed"
		(self allowAuth and:[response code = 401 or:[response code = 407]]) ifTrue:[
			"Eat up the content of the previous response"
			response content.
			repeatAuth := self authenticate: request from: response.
		].

		repeatAuth] whileTrue.

	"Flush previous authState.
	XXXX: Fixme. authState must be preserved for pre-authentication of requests."
	self flushAuthState.

	"Handle redirect if needed"
	(self allowRedirect and:[response isRedirect]) ifTrue:[
		"Eat up the content of the previous response"
		response content.
		repeatRedirect := self redirect: request from: response.
	].
	repeatRedirect] whileTrue:[
		"When redirecting, remove authentication headers"
		request removeHeader: 'Authorization'.
		request removeHeader: 'Proxy-Authorization'.
	].

	"If the response is not a success, eat up its content"
	(response isSuccess or:[response isInformational]) ifFalse:[response content].

	^response! !
!WebClient methodsFor: 'sending' stamp: 'ar 8/12/2010 21:37' prior: 50889771!
                             writeCookiesFor: request on: aStream
	"Write the cookies for a particular request"

	(cookies select:[:ck| (request acceptsCookie: ck from: self )]) ifNotEmpty:[:ckset|
		aStream nextPutAll: 'Cookie: '.
		ckset 
			do:[:ck| aStream nextPutAll: ck name,'=', ck value]
			separatedBy:[aStream  nextPutAll:'; '].
		aStream crlf.
	].
! !
!WebClient methodsFor: 'sending' stamp: 'DSG 5/24/2012 17:24' prior: 50889784!
   writeHeadersFor: request on: aStream
	"Write all the headers for the given request on aStream"

	request headersDo:[:key :value| aStream nextPutAll: key, ': ', value asString; nextPutAll: String crlfString].
! !
!WebClient methodsFor: 'sending' stamp: 'CK 11/24/2017 14:43:55' prior: 50889793!
                          writeRequest: request on: aStream
	"Write all the request headers on the given stream"

	self retryOnce: [
		self writeRequestLine: request on: aStream.
		self writeHeadersFor: request on: aStream.
		self writeCookiesFor: request on: aStream.
		aStream crlf.
		aStream flush].! !
!WebClient methodsFor: 'sending' stamp: 'CK 11/24/2017 14:37:08' prior: 50889804!
                      writeRequestLine: request on: aStream
	"Write the HTTP request line on the given stream"

	aStream nextPutAll: request method; space.

	"https proxy support is transparent via CONNECT"
	(proxyServer notNil and:[scheme ~= 'https']) ifTrue:[
		"http://www.ietf.org/rfc/rfc2616.txt 
		5.1.2 Request-URI:
			...
		The absoluteURI form is REQUIRED when the request is being made to a
		proxy. The proxy is requested to forward the request or service it
		from a valid cache, and return the response. Note that the proxy MAY
		forward the request on to another proxy or directly to the server"
		aStream nextPutAll: scheme, '://', self server.

		"XXXX: This is a hack. Indicate that we want the proxy connection 
		to be persistent. This should NOT be necessary; the proxy should
		know that from the HTTP/1.1 request but apparently, squid will fail 
		NTLM and Negotiate authentication unless explicitly instructed to 
		keep the proxy connection alive."
		request headerAt: 'Proxy-Connection' put: 'keep-alive'.
	].

	aStream nextPutAll: request rawUrl; space; nextPutAll: request protocol; nextPutAll: String crlfString.! !
!WebClient methodsFor: 'initialize' stamp: 'topa 6/17/2016 20:59' prior: 50889842!
           close
	"Close the client's stream"

	stream ifNotNil:[
		stream isConnected ifTrue: [stream close].
		stream := nil].
! !
!WebClient methodsFor: 'initialize' stamp: 'CK 11/24/2017 14:24:01' prior: 50889848!
                 connect
	"Connect the client to a web server. Returns nil if successful,
	a WebResponse if a proxy CONNECT request fails."

	| actualServer actualPort |

	"Determine which server to connect to (proxy or real)"
	proxyServer ifNil:[
		actualServer := self serverName.
		actualPort := self serverPort.
	] ifNotNil:[
		actualServer := self proxyServerName.
		actualPort := self proxyServerPort.
	].

	"Check if we can use the same stream or if we need to reconnect"
	(stream notNil
		and:[stream isConnected
		and:[lastServer = actualServer
		and:[lastPort = actualPort
		and:[lastScheme = scheme]]]]) ifTrue:[^nil].

	self close.
	lastServer := actualServer.
	lastPort := actualPort.
	lastScheme := scheme.
	stream := SocketStream openConnectionToHostNamed: lastServer port: lastPort.
	stream timeout: timeout.
	"Perform ssl initialization if necessary"
	scheme = 'https' ifTrue:[self retryOnce: [^self sslConnect]].
	^nil! !
!WebClient methodsFor: 'initialize' stamp: 'ar 7/21/2010 21:12' prior: 50889879!
                    defaultPort
	"Return the default port to use if no port was specified.
	Since we only support https and http, default to port 80 unless https."

	^scheme = 'https' 
		ifTrue:[443]
		ifFalse:[80]! !
!WebClient methodsFor: 'initialize' stamp: 'ar 2/12/2012 21:03' prior: 50889888!
         defaultUserAgent
	"Answer the default User-Agent string to use for WebClient"

	^'WebClient/1.5 (', 
		WebUtils mcVersion, '; ', 
		SystemVersion current version,'-', 
		SystemVersion current highestUpdate printString, '; ', 
		WebUtils platformName,')'.
! !
!WebClient methodsFor: 'initialize' stamp: 'ul 7/28/2016 18:09' prior: 50889899!
            destroy
	"Destroys the client"

	stream ifNotNil:[
		stream destroy.
		stream := nil.
	].
! !
!WebClient methodsFor: 'initialize' stamp: 'ar 3/27/2010 11:59' prior: 50889904!
                 detectProxyServer
	"Automatically detect the proxy server to use"

	proxyServer := ProxyHandler proxyServerFor: self server.
! !
!WebClient methodsFor: 'initialize' stamp: 'ar 4/1/2010 18:51' prior: 50889911!
               flushAuthState
	"Flush all the auth state"

	self flushAuthState: authParams.
	self flushAuthState: proxyParams.! !
!WebClient methodsFor: 'initialize' stamp: 'ar 2/10/2012 13:33' prior: 50889918 overrides: 16896425!
       initialize
	"Initializes the receiver"
	flags := 0.
	super initialize.

	self allowAuth: true.
	self allowRedirect: true.
	self acceptCookies: true.

	timeout := Socket standardTimeout.
	cookies := OrderedCollection new.
	redirections := Dictionary new.
	maxRedirect := 10.
	userAgent := self defaultUserAgent.
	authParams := IdentityDictionary new.
	proxyParams := IdentityDictionary new.

	"Use the default debug log"
	debugLog := DebugLog.
! !
!WebClient methodsFor: 'initialize' stamp: 'ar 7/25/2010 15:36' prior: 50889934!
                initializeFromUrl: urlString
	"Initialize the client from a url string"

	| urlStream serverAndPort userAndPass |
	urlStream := urlString readStream.
	scheme := (urlStream upToAll: '://') asLowercase.
	(scheme = 'http' or:[scheme = 'https'])
		ifFalse:[self error: 'Unsupported scheme: ', scheme].
	serverAndPort := urlStream upTo: $/.

	userAndPass := serverAndPort copyUpTo: $@.
	userAndPass = serverAndPort ifFalse:[
		serverAndPort := serverAndPort copyAfter: $@.
		self username: (userAndPass copyUpTo: $:).
		self password: (userAndPass copyAfter: $:).
	].

	self server: serverAndPort.
	self detectProxyServer.! !
!WebClient methodsFor: 'initialize' stamp: 'ar 8/9/2010 08:30' prior: 50889956!
   newRequest
	"Create an return a new WebRequest.
	Subclasses can use this method to override the default request class."

	^WebRequest new! !
!WebClient methodsFor: 'initialize' stamp: 'CK 11/24/2017 14:59:44' prior: 50889963!
                              proxyConnect
	"Send a proxy CONNECT request to connect to a remote host via the chosen proxy server"

	| uri request repeatAuth response |
	uri := self serverName,':', self serverPort asString.
	request := self newRequest.
	request method: 'CONNECT'.
	request rawUrl: uri.

	[repeatAuth := false.

	"The proxy response may use Connection: Close; reconnect when that happens"
	self isConnected ifFalse:[
		stream := SocketStream openConnectionToHostNamed: lastServer port: lastPort.
		stream timeout: timeout.
	].

	debugLog ifNotNil:[
		request writeOn: debugLog.
		debugLog flush.
	].

	"Don't use 'self writeRequestOn:' since this will insert both cookies
	as well as modify the url target when a proxy is present"
	request writeOn: stream.
	
	stream flush.

	response := request newResponse readFrom: stream.

	debugLog ifNotNil:[
		response writeOn: debugLog.
		debugLog flush.
	].

	"Handle authentication if needed"
	(self allowAuth and:[response code = 407]) ifTrue:[
		"Eat up the content of the previous response"
		response content.
		repeatAuth := self authenticate: request from: response.
	].
	repeatAuth] whileTrue.

	^response! !
!WebClient methodsFor: 'initialize' stamp: 'ar 9/4/2010 11:10' prior: 50890001!
                       requestWithUrl: urlString
	"Create and return a new WebRequest initialized with the given url."

	^self  newRequest initializeFromUrl: urlString! !
!WebClient methodsFor: 'initialize' stamp: 'topa 11/4/2014 00:13' prior: 50890008!
                         retryOnce: aTryBlock
	" Retry the block once if it failes,
	except for direct network errors.
	This can help in cases like temporary failing
	SqueakSSL primitives"
	| again |
	again := true.
	[^ aTryBlock value.
	] on: Error do: [:e |
		((e isKindOf: NetworkError) or: [again not])
			ifTrue: [e pass]
			ifFalse: [again := false. e retry]].! !
!WebClient methodsFor: 'initialize' stamp: 'CK 11/24/2017 14:25:04' prior: 50890021!
                  sslConnect
	"Do the SSL handshake"
	"Connect the client to a web server"

	| sqSSL |
	proxyServer ifNotNil:[ | resp |
		"If we have a proxy server, do the proxy connect"
		resp := self proxyConnect.
		resp isSuccess ifFalse:[^resp].
	].

	sqSSL := Smalltalk at: #SqueakSSL ifAbsent:[self error: 'SqueakSSL is missing'].
	"Convert the stream to a secure stream"
	stream := sqSSL secureSocketStream on: stream socket.
	stream timeout: timeout.
	self sslConnect: stream to: lastServer.
	"And cert verification
	(unless on OSX, where this does not work yet)"
	WebUtils platformName = 'Mac OS'
		ifFalse: [stream verifyCert: self serverName].
	^ nil"indicating success"
! !
!WebClient methodsFor: 'initialize' stamp: 'jmv 3/18/2019 13:15:39' prior: 50890045!
              sslConnect: aStream to: aLastServer
	"Do the SSL handshake, use SNI if available"
	(aStream respondsTo: #sslConnectTo:)
		ifTrue: [aStream sslConnectTo: aLastServer]
		ifFalse: [aStream sslConnect].! !
!WebClient methodsFor: 'methods' stamp: 'ar 5/11/2010 20:04' prior: 50890054!
        httpDelete: urlString
	"Sends an DELETE request"

	^self httpDelete: urlString do:[:req]
! !
!WebClient methodsFor: 'methods' stamp: 'ar 9/4/2010 11:06' prior: 50890059!
                      httpDelete: urlString do: aBlock
	"Sends a DELETE request"

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'DELETE'.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	aBlock value: request.
	^self sendRequest: request.! !
!WebClient methodsFor: 'methods' stamp: 'ar 2/23/2010 08:57' prior: 50890071!
 httpGet: urlString
	"GET the response from the given url"
	"(WebClient httpGet: 'http://www.squeak.org') content"

	^self httpGet: urlString do:[:req]
! !
!WebClient methodsFor: 'methods' stamp: 'CK 11/24/2017 14:46:24' prior: 50890078!
                   httpGet: urlString do: aBlock
	"GET the response from the given url
	(WebClient httpGet: 'http://www.cuis-smalltalk.org/') content
	"

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'GET'.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	request headerAt: 'Accept-Encoding' put: 'gzip'.
	aBlock value: request.
	^self sendRequest: request
! !
!WebClient methodsFor: 'methods' stamp: 'ar 5/11/2010 20:05' prior: 50890094!
       httpHead: urlString
	"Sends a HEAD request"

	^self httpHead: urlString do:[:req]
! !
!WebClient methodsFor: 'methods' stamp: 'ar 9/4/2010 11:06' prior: 50890099!
                             httpHead: urlString do: aBlock
	"Sends a HEAD request"

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'HEAD'.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	aBlock value: request.
	^self sendRequest: request.! !
!WebClient methodsFor: 'methods' stamp: 'ar 5/11/2010 20:05' prior: 50890111!
       httpOptions: urlString
	"Sends an OPTIONS request"

	^self httpOptions: urlString do:[:req]
! !
!WebClient methodsFor: 'methods' stamp: 'ar 9/4/2010 11:06' prior: 50890116!
                   httpOptions: urlString do: aBlock
	"Sends an OPTIONS request"

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'OPTIONS'.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	aBlock value: request.
	^self sendRequest: request
! !
!WebClient methodsFor: 'methods' stamp: 'ar 2/23/2010 08:56' prior: 50890128!
                             httpPost: urlString content: postData type: contentType
	"POST the data to the given url"

	^self httpPost: urlString content: postData type: contentType do:[:req]! !
!WebClient methodsFor: 'methods' stamp: 'ar 9/4/2010 11:07' prior: 50890136!
            httpPost: urlString content: postData type: contentType do: aBlock
	"POST the data to the given url"

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'POST'.
	contentType ifNotNil:[request headerAt: 'Content-Type' put: contentType].
	request headerAt: 'Content-Length' put: postData size.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	aBlock value: request.
	^self sendRequest: request content: postData readStream size: postData size! !
!WebClient methodsFor: 'methods' stamp: 'ar 8/31/2010 22:54' prior: 50890155!
      httpPostChunked: urlString content: chunkBlock type: contentType
	"POST the data to the given url using chunked transfer-encoding.
	The chunkBlock takes a request and can be fed using #nextChunkPut:
	until all the data has been sent.

	Chunked encoding can be used for long-lasting connections to a server,
	but care must be taken to ensure that the client isn't running afoul of
	the server expecting to read the full response (i.e., you should use this
	only if you have control over both ends).

	However, it is a great way to send output from commands that take awhile
	and other time-consuming operations if authentication has been handled."

	^self httpPostChunked: urlString content: chunkBlock type: contentType do: [:req]! !
!WebClient methodsFor: 'methods' stamp: 'ar 9/4/2010 11:07' prior: 50890180!
                     httpPostChunked: urlString content: chunkBlock type: contentType do: aBlock
	"POST the data to the given url using chunked transfer-encoding. 
	The chunkBlock takes a request and can be fed using #nextChunkPut:
	until all the data has been sent. 

	Chunked encoding can be used for long-lasting connections to a server,
	but care must be taken to ensure that the client isn't running afoul of
	the server expecting to read the full response (i.e., you should use this
	only if you have control over both ends).

	However, it is a great way to send output from commands that take awhile
	and other time-consuming operations if authentication has been handled."

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'POST'.
	contentType ifNotNil:[request headerAt: 'Content-Type' put: contentType].
	request headerAt: 'Transfer-Encoding' put: 'chunked'.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	aBlock value: request.
	"Send the chunked data"
	^self sendRequest: request contentBlock:[:aStream| 
		"Set the stream in the request and pass it in the chunk block"
		request stream: aStream.
		chunkBlock value: request.
		"send termination chunk"
		aStream nextPutAll: '0'; crlf; crlf; flush.
	].
! !
!WebClient methodsFor: 'methods' stamp: 'ar 2/23/2010 08:57' prior: 50890222!
                httpPut: urlString content: postData type: contentType
	"PUT the data to the given url"

	^self httpPut: urlString content: postData type: contentType do:[:req]! !
!WebClient methodsFor: 'methods' stamp: 'ar 9/4/2010 11:07' prior: 50890230!
               httpPut: urlString content: postData type: contentType do: aBlock
	"PUT the data to the given url"

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'PUT'.
	contentType ifNotNil:[request headerAt: 'Content-Type' put: contentType].
	request headerAt: 'Content-Length' put: postData size.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	aBlock value: request.
	^self sendRequest: request content: postData readStream size: postData size! !
!WebClient methodsFor: 'methods' stamp: 'ar 5/11/2010 20:05' prior: 50890249!
         httpTrace: urlString
	"Sends a TRACE request"

	^self httpTrace: urlString do:[:req]
! !
!WebClient methodsFor: 'methods' stamp: 'ar 9/4/2010 11:08' prior: 50890254!
                          httpTrace: urlString do: aBlock
	"Sends a TRACE request"

	| request |
	self initializeFromUrl: urlString.
	request := self requestWithUrl: urlString.
	request method: 'TRACE'.
	userAgent ifNotNil:[request headerAt: 'User-Agent' put: userAgent].
	aBlock value: request.
	^self sendRequest: request
! !
!WebClient methodsFor: 'testing' stamp: 'ar 3/30/2010 19:18' prior: 50890266!
    isConnected
	"Returns true if the client is still connected"

	^stream notNil and:[stream isConnected]! !
!WebClient methodsFor: 'proxy' stamp: 'ar 2/10/2012 13:12' prior: 50890272!
          proxyParams
	"The proxy authentication parameters"

	^proxyParams! !
!WebClient methodsFor: 'proxy' stamp: 'ar 2/10/2012 13:12' prior: 50890277!
               proxyParams: aDictionary
	"The proxy authentication parameters"

	proxyParams := aDictionary! !
!WebClient methodsFor: 'proxy' stamp: 'ar 3/24/2010 16:04' prior: 50890282!
                    proxyPass
	"The password for an authenticating proxy.
	The password should generally not be a plain-text
	version but rather a block that can retrieve the password
	when required."

	^proxyParams at: #password! !
!WebClient methodsFor: 'proxy' stamp: 'ar 3/24/2010 16:04' prior: 50890291!
                               proxyPass: aStringOrValuable
	"The password for an authenticating proxy.
	The password should generally not be a plain-text
	version but rather a block that can retrieve the password
	when required."

	proxyParams at: #password put: aStringOrValuable! !
!WebClient methodsFor: 'proxy' stamp: 'ar 2/20/2010 19:17' prior: 50890301!
                      proxyServer
	"The proxy server to use for connections.
	The server should be specified as server:port if the proxy
	port to be used is different from the desitation port."

	^proxyServer! !
!WebClient methodsFor: 'proxy' stamp: 'CK 11/24/2017 14:01:01' prior: 50890309!
                  proxyServer: aString
	"The proxy server to use for connections.
	The server should be specified as server:port if the proxy
	port to be used is different from the desitation port."

	proxyServer := aString.
	ProxyHandler defaultProxyServer: aString.! !
!WebClient methodsFor: 'proxy' stamp: 'ar 2/20/2010 19:22' prior: 50890319!
                       proxyServerName
	"Returns the name part of the server:port description"

	^proxyServer copyUpTo: $:! !
!WebClient methodsFor: 'proxy' stamp: 'ar 2/20/2010 19:21' prior: 50890325!
             proxyServerPort
	"Returns the port of the proxyServer:port description"

	^(proxyServer copyAfter: $:) 
		ifEmpty:[self serverPort]
		ifNotEmpty:[:portString| portString asInteger].
! !
!WebClient methodsFor: 'proxy' stamp: 'ar 3/24/2010 16:02' prior: 50890333!
                          proxyUser
	"The user name for an authenticating proxy"

	^proxyParams at: #username ifAbsent:[nil]! !
!WebClient methodsFor: 'proxy' stamp: 'ar 3/24/2010 16:02' prior: 50890339!
              proxyUser: aString
	"The user name for an authenticating proxy"

	proxyParams at: #username put: aString! !
!WebClient class methodsFor: 'accessing' stamp: 'ar 8/12/2010 21:20' prior: 50890345!
                              debugLog
	"The default debugLog, if any:
		WebClient debugLog: Transcript.
		WebClient debugLog: nil.
	"

	^DebugLog! !
!WebClient class methodsFor: 'accessing' stamp: 'ar 8/12/2010 21:20' prior: 50890351!
                  debugLog: aStream
	"The default debugLog, if any:
		WebClient debugLog: Transcript.
		WebClient debugLog: nil.
	"

	DebugLog := aStream.! !
!WebClient class methodsFor: 'accessing' stamp: 'ar 2/23/2010 22:26' prior: 50890358!
                              proxyHandler
	"The currently registered proxy handler"

	^ProxyHandler! !
!WebClient class methodsFor: 'accessing' stamp: 'ar 2/23/2010 22:26' prior: 50890363!
proxyHandler: anObject
	"The currently registered proxy handler"

	ProxyHandler := anObject! !
!WebClient class methodsFor: 'utilities' stamp: 'ar 6/1/2010 20:24' prior: 50890369!
            htmlSubmit: urlString fields: fieldMap
	"A utility method for html submit operations. The fieldMap can be EITHER
	an array of associations OR a Dictionary of key value pairs (the former is
	useful for providing multiple fields and/or specifying the order of fields).

		WebClient 
			htmlSubmit: 'http://www.google.com/search'
			fields: {
				'hl' -> 'en'.
				'q' -> 'Squeak'
			}
	"
	^self htmlSubmit: urlString 
			fields: fieldMap
			method: 'GET'
! !
!WebClient class methodsFor: 'utilities' stamp: 'ar 6/1/2010 20:24' prior: 50890386!
  htmlSubmit: urlString fields: fieldMap method: method
	"A utility method for html submit operations. The fieldMap can be EITHER
	an array of associations OR a Dictionary of key value pairs (the former is
	useful for providing multiple fields and/or specifying the order of fields).

		WebClient 
			htmlSubmit: 'http://www.google.com/search'
			fields: {
				'hl' -> 'en'.
				'q' -> 'Squeak'
			} method: 'GET'
	"
	^self htmlSubmit: urlString 
			fields: fieldMap
			method: method
			encoding: 'application/x-www-form-urlencoded'
! !
!WebClient class methodsFor: 'utilities' stamp: 'ar 7/20/2010 20:10' prior: 50890405!
                  htmlSubmit: urlString fields: fields method: method encoding: encoding
	"A utility method for html submit operations. The fieldMap can be EITHER
	an array of associations OR a Dictionary of key value pairs (the former is
	useful for providing multiple fields and/or specifying the order of fields).

		WebClient 
			htmlSubmit: 'http://www.google.com/search'
			fields: {
				'hl' -> 'en'.
				'q' -> 'Squeak'
			} method: 'GET'
			encoding: 'application/x-www-form-urlencoded'
	"

	method = 'GET' ifTrue:[
		"GET only supports url encoded requests"
		encoding = 'application/x-www-form-urlencoded' 
			ifFalse:[^self error: 'Unsupported encoding: ', encoding].
		^self httpGet: urlString, '?', (WebUtils encodeUrlEncodedForm: fields).
	].

	method = 'POST' ifTrue:[
		"Dispatch on encoding type"
		encoding caseOf: {
			[ 'application/x-www-form-urlencoded'] -> [
				^self httpPost: urlString
					content: (WebUtils encodeUrlEncodedForm: fields)
					type: encoding.
			].
			['multipart/form-data'] -> [
				^self httpPost: urlString multipartFields: fields
			].
		} otherwise:[]
	].

	self error: 'Unsupported method: ', method.
! !
!WebClient class methodsFor: 'utilities' stamp: 'ar 7/20/2010 20:09' prior: 50890443!
                       httpPost: url multipartFields: fieldMap
	"Make a form submission using multipart/form-data POST.

	The fieldMap may contain MIMEDocument instances to indicate the presence
	of a file to upload to the server. If the MIMEDocument is present, its
	content type and file name will be used for the upload.

	The fieldMap can be EITHER an array of associations OR a Dictionary of 
	key value pairs (the former is useful for providing multiple fields and/or 
	specifying the order of fields)."

	| boundary |
	boundary := WebUtils multipartBoundary.

	^self httpPost: url 
		content: (WebUtils encodeMultipartForm: fieldMap boundary: boundary) 
		type: 'multipart/form-data; boundary=', boundary! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:30' prior: 50890467!
                        httpDelete: urlString
	"Sends a DELETE request"
	"WebClient httpDelete: 'http://ftp.squeak.org/trunk'"

	^self httpDo:[:client| client httpDelete: urlString].
! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:29' prior: 50890475!
         httpDo: aBlock
	"Simplified wrapper for running various methods"

	| client response |
	client := self new.
	response := WebUtils handleAuth: [aBlock value: client].
	response content; close.
	^response! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:30' prior: 50890484!
                              httpGet: urlString
	"Get the response from the given url"
	"(WebClient httpGet: 'http://www.squeak.org') content"

	^self httpDo:[:client| client httpGet: urlString].! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:31' prior: 50890492!
  httpHead: urlString
	"Sends a HEAD request"
	"WebClient httpHead: 'http://ftp.squeak.org/trunk'"

	^self httpDo:[:client| client httpHead: urlString].
! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:31' prior: 50890499!
                 httpOptions: urlString
	"Sends an OPTIONS request"
	"WebClient httpOptions: 'http://ftp.squeak.org/*'"
	"WebClient httpOptions: 'http://ftp.squeak.org/4.1/Squeak4.1.zip'"

	^self httpDo:[:client| client httpOptions: urlString]
! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:31' prior: 50890509!
     httpPost: urlString content: postData type: contentType
	"Fire off an HTTP post request"

	^self httpDo:[:client| client httpPost: urlString content: postData type: contentType]
! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:31' prior: 50890517!
                      httpPostChunked: urlString content: chunkBlock type: contentType
	"POST the data to the given url using chunked transfer-encoding.
	The chunkBlock takes a request and can be fed using #nextChunkPut:
	until all the data has been sent.

	Chunked encoding can be used for long-lasting connections to a server,
	but care must be taken to ensure that the client isn't running afoul of
	the server expecting to read the full response (i.e., you should use this
	only if you have control over both ends).

	However, it is a great way to send output from commands that take awhile
	and other time-consuming operations if authentication has been handled."

	^self httpDo:[:client| 
		client httpPostChunked: urlString content: chunkBlock type: contentType]
! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:32' prior: 50890543!
                            httpPut: urlString content: postData type: contentType
	"Fire off an HTTP PUT request"

	^self httpDo:[:client| client httpPut: urlString content: postData type: contentType]! !
!WebClient class methodsFor: 'methods' stamp: 'ar 2/10/2012 13:32' prior: 50890551!
                          httpTrace: urlString
	"Sends a TRACE request"
	"(WebClient httpTrace: 'http://lists.squeakfoundation.org') content"
	"(WebClient httpTrace: 'http://ftp.squeak.org/trunk') content"

	^self httpDo:[:client| client httpTrace: urlString]! !
!WebClient class methodsFor: 'class initialization' stamp: 'jmv 6/26/2017 19:16:36' prior: 50890562 overrides: 16883149!
                          initialize
	"WebClient initialize"

	FlagAcceptCookies := 1.
	FlagAllowAuth := 2.
	FlagAllowRedirect := 4.

	"Default proxy handler"
	ProxyHandler := WebUtils! !
!WebClient class methodsFor: 'benchmark' stamp: 'jmv 6/25/2017 20:07:19' prior: 50890570!
    requestBenchmark: url persistent: aBool
	"Run a WebClient benchmark to measure request handling speed.
	Try using a persistent connection if requested.

	1) Launch WebServer  (or Seaside, or whatever):
	
		(WebServer reset default)
			listenOn: 8888;
			addService: '/' action:[:r| r send200Response: ''].

	2) Run the benchmark:

		MessageTally spyOn:[
			WebClient requestBenchmark: 'http://localhost:8888/' persistent: true.
		]
	"

	| time resp startTime endTime count client |
	count := 0.
	client := WebClient new.
	startTime := Time localMillisecondClock.
	[endTime := Time localMillisecondClock.
	(time := endTime - startTime) < 5000] whileTrue:[
		resp := client httpGet: url.
		resp isSuccess ifFalse:[self error: resp status].
		resp content.
		aBool ifFalse:[resp close].
		count := count + 1.
	].
	^(count  * 1000 // time) printStringWithCommas, ' requests/sec'! !
!WebClient class methodsFor: 'websockets' stamp: 'ar 9/26/2011 10:39' prior: 50890600!
                           webSocket00: serverUrl protocol: protocol
	"Attempt to connect to the given server url using the WebSocket api"

	| key1 key2 bytes hash client req resp |
	"Fixed keys from spec"
	key1 := 155712099.
	key2 := 173347027.
	bytes := ByteArray new: 8.
	(1 to: bytes size) do:[:i| bytes at: i put: (256 atRandom - 1)].
	hash := WebUtils webSocketHandshake: key1 with: key2 with: bytes.

	client := self new.
	client initializeFromUrl: serverUrl.
	req := client requestWithUrl: serverUrl.
	req method: 'GET'.
	req headerAt: 'Upgrade' put: 'WebSocket'.
	req headerAt: 'Connection' put: 'Upgrade'.
	req headerAt: 'Origin' put: 'null'.
	protocol ifNotNil:[req headerAt: 'Sec-WebSocket-Protocol' put: protocol].
	req headerAt: 'Sec-WebSocket-Key1' put: '18x 6]8vM;54 *(5:  {   U1]8  z [  8'.
	req headerAt: 'Sec-WebSocket-Key2' put: '1_ tx7X d  <  nw  334J702) 7]o}` 0'.
	resp := client sendRequest: req content: bytes readStream size: bytes size.
	resp code = 101 ifFalse:[client close. ^nil].
	(resp stream next: 16) asByteArray = hash ifFalse:[client close. ^nil].

	"Close of stream is left to caller"
	^WebSocket00 on: resp stream.
! !
!WebClient class methodsFor: 'websockets' stamp: 'ar 9/26/2011 10:39' prior: 50890638!
                               webSocket07: serverUrl protocol: protocol
	"Attempt to connect to the given server url using the WebSocket api"
	"http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07"

	| hash client req resp nonce |
	nonce := ByteArray new: 16.
	(1 to: nonce size) collect:[:i| nonce at: i put: (256 atRandom - 1)].
	nonce := nonce base64Encoded.

	client := self new.
	client initializeFromUrl: serverUrl.
	req := client requestWithUrl: serverUrl.
	req method: 'GET'.
	req headerAt: 'Upgrade' put: 'WebSocket'.
	req headerAt: 'Connection' put: 'Upgrade'.
	req headerAt: 'Sec-WebSocket-Origin' put: 'null'.
	protocol ifNotNil:[req headerAt: 'Sec-WebSocket-Protocol' put: protocol].
	req headerAt: 'Sec-WebSocket-Key' put: nonce.
	req headerAt: 'Sec-WebSocket-Version' put: '7'.

	resp := client sendRequest: req.
	resp code = 101 ifFalse:[client close. ^nil].

	"Verify WebSocket hash"
	hash := WebUtils webSocketHash07: nonce.
	hash = (resp headerAt: 'Sec-WebSocket-Accept') ifFalse:[client close. ^nil].

	"Close of stream is left to caller"
	^WebSocket07 on: resp stream.
! !
!WebClient class methodsFor: 'websockets' stamp: 'ar 9/26/2011 10:39' prior: 50890674!
                   webSocket68: serverUrl protocol: protocol
	"Attempt to connect to the given server url using the WebSocket api"

	| client req resp |
	client := self new.
	client initializeFromUrl: serverUrl.
	req := client requestWithUrl: serverUrl.
	req method: 'GET'.
	req headerAt: 'Upgrade' put: 'WebSocket'.
	req headerAt: 'Connection' put: 'Upgrade'.
	req headerAt: 'Origin' put: 'null'.
	protocol ifNotNil:[req headerAt: 'WebSocket-Protocol' put: protocol].
	resp := client sendRequest: req.
	resp code = 101 ifFalse:[client close. ^nil].

	"Close of stream is left to caller"
	^WebSocket00 on: resp stream.
! !
!WebClient class methodsFor: 'websockets' stamp: 'ar 7/9/2010 00:37' prior: 50890696!
              webSocketTo: serverUrl
	"Attempt to connect to the given server url using the WebSocket api"

	"Testing:

		1) Launch WebSocket example.
		2) Run the following code:
		
		| ws |
		ws := WebClient webSocketTo: 'http://localhost:8080/broadcast'.
		ws onMessage:[:data| Transcript cr; show: data].
		ws fork.
		ws send: 'This is the first message'.
		ws send: 'This is the last message'.
		ws close.

	"

	^self webSocketTo: serverUrl protocol: nil! !
!WebClient class methodsFor: 'websockets' stamp: 'ar 7/9/2010 00:31' prior: 50890713!
         webSocketTo: serverUrl protocol: protocol
	"Attempt to connect to the given server url using the WebSocket api"

	^self webSocket00: serverUrl protocol: protocol! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05' prior: 50890721!
           domain
	"Cookie domain"

	^domain! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05' prior: 50890725!
           domain: aString
	"Cookie domain"

	domain := aString.! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 5/11/2010 20:06' prior: 50890729!
                       expiry
	"The expiry DateAndTime"

	^expiry! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 5/11/2010 20:06' prior: 50890733!
  expiry: aDateAndTime
	"The expiry DateAndTime"

	expiry := aDateAndTime ifNotNil:[:dt| dt asUTC].! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 8/5/2010 18:21' prior: 50890739!
            expirySeconds: maxAge
	"Compute the cookie's expiry age from the given number of seconds"

	maxAge = 0 ifTrue:[self expiry: DateAndTime new].
	self expiry: DateAndTime now + maxAge seconds.! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 3/31/2010 08:38' prior: 50890748!
               httpOnly
	"If the cookie should be httpOnly (not scriptable).
	See http://msdn2.microsoft.com/en-us/library/ms533046.aspx"

	^httpOnly! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 3/31/2010 08:38' prior: 50890755!
      httpOnly: aBool
	"If the cookie should be httpOnly (not scriptable).
	See http://msdn2.microsoft.com/en-us/library/ms533046.aspx"

	httpOnly := aBool! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05' prior: 50890762!
                       name: aString
	"The name of the cookie"

	name := aString! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05' prior: 50890766!
                   path
	"Cookie path"

	^path! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05' prior: 50890769!
                 path: aString
	"Cookie path"

	path := aString! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05' prior: 50890773!
                              secure
	"Secure cookie flag"

	^secure! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05' prior: 50890777!
      secure: aBool
	"Secure cookie flag"

	secure := aBool! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:05' prior: 50890782 overrides: 16881508!
   value
	"The value of the cookie"

	^value! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:06' prior: 50890786!
   value: aString
	"The value of the cookie"

	value := aString! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:06' prior: 50890790!
                version
	"Cookie version"

	^version! !
!WebCookie methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:06' prior: 50890794!
        version: aString
	"Cookie version"

	version := aString! !
!WebCookie methodsFor: 'comparing' stamp: 'ar 5/11/2010 08:58' prior: 50890799 overrides: 16881029!
 = aCookie
	"Compare the receiver with aCookie"

	^aCookie class == self class 
		and:[aCookie name = self name
		and:[aCookie domain = self domain
		and:[aCookie path = self path]]].! !
!WebCookie methodsFor: 'comparing' stamp: 'ar 5/11/2010 08:59' prior: 50890808 overrides: 16881052!
  hash
	"Hash is re-implemented because #= is re-implemented"

	^name hash + domain hash + path hash.! !
!WebCookie methodsFor: 'converting' stamp: 'ar 2/20/2010 11:06' prior: 50890814 overrides: 16881101!
                    asString
	"Create the string representation for this cookie"

	^String streamContents:[:s| self printOn: s].! !
!WebCookie methodsFor: 'initialize' stamp: 'ar 3/31/2010 08:40' prior: 50890821 overrides: 16896425!
           initialize
	"Initializes the receiver"
	super initialize.
	secure := false.
	httpOnly := false.
! !
!WebCookie methodsFor: 'initialize' stamp: 'DSG 3/28/2015 16:36' prior: 50890827!
          readExpiryFrom: aString
	"Read a cookie expiry date from the given string.
	The expiration date is specified in the 'Wdy, DD-Mon-YYYY HH:MM:SS GMT' format."
	
	| tokens |
	^[
		tokens := aString withBlanksTrimmed.
		(tokens copyAfterLast: Character space) = 'GMT'
			ifFalse:[^DateAndTime new].
		tokens := (tokens copyAfter: Character space) copyUpToLast: Character space.
		(DateAndTime readFrom: tokens readStream) utcOffset: Duration zero.
	] on: Error do:[:ex| ex return: DateAndTime new].! !
!WebCookie methodsFor: 'initialize' stamp: 'jmv 6/25/2017 19:15:38' prior: 50890845!
                         readFrom: aStream
	"Read a cookie from the given stream"

	| keyval key val |
	aStream skipSeparators.
	name := (aStream upTo: $=) withBlanksTrimmed.
	value := (aStream upTo: $;) withBlanksTrimmed.
	[aStream atEnd] whileFalse:[
		keyval := aStream upTo: $;.
		key := (keyval copyUpTo: $=) withBlanksTrimmed.
		val := (keyval copyAfter: $=) withBlanksTrimmed.
		key asLowercase caseOf: {
			['expires'] 	-> [self expiry: (self readExpiryFrom: val)].
			['path']		-> [self path: (WebUtils unquote: val)].
			['domain'] 	-> [self domain: (WebUtils unquote: val)].
			['secure'] 	-> [self secure: true].
			['version'] 	-> [self version: val].
			['httponly'] 	-> [self httpOnly: true].
			['comment']	 ->[self comment: val].
			['max-age']	->[self expirySeconds: val asNumber].
		} otherwise:[Transcript log: 'Unknown cookie field: ', key].
	].! !
!WebCookie methodsFor: 'testing' stamp: 'ar 5/11/2010 20:06' prior: 50890874!
     isExpired
	"Return true if this cookie is expired"
	
	expiry ifNil:[^false].
	^expiry asUTC < DateAndTime now asUTC! !
!WebMessage methodsFor: 'printing' stamp: 'DSG 5/24/2012 17:38' prior: 50890880!
                        writeHeadersOn: aStream
	"Write the request"

	self headersDo:[:key :value| aStream nextPutAll: key, ': ', value asString; nextPutAll: String crlfString].
! !
!WebMessage methodsFor: 'printing' stamp: 'DSG 5/24/2012 17:38' prior: 50890887!
                writeOn: aStream
	"Write the request"

	self writeHeadersOn: aStream.
	aStream nextPutAll: String crlfString.
! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 16:31' prior: 50890893!
                               addHeader: key value: value
	"Adds an ADDITIONAL header for the given key"

	headers add: key -> value.! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 11:02' prior: 50890899!
      headerAt: key
	"Answers a single value for the given http header. 
	Do not use for headers that may appear multiple times, such at www-authenticate."

	^self headerAt: key ifAbsent:[''].! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 11:03' prior: 50890907!
                   headerAt: key ifAbsent: aBlock
	"Answers a single value for the given http header. 
	Do not use for headers that may appear multiple times, such at www-authenticate."

	self headersAt: key do:[:value| ^value].
	^aBlock value! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 12:18' prior: 50890917!
             headerAt: key put: value
	"Sets the value of a header, adding if necessary"

	headers do:[:assoc|
		(assoc key sameAs: key) ifTrue:[
			assoc value: value.
			^self
		].
	].
	self addHeader: key value: value.! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 11:03' prior: 50890926!
                             headersAt: key
	"Answers a collection of values for the given http header. 
	Use for headers that may appear multiple times, such at www-authenticate."

	^self headersAt: key ifAbsent:[#()].! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 11:03' prior: 50890935!
               headersAt: aKey do: aBlock
	"Evaluate aBlock with all the headers matching aKey"

	self headersDo:[:key :value|
		(aKey sameAs: key) ifTrue:[ aBlock value: value].
	].! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 11:03' prior: 50890943!
      headersAt: key ifAbsent: aBlock
	"Answers a collection of values for the given http header. 
	Use for headers that may appear multiple times, such at www-authenticate."

	| hdrs |
	hdrs := OrderedCollection new.
	self headersAt: key do:[:value| hdrs add: value].
	^hdrs asArray ifEmpty:[aBlock value]
! !
!WebMessage methodsFor: 'headers' stamp: 'ar 2/20/2010 11:03' prior: 50890955!
headersDo: aBlock
	"Evaluate aBlock with all of the headers key-value pairs"

	headers do:[:assoc|
		aBlock value: assoc key value: assoc value.
	].! !
!WebMessage methodsFor: 'headers' stamp: 'ar 3/26/2010 19:02' prior: 50890962!
                         removeHeader: key
	"Removes ALL headers with the given key"

	headers := headers reject:[:assoc| assoc key sameAs: key].
! !
!WebMessage methodsFor: 'converting' stamp: 'ar 2/23/2010 09:02' prior: 50890969 overrides: 16881101!
                             asString
	"Prints the receiver"

	^String streamContents:[:s| self writeOn: s].! !
!WebMessage methodsFor: 'streaming' stamp: 'ar 2/2/2012 15:55' prior: 50890974!
                             chunkFrom: srcStream to: dstStream progress: progressBlock
	"Stream the content of srcStream to dstStream.
	Use chunked transfer-encoding."

	| chunkSize firstLine buffer totalRead |
	totalRead := 0.
	buffer := (srcStream isBinary ifTrue:[ByteArray] ifFalse:[String]) new.
	[firstLine := srcStream nextLine asString.
	chunkSize := ('16r',firstLine asUppercase) asNumber.
	chunkSize = 0] whileFalse:[
		progressBlock ifNotNil:[progressBlock value: nil value: totalRead].
		buffer size = chunkSize ifFalse:[buffer := buffer class new: chunkSize].
		buffer := srcStream next: chunkSize into: buffer startingAt: 1.
		dstStream nextPutAll: buffer.
		srcStream skip: 2. "CRLF"
		totalRead := totalRead + chunkSize.
	].
	srcStream skip: 2. "CRLF"
	dstStream flush.
	progressBlock ifNotNil:[progressBlock value: nil value: totalRead].! !
!WebMessage methodsFor: 'streaming' stamp: 'DSG 3/29/2015 09:10' prior: 50891002!
                nextChunk
	"Answer the next chunk from a message using chunked transfer encoding."

	| chunkSize chunk |
	chunkSize := Integer readFrom: (stream upToAll: String crlfString) readStream base: 16.
	chunkSize = 0 ifFalse:[chunk := stream next: chunkSize].
	stream skip: 2. "CrLf"
	^chunk! !
!WebMessage methodsFor: 'streaming' stamp: 'ar 8/31/2010 22:57' prior: 50891013!
                nextChunkPut: chunk
	"Send the next chunk of a message using chunked transfer encoding.

	Note: This method does not allow to send empty chunks to avoid accidentally
	terminating the chunked transfer. Ending the transfer is part of the chunked
	request/response protocol (see #httpPostChunked:encoded:content:type:do:
	as well as #sendResponse:chunked:do:)"

	chunk ifNotEmpty:[
		stream nextPutAll: (chunk size printStringBase: 16); crlf.
		stream nextPutAll: chunk; crlf; flush.
	].! !
!WebMessage methodsFor: 'streaming' stamp: 'ar 5/4/2010 15:44' prior: 50891031!
        streamFrom: srcStream size: size progress: aBlock
	"Stream the given source stream to the message's socket stream.
	Outbound. Can be used on both request/response depending on
	whether it is utilized by WebClient or WebServer."

	^self streamFrom: srcStream to: stream size: size progress: aBlock! !
!WebMessage methodsFor: 'streaming' stamp: 'ar 7/10/2010 13:51' prior: 50891043!
   streamFrom: srcStream to: dstStream size: sizeOrNil progress: progressBlock
	"Stream the content of srcStream to dstStream.
	If a size is given, stream that many elements, otherwise stream up to the end."

	| buffer totalRead remaining size |
	(self headerAt: 'transfer-encoding') ifNotEmpty:[:encoding|
		encoding = 'chunked' 
			ifTrue:[^self chunkFrom: srcStream to: dstStream progress: progressBlock]
			ifFalse:[self error: 'Unknown transfer-encoding: ', encoding]].

	sizeOrNil = 0 ifTrue:[^self].

	buffer := (srcStream isBinary ifTrue:[ByteArray] ifFalse:[String]) new: 4096.
	totalRead := 0.
	size := sizeOrNil ifNil:[0].
	[(sizeOrNil == nil and:[stream atEnd not]) or:[totalRead < size]] whileTrue:[
		progressBlock ifNotNil:[progressBlock value: sizeOrNil value: totalRead].
		remaining := sizeOrNil ifNil:[99999] ifNotNil:[sizeOrNil - totalRead].
		remaining > buffer size ifTrue:[remaining := buffer size].
		buffer := srcStream next: remaining into: buffer startingAt: 1.
		dstStream nextPutAll: (remaining < buffer size  
			ifTrue:[(buffer copyFrom: 1 to: remaining)]
			ifFalse:[buffer]).
		totalRead := totalRead + buffer size.
	].
	dstStream flush.
	progressBlock ifNotNil:[progressBlock value: sizeOrNil value: totalRead].! !
!WebMessage methodsFor: 'streaming' stamp: 'ar 5/4/2010 15:46' prior: 50891084!
                  streamTo: dstStream size: size progress: aBlock
	"Stream from the receiver's socket stream to the given destination stream.
	Inbound. Can be used on both request/response depending on
	whether it is utilized by WebClient or WebServer."
	content ifNil:[
		self streamFrom: stream to: dstStream size: size progress: aBlock
	] ifNotNil:[
		self streamFrom: content readStream to: dstStream size: size progress: aBlock
	].! !
!WebMessage methodsFor: 'initialize' stamp: 'ar 5/4/2010 20:02' prior: 50891100!
         close
	"Always closes regardless of connection header"

	stream ifNotNil:[stream close].! !
!WebMessage methodsFor: 'initialize' stamp: 'ar 5/6/2010 20:47' prior: 50891105!
                   closeIfTransient
	"Close the underlying connection if it's not persistent"

	self isPersistent ifFalse:[self close].
! !
!WebMessage methodsFor: 'initialize' stamp: 'ar 5/4/2010 20:02' prior: 50891111!
                      destroy
	"Destroys the underlying stream"

	stream ifNotNil:[stream destroy].! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 6/18/2010 23:52' prior: 50891116!
                              content
	"Reads and caches available content and returns it."

	^content ifNil:[content := self getContent].
! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 3/30/2010 22:05' prior: 50891122!
                              content: aString
	"Sets content for a response"

	content := aString.! !
!WebMessage methodsFor: 'accessing' stamp: 'tsl 1/18/2021 11:17:47' prior: 50891127!
  contentLength
	"Answers the numeric value of the Content-Length header, or nil if no header exist"

	^(self headerAt: 'Content-Length' ifAbsent:[^nil]) asNumber! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 5/4/2010 21:04' prior: 50891135!
            contentLength: aNumber
	"Sets the numeric value of the Content-Length header"

	^self headerAt: 'Content-Length' put: aNumber! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:01' prior: 50891142!
              contentStream
	"Answers a stream for the conent."

	^stream! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:02' prior: 50891146!
                contentType
	"Answer the content type for the receiver"

	^self headerAt: 'Content-Type' ifAbsent:['application/octet-stream']
! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 3/30/2010 21:58' prior: 50891153!
            contentType: aString
	"Sets the content type for the receiver"

	^self headerAt: 'Content-Type' put: aString! !
!WebMessage methodsFor: 'accessing' stamp: 'ul 4/21/2015 06:40' prior: 50891159!
                               contentWithProgress: progressBlock
	"Reads and caches available content and returns it."

	^content ifNil: [ content := self getContentWithProgress: progressBlock ]! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 7/20/2010 20:09' prior: 50891167!
       multipartBoundary
	"Answer the boundary of a multipart/form-data message"

	| header |
	header := self headerAt: 'Content-Type' ifAbsent:[^nil].
	(header beginsWith: 'multipart/form-data') ifFalse:[^nil].
	^(header copyFrom: (header findString: 'boundary=') + 9 to: header size)! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 2/20/2010 16:31' prior: 50891178!
                     protocol
	"Returns the requested protocol"

	^protocol! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 2/20/2010 16:31' prior: 50891182!
                     protocol: aString
	"Returns the requested protocol"

	protocol := aString! !
!WebMessage methodsFor: 'accessing' stamp: 'dtl 7/17/2012 18:59' prior: 50891187!
 remoteHost
	"Return the name of the remote host"

	| remote |
	(stream isKindOf: SocketStream) ifFalse:[^nil]. "don't have it"
	remote := stream socket remoteAddress.
	^ NetNameResolver stringFromAddress: remote.
! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:01' prior: 50891196!
                      stream
	"Answers the underlying TCP stream"

	^stream! !
!WebMessage methodsFor: 'accessing' stamp: 'ar 2/20/2010 11:01' prior: 50891200!
                      stream: aStream
	"Sets the underlying TCP stream"

	stream := aStream! !
!WebMessage methodsFor: 'private' stamp: 'ul 4/21/2015 06:31' prior: 50891205!
        getContent
	"Reads available content and returns it."

	^self getContentWithProgress: nil! !
!WebMessage methodsFor: 'private' stamp: 'jmv 6/25/2017 19:43:27' prior: 50891210!
                getContentWithProgress: progressBlockOrNil
	"Reads available content and returns it."

	| length result |
	length := self contentLength.
	result := (stream isBinary ifTrue:[ ByteArray ] ifFalse: [ String ])
		streamContents: [ :outputStream | 
			self 
				streamFrom: stream
				to: outputStream
				size: length
				progress: progressBlockOrNil ]
		estimatedSize: (length ifNil: [ 1000 ]).
	(self headerAt: 'content-encoding') = 'gzip' ifFalse: [ ^result ].
	^(GZipReadStream on: result) upToEnd! !
!WebMessage methodsFor: 'testing' stamp: 'pmm 6/19/2010 08:05' prior: 50891228!
                           isPersistent
	"Return true if this is a persistent connection"

	"Check for explicit connection headers"
	((self headerAt:'Connection') sameAs: 'close') ifTrue:[^false].
	((self headerAt:'Connection') sameAs: 'keep-alive') ifTrue:[^true].

	"Defaults for various versions"
	(self protocol = 'HTTP/1.0') ifTrue:[^false].
	(self protocol = 'HTTP/1.1') ifTrue:[^true].

	"Assume that later HTTP versions are compatible with 1.1"
	^true! !
!WebMessage class methodsFor: 'class initialization' stamp: 'ar 2/21/2010 09:55' prior: 50891245 overrides: 16883149!
                      initialize
	"self initialize"

	StatusCodes := Dictionary newFromPairs:{
		"1xx: Meta status codes"
		100. 	'Continue'.
		101. 	'Switching Protocols'.
		102.	'Processing'.
		"2xx: Success status codes"
		200.	'OK'.
		201.	'Created'.
		202.	'Accepted'.
		203. 	'Non-Authoritative Information'.
		204.	'No Content'.
		205. 	'Reset Content'.
		206.	'Partial Content'.
		207.	'Multi-Status'. 				"WebDav RFC: 2518"
		"3xx: Redirection status codes"
		300.	'Multiple Choices'.
		301.	'Moved Permanently'.
		302.	'Moved Temporarily'.
		303.	'See Other'.
		304.	'Not Modified'.
		305.	'Use Proxy'.
		307.	'Temporary Redirect'.
		"4xx: Client-Side Error status code"
		400.	'Bad Request'.
		401.	'Unauthorized'.
		402.	'Payment Required'.
		403.	'Forbidden'.
		404.	'Not Found'.
		405.	'Method Not Allowed'.
		406.	'Not Acceptable'.
		407.	'Proxy Authentication Required'.
		408.	'Request Timeout'.
		409.	'Conflict'.
		410.	'Gone'.
		411.	'Lenght Required'.
		412.	'Precondition Failed'.
		413.	'Request Entity Too Large'.
		414.	'Request-URI Too Long'.
		415.	'Unsupported Media Type'.
		416.	'Requested Range Not Satisfiable'.
		417.	'Expectation Failed'.
		422.	'Unprocessable Entity'. 		"WebDav RFC: 2518"
		423.	'Locked'. 					"WebDav RFC: 2518"
		424.	'Failed Dependency'. 		"WebDav RFC: 2518"
		"5xx: Server-Side Error status codes"
		500.	'Internal Server Error'.
		501.	'Not Implemented'.
		502.	'Bad Gateway'.
		503.	'Service Unavailable'.
		504.	'Gateway Timeout'.
		505.	'HTTP Version Not Supported'.
		507.	'Insufficient Storage'. 		"WebDav RFC: 2518"
	}.! !
!WebMessage class methodsFor: 'utilities' stamp: 'klub 1/14/2014 22:09' prior: 50891297!
          statusCodeAt: code
	"Return the textual description of a status code"

	^StatusCodes at: code ifAbsent: [ 'Unknown error' ]! !
!WebRequest methodsFor: 'testing' stamp: 'ar 8/5/2010 19:51' prior: 50891303!
                   acceptsCookie: aCookie from: webClient
	"Returns true if this cookie is applicable to this request"

	aCookie domain ifNotNil:[:domain|
		(webClient serverName endsWith: domain) ifFalse:[^false].
	].
	aCookie path ifNotNil:[:path|
		(self url beginsWith: path) ifFalse:[^false].
	].
	aCookie secure ifNotNil:[:secure|
		secure ifTrue:[webClient scheme = 'https' ifFalse:[^false]].
	].
	aCookie expiry ifNotNil:[:expiry|
		aCookie isExpired ifTrue:[^false].
	].
	^true! !
!WebRequest methodsFor: 'testing' stamp: 'ar 6/23/2010 15:18' prior: 50891320!
                          isDeleteRequest
	"Returns true if this is an HTTP DELETE request"

	^self method = 'DELETE'! !
!WebRequest methodsFor: 'testing' stamp: 'ar 2/20/2010 10:40' prior: 50891325!
                  isGetRequest
	"Returns true if this is an HTTP GET request"

	^self method = 'GET'! !
!WebRequest methodsFor: 'testing' stamp: 'ar 2/20/2010 10:41' prior: 50891330!
                           isHeadRequest
	"Returns true if this is an HTTP HEAD request"

	^self method = 'HEAD'! !
!WebRequest methodsFor: 'testing' stamp: 'ar 6/23/2010 15:19' prior: 50891335!
                        isOptionsRequest
	"Returns true if this is an HTTP OPTIONS request"

	^self method = 'OPTIONS'! !
!WebRequest methodsFor: 'testing' stamp: 'ar 2/20/2010 10:41' prior: 50891341!
               isPostRequest
	"Returns true if this is an HTTP POST request"

	^self method = 'POST'! !
!WebRequest methodsFor: 'testing' stamp: 'ar 6/23/2010 15:18' prior: 50891346!
                        isPutRequest
	"Returns true if this is an HTTP PUT request"

	^self method = 'PUT'! !
!WebRequest methodsFor: 'testing' stamp: 'ar 6/23/2010 15:18' prior: 50891351!
                           isTraceRequest
	"Returns true if this is an HTTP TRACE request"

	^self method = 'TRACE'! !
!WebRequest methodsFor: 'converting' stamp: 'ar 9/26/2011 10:25' prior: 50891356!
                  asWebSocket
	"Convert this request into a WebSocket"

	"Figure out the version of the protocol"
	| field version |
	version := self headerAt: 'Sec-WebSocket-Version' ifAbsent:[nil].
	version ifNil:[
		field := self headerAt: 'Sec-WebSocket-Key1' ifAbsent:[nil].
		field 
			ifNil:[^self asWebSocket68] 
			ifNotNil:[^self asWebSocket00].
	].

	"Attempt WebSocket07 conversion"
	^self asWebSocket07
! !
!WebRequest methodsFor: 'converting' stamp: 'ar 9/26/2011 10:39' prior: 50891371!
                            asWebSocket00
	"Convert this request into a WebSocket"

	| field key1 key2 bytes resp |
	resp := self newResponse protocol: 'HTTP/1.1' code: 101.
	resp status: 'HTTP/1.1 101 Web Socket Protocol Handshake'.

	"Chrome 4/5 is *VERY* sensitive to the order of the fields"
	resp headerAt: 'Upgrade' put: 'WebSocket'.
	resp headerAt: 'Connection' put: 'Upgrade'.

	field := self headerAt: 'Sec-WebSocket-Key1'.
	key1 := WebUtils extractWebSocketKey: field.
	field := self headerAt: 'Sec-WebSocket-Key2'.
	key2 := WebUtils extractWebSocketKey: field.
	bytes := WebUtils webSocketHandshake: key1 with: key2 with: (stream next: 8).

	resp headerAt: 'Sec-WebSocket-Origin' put: (self headerAt: 'Origin').
	resp headerAt: 'Sec-WebSocket-Location' put: ('ws://', (self headerAt: 'host'), self rawUrl).
	(self headerAt: 'Sec-WebSocket-Protocol' ifAbsent:[nil]) ifNotNil:[:hdr|
		resp headerAt: 'Sec-WebSocket-Protocol' put: hdr.
	].

	resp writeOn: stream.
	bytes ifNotNil:[stream nextPutAll: bytes].
	stream flush.
	^WebSocket00 on: stream.
! !
!WebRequest methodsFor: 'converting' stamp: 'klub 6/13/2012 17:00' prior: 50891406!
   asWebSocket07
	"Convert this request into a WebSocket"

	| resp hash nonce |
	resp := self newResponse protocol: 'HTTP/1.1' code: 101.
	resp status: 'HTTP/1.1 101 Web Socket Protocol Handshake'.

	"Chrome 4/5 is *VERY* sensitive to the order of the fields"
	resp headerAt: 'Upgrade' put: 'WebSocket'.
	resp headerAt: 'Connection' put: 'Upgrade'.

	nonce := self headerAt: 'Sec-WebSocket-Key'.
	hash := WebUtils webSocketHash07: nonce.

	resp headerAt: 'Sec-WebSocket-Accept' put: hash.
	(self headerAt: 'Sec-WebSocket-Origin' ifAbsent: [self headerAt: 'Origin']) 
		ifNotNil: [ :origin | resp headerAt: 'Sec-WebSocket-Origin' put: origin ].
	resp headerAt: 'Sec-WebSocket-Location' put: ('ws://', (self headerAt: 'host'), self rawUrl).
	(self headerAt: 'Sec-WebSocket-Protocol' ifAbsent:[nil]) ifNotNil:[:hdr|
		resp headerAt: 'Sec-WebSocket-Protocol' put: hdr.
	].

	resp writeOn: stream.
	stream flush.
	^(WebSocket07 on: stream)
		masking: false;
		yourself.
	"http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07#section-4.1 says:
   ''Frames sent from the server to the client are not masked.''
	http://tools.ietf.org/html/rfc6455#section-5.1 says: 
   ''A client MUST close a connection if it detects a masked
   frame.''
	So not using masking is compatible with the 07 protocol and is required by RFC 6455."! !
!WebRequest methodsFor: 'converting' stamp: 'ar 9/26/2011 10:40' prior: 50891450!
                          asWebSocket68
	"Convert this request into a WebSocket"

	| resp |
	resp := self newResponse protocol: 'HTTP/1.1' code: 101.
	resp status: 'HTTP/1.1 101 Web Socket Protocol Handshake'.

	"Chrome 4/5 is *VERY* sensitive to the order of the fields"
	resp headerAt: 'Upgrade' put: 'WebSocket'.
	resp headerAt: 'Connection' put: 'Upgrade'.

	resp headerAt: 'WebSocket-Origin' put: (self headerAt: 'Origin').
	resp headerAt: 'WebSocket-Location' put: ('ws://', (self headerAt: 'host'), self rawUrl).
	(self headerAt: 'WebSocket-Protocol' ifAbsent:[nil]) ifNotNil:[:hdr|
		resp headerAt: 'WebSocket-Protocol' put: hdr.
	].
	resp writeOn: stream.
	stream flush.
	^WebSocket00 on: stream.! !
!WebRequest methodsFor: 'sending' stamp: 'klub 7/24/2011 19:25' prior: 50891474!
    closeIfTransient: resp after: aBlock
	"Evaluate aBlock. Close the connection if it is transient.
	Inserts Connection: close header if needed."

	| close |
	close := self isPersistent not.
	close 
		ifTrue: [
			"Always be explicit and insert the Connection: close header"
			resp headerAt: 'Connection' put: 'close' ]
		ifFalse: [
			"We should tell the client that we keep this connection alive."
			resp headerAt: 'Connection' put: 'Keep-Alive' ].
	aBlock value.
	stream flush.
	close  ifTrue:[self close].
! !
!WebRequest methodsFor: 'sending' stamp: 'ar 2/23/2010 22:04' prior: 50891492!
                sendResponse: resp content: aString
	"Send a WebResponse with content."

	^self sendResponse: resp contentStream: aString readStream size: aString size! !
!WebRequest methodsFor: 'sending' stamp: 'ar 8/31/2010 22:11' prior: 50891499!
                      sendResponse: resp contentBlock: contentBlock
	"Sends a WebResponse, streaming its contents from aStream.
	If a size is provided, insert a Content-Length header, otherwise
	ensure that the connection is transient."

	"Add Date and Server headers"
	resp headerAt: 'Date' put: (server ifNil:[WebServer]) serverDate.
	resp headerAt: 'Server' put: (server ifNil:[WebServer]) serverString.

	self closeIfTransient: resp after:[
		"Ignore all network errors while sending the response"
		[resp writeOn: stream.
		stream flush.
		self isHeadRequest ifFalse:[contentBlock value: stream].
		] on: NetworkError do:["ignore"].

		"Make sure we log before closing the connection"
		server ifNotNil:[server logRequest: self response: resp].
	].! !
!WebRequest methodsFor: 'sending' stamp: 'ar 8/31/2010 22:12' prior: 50891524!
                  sendResponse: resp contentStream: aStream size: streamSize
	"Sends a WebResponse, streaming its contents from aStream.
	If a size is provided, insert a Content-Length header, otherwise
	ensure that the connection is transient."

	streamSize 
		ifNil:[self headerAt: 'Connection' put: 'close'] "mark transient"
		ifNotNil:[resp headerAt: 'Content-Length' put: streamSize].

	^self sendResponse: resp contentBlock:[:sockStream|
		resp streamFrom: aStream to: sockStream size: streamSize progress: nil
	]! !
!WebRequest methodsFor: 'cookies' stamp: 'ar 2/20/2010 19:34' prior: 50891542!
                        cookieAt: aString
	"Answer the value for a cookie with the given name"

	^self cookieAt: aString ifAbsent:['']! !
!WebRequest methodsFor: 'cookies' stamp: 'ar 2/20/2010 19:35' prior: 50891548!
                               cookieAt: aString ifAbsent: aBlock
	"Answer the value for a cookie with the given name"

	self cookiesDo:[:name :value| name = aString ifTrue:[^value]].
	^aBlock value! !
!WebRequest methodsFor: 'cookies' stamp: 'ar 2/20/2010 19:35' prior: 50891556!
      cookies
	"Answer all the cookies defined in the request"

	| cookies |
	cookies := Dictionary new.
	self cookiesDo:[:name :value| cookies at: name put: value].
	^cookies! !
!WebRequest methodsFor: 'cookies' stamp: 'ar 8/5/2010 19:56' prior: 50891564!
     cookiesDo: aBlock
	"Parse the cookie headers and evaluate aBlock with name / value pairs"

	self headersAt: 'Cookie' do:[:hdr|
		(hdr findTokens: ';,') do:[:token|
			aBlock 
				value: (token copyUpTo: $=) withBlanksTrimmed 
				value: (token copyAfter: $=) withBlanksTrimmed]].! !
!WebRequest methodsFor: 'fields' stamp: 'ar 7/20/2010 20:08' prior: 50891575!
                       fields
	"Answer the fields for the given request."

	| fields |
	fields := Dictionary new.
	self getFields associationsDo:[:a| fields add: a].
	self postFields associationsDo:[:a| fields add: a].
	self multipartFields associationsDo:[:a| fields add: a].
	^fields
! !
!WebRequest methodsFor: 'fields' stamp: 'ar 2/21/2010 09:55' prior: 50891586!
       getFields
	"Decodes the fields embedded in the url ?var1=val1&var2=val2"

	| args |
	args := (rawUrl copyAfter: $?) ifEmpty:[^Dictionary new].
	^WebUtils decodeUrlEncodedForm: args multipleValues: false
! !
!WebRequest methodsFor: 'fields' stamp: 'ar 7/28/2010 21:01' prior: 50891595!
   multipartFields
	"Answers the multipart fields of a post request"

	| fields |
	fields := Dictionary new.
	self multipartFieldsDo:[:hdrs :params :cntnt|
		params at: 'name' ifPresent:[:fieldName| fields at: fieldName put: cntnt].
	].
	^fields! !
!WebRequest methodsFor: 'fields' stamp: 'ar 7/20/2010 20:08' prior: 50891605!
                            multipartFieldsDo: aBlock
	"Evaluate aBlock with the multipart fields of a post request.
	The block is expected to take three arguments:
		* The headers from the part being processed
		* The parameters from the content-disposition header
		* The content from the part being processed
	"

	^(self isPostRequest and: [
		self contentType beginsWith: 'multipart/form-data'])
			ifTrue: [WebUtils decodeMultipartForm: self content readStream boundary: self multipartBoundary do: aBlock]
			ifFalse: [Dictionary new]! !
!WebRequest methodsFor: 'fields' stamp: 'jmv 6/25/2017 20:10:00' prior: 50891624!
           postFields
	"Answers the multipart fields of a post request"

	^(self isPostRequest and: [
		self contentType beginsWith: 'application/x-www-form-urlencoded'])
			ifTrue: [
				WebUtils 
					decodeUrlEncodedForm: self content 
					multipleValues: true ]
			ifFalse: [Dictionary new]! !
!WebRequest methodsFor: 'initialize' stamp: 'ar 2/23/2010 09:02' prior: 50891636 overrides: 16896425!
                          initialize
	"Initialize the receiver"

	super initialize.
	method := 'GET'.
	protocol := 'HTTP/1.1'.
	headers := OrderedCollection new.! !
!WebRequest methodsFor: 'initialize' stamp: 'ar 9/4/2010 11:09' prior: 50891643!
    initializeFromUrl: urlString
	"Initialize the client from a http url or string"

	| urlStream |
	urlStream := urlString readStream.
	"Skip past scheme if present"
	urlStream upToAll: '://'.
	urlStream atEnd 
		ifTrue:[rawUrl := urlString]
		ifFalse:[rawUrl := urlStream upTo: $/; upToEnd].
	(rawUrl beginsWith: '/') ifFalse:[rawUrl := '/', rawUrl].
! !
!WebRequest methodsFor: 'initialize' stamp: 'ar 4/1/2010 16:03' prior: 50891657!
              newResponse
	"Create a new response entitiy.
	Subclasses can override this method to provide a different response class"

	^(WebResponse new)
		request: self;
		yourself! !
!WebRequest methodsFor: 'initialize' stamp: 'ar 7/8/2010 19:11' prior: 50891665!
  newWebSocketOn: aStream
	"Create a new socket entitiy.
	Subclasses can override this method to provide a different response class"

	^WebSocket on: aStream! !
!WebRequest methodsFor: 'initialize' stamp: 'jmv 6/25/2017 19:15:52' prior: 50891673!
           readFrom: aStream
	"Initialize the receiver initialized from an existing socket stream 
	This method will block until the headers have been parsed."

	| tokens |
	stream := aStream.
	stream isBinary ifTrue:[stream ascii].
	"Parse request header"
	request := stream upToAll: String crlfString.
	tokens := request findTokens: ' '.
	tokens size < 2 ifTrue:[^self error: 'Invalid HTTP request: ', request].
	method := tokens first.
	rawUrl := tokens second.
	tokens size > 2 
		ifTrue:[protocol := tokens third]
		ifFalse:[protocol := 'HTTP/1.0'].

	"Parse HTTP header"
	headers := WebUtils readHeadersFrom: stream.
! !
!WebRequest methodsFor: 'accessing' stamp: 'ar 2/20/2010 10:40' prior: 50891695!
       method
	"The request method (GET, POST etc)"

	^method! !
!WebRequest methodsFor: 'accessing' stamp: 'ar 2/20/2010 10:40' prior: 50891699!
                     method: aString
	"The request method (GET, POST etc)"

	method := aString! !
!WebRequest methodsFor: 'accessing' stamp: 'ar 2/20/2010 10:40' prior: 50891704!
  rawUrl
	"The raw (unparsed) url"

	^rawUrl! !
!WebRequest methodsFor: 'accessing' stamp: 'ar 5/11/2010 20:07' prior: 50891708!
 rawUrl: aString
	"The raw (unparsed) url"

	rawUrl := aString
! !
!WebRequest methodsFor: 'accessing' stamp: 'ar 7/28/2010 19:49' prior: 50891713!
             requestLine
	"The actual request line as sent by the client"

	^request ifNil:[self method, ' ', self rawUrl, ' ', self protocol]! !
!WebRequest methodsFor: 'accessing' stamp: 'ar 6/14/2010 20:55' prior: 50891720!
          server
	"If non-nil, the WebServer instance associated with the request."

	^server! !
!WebRequest methodsFor: 'accessing' stamp: 'ar 6/14/2010 20:55' prior: 50891725!
                        server: aWebServer
	"If non-nil, the WebServer instance associated with the request."

	server := aWebServer! !
!WebRequest methodsFor: 'accessing' stamp: 'DSG 5/24/2012 21:18' prior: 50891731!
                              url
	"The url without fragment or arguments"

	^((rawUrl copyUpTo: $#) copyUpTo: $?) unescapePercents! !
!WebRequest methodsFor: 'responses' stamp: 'DSG 12/5/2013 10:57' prior: 50891737!
     send200Response: aString
	"Send a 200 OK response"

	^self 
		send200Response: (aString asUtf8) 
		contentType: 'text/plain; charset=utf-8'.! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/20/2010 15:42' prior: 50891744!
                               send200Response: aString contentType: contentType
	"Send a 200 OK response"

	^self send200Response: aString contentType: contentType do:[:resp]! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 16:32' prior: 50891751!
                           send200Response: aString contentType: contentType do: aBlock
	"Send a 200 OK response"

	| resp |
	resp := self newResponse protocol: 'HTTP/1.1' code: 200.
	resp headerAt: 'Content-Type' put: contentType.
	aBlock value: resp.
	^self sendResponse: resp content: aString.! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 03:26' prior: 50891762!
                              send301Response: location
	"Send a 301 permanent redirect response"

	^self send301Response: location do:[:resp].! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 03:27' prior: 50891768!
                          send301Response: location do: aBlock
	"Send a 301 permanent redirect response"

	^self send3xxResponse: location code: 301 do: aBlock! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 03:26' prior: 50891775!
      send302Response: location
	"Send a 302 temporary redirect response"

	^self send302Response: location do:[:resp].! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 03:26' prior: 50891781!
                          send302Response: location do: aBlock
	"Send a 302 temporary redirect response"

	^self send3xxResponse: location code: 302 do: aBlock! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/20/2010 15:42' prior: 50891788!
      send3xxResponse: location code: statusCode
	"Send a 3xx redirect response"

	^self send3xxResponse: location code: statusCode do:[:resp].! !
!WebRequest methodsFor: 'responses' stamp: 'ar 7/23/2010 09:33' prior: 50891795!
  send3xxResponse: location code: statusCode do: aBlock
	"Send a 3xx redirect response"

	| resp url |
	"If the redirect is not to an absolute url, prefix it with the host if we have one"
	url := location.
	(location findString: '://') > 0 ifFalse:[
		(self headerAt: 'host') ifNotEmpty:[:host| url := 'http://', host, location]].

	resp := self newResponse protocol: 'HTTP/1.1' code: statusCode.
	resp headerAt: 'Location' put: url.
	aBlock value: resp.
	^self sendResponse: resp content: ''.
! !
!WebRequest methodsFor: 'responses' stamp: 'NR 6/23/2021 19:52:01' prior: 50891813!
                            send400Response
	"Send a 400 bad request response"

	| message |
	message := '<html><head><title>400 Bad Request</title></head><body>',
		'<h1>Bad Request</h1>
		<p>The server encountered a request it did not understand.
		</body></html>'.
	
	self sendResponseCode: 400 
		content: message asUtf8
		type: 'text/html; charset=utf-8'
		close: true! !
!WebRequest methodsFor: 'responses' stamp: 'NR 6/23/2021 21:16:45' prior: 50891827!
               send400Response: errorMessageText
	"Send a 400 bad request response"

	| message |
	message := '<html><head><title>400 Bad Request</title></head><body>',
		'<h1>400 Bad Request</h1>
		<p>', errorMessageText,
		'</p></body></html>'.
	
	self sendResponseCode: 400 
		content: message asUtf8
		type: 'text/html; charset=utf-8'
		close: true.! !
!WebRequest methodsFor: 'responses' stamp: 'NR 6/23/2021 19:50:46' prior: 50891840!
                      send404Response
	"Send a 404 not found response"
	
	^self send404Response: '<html><head><title>404 Not Found</title></head><body><h1>404 Not Found</h1><p>The requested URL ',self rawUrl,' was not found on this server.</p></body></html>'.
! !
!WebRequest methodsFor: 'responses' stamp: 'NR 6/23/2021 19:50:50' prior: 50891850!
                          send404Response: body
	"Send a 404 not found response"

	^self 
		send404Response: (body asUtf8) 
		do: [ :resp | resp headerAt: 'Content-Type' put: 'text/html; charset=utf-8' ]! !
!WebRequest methodsFor: 'responses' stamp: 'NR 6/23/2021 19:50:58' prior: 50891858!
                       send404Response: body do: aBlock
	"Send a 404 not found response"

	| resp |
	
	resp := self newResponse protocol: 'HTTP/1.1' code: 404.
	resp headerAt: 'Content-Type' put: 'text/html; charset=utf-8'.
	aBlock value: resp.
	^self sendResponse: resp content: body.
! !
!WebRequest methodsFor: 'responses' stamp: 'ar 5/11/2010 20:08' prior: 50891869!
    send405Response: allowed
	"Send a 405 method not allowed response"

	^self send405Response: allowed content: '<html><head><title>405 Method Not Allowed</title></head><body><h1>405 Method Not Allowed</h1><p>The requested method ',self method,' is not allowed for the URL', self rawUrl, '</p></body></html>'.! !
!WebRequest methodsFor: 'responses' stamp: 'ar 5/11/2010 20:08' prior: 50891881!
                         send405Response: allowed content: body
	"Send a 405 method not allowed response"
	| resp |
	resp := self newResponse protocol: 'HTTP/1.1' code: 405.
	resp headerAt: 'Content-Type' put: 'text/html; charset=utf-8'.
	resp headerAt: 'allow' put: (String streamContents:[:s|
		allowed do:[:m| s nextPutAll: m] separatedBy:[s nextPut: $,]
	]).
	^self sendResponse: resp content: body.! !
!WebRequest methodsFor: 'responses' stamp: 'jmv 5/19/2015 22:03' prior: 50891895!
                send500Response: errReport
	"Send a 500 internal server error response"

	| errLog |
	errLog := '<html><head><title>500 Internal Server Error</title></head><body>',
		'<h1>Internal Server Error</h1><pre>',
		(errReport  withLineEndings: String crlfString),
		'</pre></body></html>'.

	self sendResponseCode: 500
				content: errLog asUtf8
				type: 'text/html; charset=utf-8'
				close: true.
! !
!WebRequest methodsFor: 'responses' stamp: 'ar 5/11/2010 20:08' prior: 50891910!
  sendOptionsResponse: allowed
	"Send a 200 OK response for an OPTIONS request"

	^self send200Response: '' contentType: 'application/octet-stream' do:[:resp|
		resp headerAt: 'allow' put: (String streamContents:[:s|
			allowed do:[:m| s nextPutAll: m] separatedBy:[s nextPut: $,]
		]).
	].! !
!WebRequest methodsFor: 'responses' stamp: 'ar 8/31/2010 22:16' prior: 50891922!
           sendResponse: code chunked: chunkBlock
	"Send a chunked response"

	^self sendResponse: code chunked: chunkBlock do:[:resp]! !
!WebRequest methodsFor: 'responses' stamp: 'ar 8/31/2010 22:16' prior: 50891928!
                sendResponse: code chunked: chunkBlock do: hdrBlock
	"Send a chunked response"

	| resp |
	resp := self newResponse protocol: 'HTTP/1.1' code: code.
	resp headerAt: 'Transfer-Encoding' put: 'chunked'.
	hdrBlock value: resp.
	^self sendResponse: resp contentBlock:[:aStream|
		"Set the stream in the request and pass it in the chunk block"
		resp stream: aStream.
		chunkBlock value: resp.
		"send termination chunk"
		aStream nextPutAll: '0'; crlf; crlf; flush.
	].
! !
!WebRequest methodsFor: 'responses' stamp: 'ar 7/28/2010 20:22' prior: 50891945!
                         sendResponseCode: code content: aString type: contentType close: aBool
	"Send a 500 Internal server error response"

	^self sendResponseCode: code content: aString type: contentType do:[:hdr|
		aBool ifTrue:[hdr headerAt: 'Connection' put: 'close'].
	].! !
!WebRequest methodsFor: 'responses' stamp: 'ar 7/28/2010 20:19' prior: 50891956!
              sendResponseCode: code content: aString type: contentType do: aBlock
	"Send a 500 Internal server error response"

	| resp |
	resp := self newResponse protocol: 'HTTP/1.1' code: code.
	contentType ifNotNil:[resp headerAt: 'Content-Type' put: contentType].
	aBlock value: resp.
	^self sendResponse: resp content: aString.! !
!WebRequest methodsFor: 'responses' stamp: 'ar 5/11/2010 23:35' prior: 50891969!
           sendXmlResponse: xmlString
	"Send an a-ok 200 xml-ish response"

	^self send200Response: xmlString contentType: 'application/xml'! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 03:48' prior: 50891976!
          stream200Response: aStream
	"Stream a 200 OK response"

	^self stream200Response: aStream size: aStream size! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 03:53' prior: 50891982!
                               stream200Response: aStream size: streamSize
	"Stream a 200 OK response"

	^self stream200Response: aStream size: streamSize type: 'application/octet-stream'! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 03:53' prior: 50891990!
               stream200Response: aStream size: streamSize type: contentType
	"Stream a 200 OK response"

	^self stream200Response: aStream size: streamSize type: contentType do:[:resp].! !
!WebRequest methodsFor: 'responses' stamp: 'ar 2/25/2010 18:14' prior: 50891998!
stream200Response: aStream size: streamSize type: contentType do: aBlock
	"Stream a 200 OK response"

	| resp |
	resp := self newResponse protocol: 'HTTP/1.1' code: 200.
	resp headerAt: 'Content-Type' put: contentType.
	aBlock value: resp.
	^self sendResponse: resp contentStream: aStream size: streamSize.! !
!WebRequest methodsFor: 'printing' stamp: 'CK 11/24/2017 14:53:04' prior: 50892011 overrides: 50346596!
  writeOn: aStream
	"Write the request"

	self writeRequestOn: aStream.
	super writeOn: aStream! !
!WebRequest methodsFor: 'printing' stamp: 'DSG 5/24/2012 17:37' prior: 50892017!
              writeRequestOn: aStream
	"Write the request"

	aStream nextPutAll: method; space; nextPutAll: rawUrl; space; nextPutAll: protocol; nextPutAll: String crlfString.
! !
!WebRequest class methodsFor: 'instance creation' stamp: 'ar 2/20/2010 11:23' prior: 50892026 overrides: 16882927!
       readFrom: aStream
	"Create a WebRequest from a given stream"

	^self new readFrom: aStream! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 2/20/2010 10:39' prior: 50892031!
                code
	"The HTTP response code"

	^code! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 6/18/2010 23:51' prior: 50892035 overrides: 50346837!
                content
	"Reimplemented to close the socket if the request is transient"

	content ifNil:[
		content := self getContent.
		self closeIfTransient.
	].
	^content! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 1/31/2012 14:02' prior: 50892043 overrides: 50346864!
                       contentStream
	"Answers a stream for the conent."

	(self headerAt: 'transfer-encoding') = 'chunked' ifTrue:[
		^WebChunkedStream on: stream.
	].
	^super contentStream! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 4/1/2010 16:02' prior: 50892051!
    request
	"The original request for this response"

	^request! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 4/1/2010 16:03' prior: 50892056!
               request: aRequest
	"The original request for this response"

	request := aRequest! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 2/20/2010 10:39' prior: 50892061!
                         status
	"The status line from the response"

	^status! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 2/20/2010 10:39' prior: 50892065!
                     status: aString
	"The status line from the response"

	status := aString! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 8/24/2010 21:37' prior: 50892070!
  url
	"The url of the resource at which a request was terminated after a series
	of redirects. Without redirects, this will be the same as the request url."

	^url! !
!WebResponse methodsFor: 'accessing' stamp: 'ar 8/24/2010 21:37' prior: 50892078!
        url: urlString
	"The url of the resource at which a request was terminated after a series
	of redirects. Without redirects, this will be the same as the request url."

	url := urlString! !
!WebResponse methodsFor: 'private' stamp: 'topa 4/3/2013 17:32' prior: 50892087 overrides: 50346933!
                              getContent
	"Do not read any content if this was a HEAD request or code is 204 (no content)"
	(request method = 'HEAD' or: [code = 204]) ifTrue:[^''].
	^super getContent! !
!WebResponse methodsFor: 'testing' stamp: 'ar 7/9/2010 00:27' prior: 50892095!
    isInformational
	"Is this a 1xx response?"

	^self code between: 100 and: 199
! !
!WebResponse methodsFor: 'testing' stamp: 'ar 8/10/2010 08:56' prior: 50892100!
                              isRedirect
	"Is this a redirect response?"

	^self code between: 300 and: 399
! !
!WebResponse methodsFor: 'testing' stamp: 'ar 2/23/2010 10:13' prior: 50892105!
                              isSuccess
	"Is this a successful response?"

	^self code between: 200 and: 299
! !
!WebResponse methodsFor: 'initialize' stamp: 'SvenVanCaekenberghe 6/14/2010 15:48' prior: 50892111!
         protocol: respProtocol code: respCode
	"Initialize a response from protocol and code"

	code := respCode.
	protocol := respProtocol.
	status := protocol, ' ', code asString, ' ', (self class statusCodeAt: code).
	headers := OrderedCollection new.! !
!WebResponse methodsFor: 'initialize' stamp: 'jmv 6/25/2017 19:15:56' prior: 50892122!
               readFrom: aStream
	"Parse an HTTP response from the given stream"

	| tokens |
	stream := aStream.
	status := stream upToAll: String crlfString.
	tokens := status findTokens: ' '.
	tokens size < 2 ifTrue:[^self error:'Invalid response: ', status].
	protocol := tokens first.
	code := tokens second asNumber.
	headers := WebUtils readHeadersFrom: stream.
! !
!WebResponse methodsFor: 'cookies' stamp: 'ar 2/20/2010 19:35' prior: 50892136!
          setCookie: aCookie
	"Adds a Set-Cookie header"

	^self addHeader: 'Set-Cookie' value: aCookie asString! !
!WebResponse methodsFor: 'cookies' stamp: 'ar 2/20/2010 19:35' prior: 50892142!
      setCookie: name value: value path: path 
	"Adds a Set-Cookie header"

	^self setCookie: ((WebCookie new)
			name: name;
			value: value;
			path: path;
		yourself)! !
!WebResponse methodsFor: 'cookies' stamp: 'ar 2/20/2010 19:35' prior: 50892150!
         setCookie: name value: value path: path expires: date domain: domain secure: aBool
	"Adds a Set-Cookie header"

	^self setCookie: ((WebCookie new)
			name: name;
			value: value;
			path: path;
			expiry: date;
			domain: domain;
			secure: aBool;
		yourself)! !
!WebResponse methodsFor: 'cookies' stamp: 'ar 2/25/2010 18:16' prior: 50892161!
         setCookieAt: key
	"Evaluate aBlock with all the cookies deined in the request"

	self setCookiesDo:[:cookie|
		cookie name = key ifTrue:[^cookie].
	].
	^nil! !
!WebResponse methodsFor: 'cookies' stamp: 'ar 2/21/2010 09:51' prior: 50892168!
                setCookiesDo: aBlock
	"Evaluate aBlock with all the cookies deined in the request"

	self headersAt: 'Set-Cookie' do:[:hdr|
		aBlock value: (WebCookie new readFrom: hdr readStream)
	].
! !
!WebResponse methodsFor: 'printing' stamp: 'ar 2/20/2010 16:33' prior: 50892177 overrides: 50346596!
                              writeOn: aStream
	"Store this response on aStream"

	self writeStatusOn: aStream.
	super writeOn: aStream.
! !
!WebResponse methodsFor: 'printing' stamp: 'DSG 5/24/2012 17:39' prior: 50892183!
                               writeStatusOn: aStream
	"Store this response on aStream"

	aStream nextPutAll: status; nextPutAll: String crlfString.
! !
!WebResponse class methodsFor: 'instance creation' stamp: 'ar 2/20/2010 11:24' prior: 50892190!
      protocol: protocol code: code
	"Create a response using the given protocol / code"

	^self new protocol: protocol code: code! !
!WebServer methodsFor: 'logging' stamp: 'ar 7/28/2010 19:56' prior: 50892196!
                  accessLog
	"The standard access log. Can be either a stream or a string; if the access log
	is a string then the string is assumed to be a file name and the file will be opened 
	and closed for each request."

	^accessLog! !
!WebServer methodsFor: 'logging' stamp: 'ar 7/28/2010 19:56' prior: 50892205!
                 accessLog: aStreamOrFilename
	"The standard access log. Can be either a stream or a string; if the access log
	is a string then the string is assumed to be a file name and the file will be opened 
	and closed for each request."

	accessLog := aStreamOrFilename! !
!WebServer methodsFor: 'logging' stamp: 'ar 7/28/2010 20:02' prior: 50892216!
          logRequest: request response: response
	"Log a request after it has been successfully processed"

	accessLog ifNil:[^self].

	"Do not use the standard exception handler for errors logging; 
	it would possibly send a 500 response. Really this should be handled
	by a different process with its own error handler."

	[WebUtils logRequest: request response: response on: accessLog]
		on: Error do:[:ex| self log: 'Error in logging: ', ex description].
! !
!WebServer methodsFor: 'services' stamp: 'ar 5/11/2010 20:10' prior: 50892233!
            addService: entryPoint action: aBlockOrMessage
	"Add a service to the web server. The service is specified by an entryPoint, 
	denoting the url under which the service can be requested 
	(such as /my/great/service) and an action which is a message 
	send taking a single argument, the WebRequest."

	^self addService: entryPoint 
		action: aBlockOrMessage 
		methods: self defaultHttpMethods.! !
!WebServer methodsFor: 'services' stamp: 'ar 5/11/2010 20:10' prior: 50892248!
     addService: entryPoint action: aBlockOrMessage methods: methods
	"Add a service to the web server. The service is specified by an entryPoint, 
	denoting the url under which the service can be requested 
	(such as /my/great/service) and an action which is a message 
	send taking a single argument, the WebRequest.
	
	The list of methods describes what HTTP methods the given url supports."

	mutex critical:[
		entryPoints at: entryPoint asLowercase put: {methods. aBlockOrMessage}.
	].! !
!WebServer methodsFor: 'services' stamp: 'ar 2/22/2010 02:52' prior: 50892266!
       removeService: entryPoint 
	"Remove a service from the HTTP service provider.  See #addService:action:"

	mutex critical:[
		entryPoints removeKey: entryPoint asLowercase ifAbsent: [].
	].! !
!WebServer methodsFor: 'handling' stamp: 'ul 7/3/2014 23:56' prior: 50892274!
                  asyncHandleConnectionFrom: aSocket
	"Handle an incoming connection asynchronously to avoid blocking the listener."

	| handlerProcess |
	handlerProcess := [
		[ [ self handleConnectionFrom: aSocket ] 
			on: Error do: [ :ex | aSocket destroy ] ]
			ensure: [
				aSocket destroy.
				mutex critical: [ 
					"If we get here, then handlerProcess is initialized, so it's safe to use that variable. Using Processor activeProcess is not possible, because this block may be evaluated by another process. Doing this outside the #ensure: block is not safe."
					connections remove: handlerProcess ifAbsent: [ ] ] ] ] newProcess.

	mutex critical:[connections add: handlerProcess].

	handlerProcess resume.
! !
!WebServer methodsFor: 'handling' stamp: 'ar 2/23/2010 22:34' prior: 50892298!
                 dispatchRequest: request
	"Look up the handler for a given request and dispatch to it"

	^self dispatchRequest: request url: request url! !
!WebServer methodsFor: 'handling' stamp: 'HAW 5/6/2020 09:47:55' prior: 50892305!
  dispatchRequest: request url: dispatchUrl
	"Look up the handler for a given url and dispatch to it"

	| entryUrl action |
	"Handle TRACE requests right away"
	request method = 'TRACE' ifTrue:[
		^request send200Response: request asString contentType: 'message/http'.
	].

	"Look up the entry point for the request"
	action := nil.
	entryUrl := dispatchUrl asLowercase.
	(entryUrl beginsWith: '/') ifFalse:[entryUrl := '/', entryUrl].
	mutex critical:[
		[entryUrl notEmpty and:[action == nil]] whileTrue: [
			action := entryPoints at: entryUrl ifAbsent:[nil].
			entryUrl := entryUrl copyUpToLast: $/.
		].
		action ifNil:[action := entryPoints at: '/' ifAbsent:[nil]].
	].

	"Handle OPTIONS requests"
	request method = 'OPTIONS' ifTrue:[
		"HEAD, TRACE, and OPTIONS are always supported"
		request sendOptionsResponse: self builtinHttpMethods,
			(action ifNil:[self defaultHttpMethods] ifNotNil:[action first])
	].

	"Handle 404 not found"
	action ifNil:[^request send404Response].

	"Handle 405 method not allowed"
	(request method = 'HEAD' "builtin" 
		or:[(action at: 1) includes: request method]) ifFalse:[
			^request send405Response: self builtinHttpMethods, action first.
		].

	^[self invokeAction: (action at: 2) request: request] 
		on: Error 
		do:[:ex|
			errorHandler 
				ifNil:[self handleError: ex request: request]
				ifNotNil:[errorHandler value: ex value: request]].
! !
!WebServer methodsFor: 'handling' stamp: 'ar 7/29/2010 18:46' prior: 50892351!
                               handleConnectionFrom: aSocket
	"Synchronously handle an incoming socket connection."

	| stream request |

	"Give the process a pretty name"
	Processor activeProcess name: (String streamContents:[:s|
		aSocket remoteAddress do:[:b| s print: b] separatedBy:[s nextPut: $.].
		s nextPut: $:; print: aSocket remotePort.
		s nextPutAll: ' - ', self class name, ' request handler'.
	]).

	"Read the request from the socket, and dispatch it.
	Since we've been forked already it's okay to block."
	[
		certName ifNil:["Regular request"
			stream := SocketStream on: aSocket.
		] ifNotNil:["SSL/TLS"
			| ssl |
			ssl := Smalltalk at: #SqueakSSL ifAbsent:[self error: 'SqueakSSL not installed'].
			stream := ssl secureSocketStream on: aSocket.
			[stream sslAccept: certName] on: Error do:[^stream destroy].
		].

		[aSocket isConnected] whileTrue:[

			"Read the next request from the connection. If the connection is closed,
			or if a network error occurs, or the read times out, just close the connection
			without further ado (rather than logging an error). Any other error resulting
			from parsing the input is treated as a 400 bad request."

			stream peek ifNil:[^aSocket destroy].
			request := self newRequest.
			[request readFrom: stream] on: Error do:[:ex| 
				(ex isKindOf: NetworkError) ifFalse:[
					[request send400Response] on: Error do:[:ignore].
				].
				^aSocket destroy].

			self dispatchRequest: request.
		].
	] on: Error do:[:ex|
		(ex isKindOf: NetworkError) ifFalse:[
			self log: 'Error in request handling: ', ex description.
			self log: (self errorReportFor: ex).
		].
	].! !
!WebServer methodsFor: 'handling' stamp: 'ar 2/20/2010 14:30' prior: 50892404!
          invokeAction: action request: request
	"Invokes the given action. Subclasses can override this method to serialize
	actions if necessary. At this point, the request header has been read from
	the network, but not its content."

	^action valueWithArguments: {request}
! !
!WebServer methodsFor: 'handling' stamp: 'ar 7/28/2010 20:27' prior: 50892415!
  newRequest
	"Answer a new request.
	Subclasses should override this method to use a different request class."

	^(WebRequest new)
		server: self;
		yourself! !
!WebServer methodsFor: 'authentication' stamp: 'ar 3/30/2010 20:43' prior: 50892423!
           authAccept: method request: request realm: realm header: authHeader
	"Performs the requested authentication method. 
	Returns true if successfully authenticated.
	Subclasses can extend this method to support more auth methods."

	^method asLowercase caseOf: {
		['basic'] 	-> [self basicAuth: request realm: realm header: authHeader].
		['digest'] 	-> [self digestAuth: request realm: realm header: authHeader].
	} otherwise:[false].
! !
!WebServer methodsFor: 'authentication' stamp: 'ar 3/30/2010 20:43' prior: 50892439!
                     authHeader: method request: request realm: realm
	"Answer the authentication header for the given method.
	Subclasses can extend this method to support more auth methods."

	^method asLowercase caseOf: {
		['basic'] 	-> ['Basic realm="', realm,'"'].
		['digest'] 	-> ['Digest realm="', realm,'", nonce="', self newNonce,'", qop="auth"'].
	} otherwise:[nil].
	
	! !
!WebServer methodsFor: 'authentication' stamp: 'ar 3/30/2010 20:43' prior: 50892453!
                              authenticate: request realm: realm methods: accepted do: aBlock
	"Authenticates an incoming request using one of the accepted methods.

	Evaluates aBlock upon successful authentication. Responds with a 401
	(Unauthorized) if the authentication fails."

	| method resp |
	request headersAt: 'Authorization' do:[:authHeader|
		method := authHeader copyUpTo: Character space.
		(accepted anySatisfy:[:auth| auth sameAs: method]) ifTrue:[
			(self authAccept: method request: request realm: realm header: authHeader)
				ifTrue:[^aBlock value].
		].
	].

	"Send a 401 (unauthorized) response"
	resp := request newResponse protocol: 'HTTP/1.1' code: 401.
	resp headerAt: 'Content-Type' put: 'text/html; charset=utf-8'.
	accepted do:[:auth| | hdr |
		hdr := self authHeader: auth request: request realm: realm.
		hdr ifNotNil:[resp addHeader: 'WWW-Authenticate' value: hdr].
	].
	request sendResponse: resp content: '<html><head><title>401 Unauthorized</title></head><body><h1>401 Unauthorized</h1><p>You are not authorized to access the requested URL</p></body></html>'.
! !
!WebServer methodsFor: 'authentication' stamp: 'jmv 6/25/2017 20:42:21' prior: 50892489!
                         basicAuth: request realm: realm header: authHeader
	"Perform Basic auth for the given request"

	| data user pass hash |
	data := String fromUtf8: (authHeader copyAfter: $ ) base64Decoded.
	user := data copyUpTo: $:.
	pass := data copyAfter: $:.
	data atAllPut: $*. data := nil.

	hash := self hashUser: user password: pass realm: realm.
	pass atAllPut: $*. pass := nil.

	^(self passwordHashAt: user, ':', realm) = hash
! !
!WebServer methodsFor: 'authentication' stamp: 'jmv 6/25/2017 19:16:08' prior: 50892505!
                              digestAuth: request realm: realm header: authHeader
	"Authenticates an incoming request using Digest auth."

	| user nonce uri response ha1 ha2 md5 qop nc cnonce 
	  nonceData nonceCounter nonceTimeout params |

	params := WebUtils parseAuthParams: authHeader.

	"Flush the nonce cache randomly about every 100 auth attempts"
	100 atRandom = 42 ifTrue:[self flushNonceCache].

	user := params at: 'username' ifAbsent:[''].
	nonce := params at: 'nonce' ifAbsent:[''].
	uri := params at: 'uri' ifAbsent:[request url].
	response := params at: 'response' ifAbsent:[''].
	
	qop := params at: 'qop' ifAbsent:[''].
	qop = 'auth' ifFalse:[^false]. "we require qop=auth"

	nc := params at: 'nc' ifAbsent:[''].
	cnonce := params at: 'cnonce' ifAbsent:[''].
	
	"Verify that this is a nonce that we have handed out, that it isn't expired
	and that the nc counter has increased from the last use."
	mutex critical:[
		nonceData := nonceCache at: nonce ifAbsent:[^false].
	].
	nonceCounter := nonceData first.		"last used nc"
	nonceTimeout := nonceData second.	"timeout for nonce"
	nc <= nonceCounter ifTrue:[^false]. 	"nc must increase"
	Time localSecondClock > nonceTimeout ifTrue:[^false]. "nonce expired"
	nonceData at: 1 put: nc.

	ha1 := self passwordHashAt: user, ':', realm.
	ha2 := WebUtils md5Digest: request method, ':', uri.
	md5 := WebUtils md5Digest: ha1, ':', nonce, ':', nc, ':', cnonce, ':', qop, ':', ha2.
	^md5 = response
! !
!WebServer methodsFor: 'authentication' stamp: 'DSG 12/5/2013 17:11' prior: 50892552!
                   flushNonceCache
	"Flushes expired nonces from the cache"

	| deadline |
	deadline := Time localSecondClock.
	mutex critical:[
		nonceCache := nonceCache reject:[:nonceData| deadline > nonceData second]
	].
! !
!WebServer methodsFor: 'authentication' stamp: 'ar 3/30/2010 20:36' prior: 50892561!
                         hashUser: user password: pass realm: realm
	"Creates a hash for the given username password pair.
	This method is the ha1 part of digest auth and can be used for both digest
	as well as basic auth."

	^WebUtils md5Digest: user, ':', realm, ':', pass! !
!WebServer methodsFor: 'authentication' stamp: 'DSG 12/5/2013 17:12' prior: 50892572!
             newNonce
	"Create a new nonce to be used for a client authentication session"

	| nonce |
	nonce := UUID new hex.
	mutex critical:[
		nonceCache at: nonce put: {''. Time localSecondClock + self nonceDeadline}.
	].
	^nonce! !
!WebServer methodsFor: 'authentication' stamp: 'ar 2/23/2010 09:20' prior: 50892582!
          nonceDeadline
	"Answer the number of seconds a nonce is considered valid for digest auth
	by the server. After this period, the client will have to reauthenticate.
	The default is 30 minutes."

	^30*60 ! !
!WebServer methodsFor: 'authentication' stamp: 'ar 2/20/2010 12:54' prior: 50892591!
                             passwordAt: username realm: realm put: password
	"Store the password hash for the key."

	| hash |
	hash := self hashUser: username password: password realm: realm.
	self passwordHashAt: (username,':',realm) put: hash! !
!WebServer methodsFor: 'authentication' stamp: 'ar 2/20/2010 12:51' prior: 50892601!
              passwordHashAt: key
	"Answer the password hash for the given key"

	^vault at: key ifAbsent:['']! !
!WebServer methodsFor: 'authentication' stamp: 'ar 2/20/2010 12:01' prior: 50892607!
       passwordHashAt: key put: hash
	"Store the password hash for the key."

	^vault at: key put: hash! !
!WebServer methodsFor: 'initialize' stamp: 'ar 5/11/2010 20:10' prior: 50892613!
           builtinHttpMethods
	"Returns the list of HTTP methods that the server handles built-in,
	i.e., without passing them to the registered service."

	^#('HEAD' 'TRACE' 'OPTIONS')! !
!WebServer methodsFor: 'initialize' stamp: 'ar 2/23/2010 12:10' prior: 50892621!
                             critical: aBlock
	"Evaluate aBlock protected byt the server's mutex.
	Necessary if code needs to manipulate internal server state."

	^mutex critical: aBlock
! !
!WebServer methodsFor: 'initialize' stamp: 'ar 5/11/2010 20:10' prior: 50892629!
             defaultHttpMethods
	"Answer the list of HTTP methods that should be be supported by default.
	The methods must be implemented by the request handler."

	^#('GET' 'POST')! !
!WebServer methodsFor: 'initialize' stamp: 'ar 11/1/2010 21:07' prior: 50892637!
  destroy
	"Destroys the receiver"

	self stopListener.
	self destroyConnections.
	listenerSocket ifNotNil:[listenerSocket destroy].

	"De-register the WebServer"
	(self class forUrl: self siteUrl ifAbsent:[self]) == self 
		ifTrue:[self class removeUrl: siteUrl]
! !
!WebServer methodsFor: 'initialize' stamp: 'ul 10/16/2014 13:16' prior: 50892648!
    destroyConnections
	"Destroy all current connections."

	| copy |
	copy := mutex critical: [ connections copy ].
	" #terminate will trigger the #ensure: block in #asyncHandleConnectionFrom:, which will block if we don't release the mutex "
	copy do: [ :p | p terminate ].
	" make sure all of them were really removed "
	mutex critical: [ connections removeAll ]
! !
!WebServer methodsFor: 'initialize' stamp: 'DSG 3/28/2015 20:16' prior: 50892663 overrides: 16896425!
            initialize
	"Initialize the receiver"

	mutex := Mutex new.
	entryPoints := Dictionary new.
	connections := IdentitySet new.
	vault := Dictionary new.
	nonceCache := Dictionary new.
	sessions := Dictionary new.
	self logAction:[:aString| Transcript log: aString].
! !
!WebServer methodsFor: 'initialize' stamp: 'ar 2/22/2010 05:35' prior: 50892674!
   log: aString
	"Log the given information."

	logAction ifNotNil:[logAction valueWithArguments: {aString}].
! !
!WebServer methodsFor: 'accessing' stamp: 'ar 7/29/2010 18:49' prior: 50892680!
 certName
	"The cert name to use for a secure (SSL/TLS) web server."

	^certName! !
!WebServer methodsFor: 'accessing' stamp: 'ar 7/29/2010 18:49' prior: 50892685!
                             certName: aString
	"The cert name to use for a secure (SSL/TLS) web server."

	certName := aString.! !
!WebServer methodsFor: 'accessing' stamp: 'ar 5/11/2010 20:22' prior: 50892691!
         connections
	"The active connection processes. Can only be examined after aquiring
	the WebServer's mutex."

	^connections! !
!WebServer methodsFor: 'accessing' stamp: 'ar 7/28/2010 20:24' prior: 50892697!
                  errorHandler
	"The user-supplied error handler. If present the handler takes two arguments:
		* The error being caught by WebServer
		* The request the error occurred in.
	The user-supplied error handler can do whatever it wants, including calling
	WebServer's #handleError:request: method which is the default."

	^errorHandler! !
!WebServer methodsFor: 'accessing' stamp: 'ar 7/28/2010 20:24' prior: 50892710!
    errorHandler: aBlock
	"The user-supplied error handler. If present the handler takes two arguments:
		* The error being caught by WebServer
		* The request the error occurred in.
	The user-supplied error handler can do whatever it wants, including calling
	WebServer's #handleError:request: method which is the default."

	errorHandler := aBlock.! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:01' prior: 50892723!
                  listenerInterface
	"Returns the listener interface for the server"

	^interface! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:01' prior: 50892728!
                             listenerPort
	"Returns the listener port for the server"

	^port! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:00' prior: 50892733!
            listenerProcess
	"Returns the socket listener process for the server."

	^listenerProcess! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/22/2010 03:00' prior: 50892738!
                   listenerSocket
	"Returns the listener socket for the server."

	^listenerSocket! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/22/2010 05:35' prior: 50892743!
                             logAction
	"The current log action (a block or message)"

	^logAction! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/22/2010 05:36' prior: 50892748!
       logAction: aBlockOrMessage
	"The current log action (a block or message).
	Example:
		WebServer new logAction: [:aString| Transcript show: aString].
		WebServer new logAction: (MessageSend receiver: Transcript selector: #show).
	"

	logAction := aBlockOrMessage! !
!WebServer methodsFor: 'accessing' stamp: 'ar 6/14/2010 20:53' prior: 50892759!
       serverDate
	"Returns the date string to be used in responses"

	^self class serverDate! !
!WebServer methodsFor: 'accessing' stamp: 'ar 6/14/2010 20:54' prior: 50892764!
                      serverString
	"Returns the server string to be used in responses.
	The response is cached for efficiency."

	^serverString ifNil:[serverString := self class serverString].! !
!WebServer methodsFor: 'accessing' stamp: 'ar 6/14/2010 20:57' prior: 50892772!
 serverString: aString
	"Set the server string to be used in responses"

	^serverString := aString! !
!WebServer methodsFor: 'accessing' stamp: 'ar 11/1/2010 21:01' prior: 50892778!
           siteUrl
	"The site URL for WebServer, i.e., http://www.mysite.com or http://www.mysite.com/server (when used in a proxied environment) or https://www.mysite.com (when using SSL). Used to allow a client to derive the 'correct' full URL for a running server instance."

	^siteUrl! !
!WebServer methodsFor: 'accessing' stamp: 'ar 11/1/2010 21:13' prior: 50892789!
                       siteUrl: aString
	"The site URL for WebServer, i.e., http://www.mysite.com or http://www.mysite.com/server (when used in a proxied environment) or https://www.mysite.com (when using SSL). Used to allow a client to derive the 'correct' full URL for a running server instance."

	siteUrl := aString! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/20/2010 12:03' prior: 50892801!
    vault
	"The vault used for storing password hashes."

	^vault! !
!WebServer methodsFor: 'accessing' stamp: 'ar 2/22/2010 02:51' prior: 50892806!
               vault: anObject
	"The vault used for storing password hashes.

	Clients can provide their own storage mechanism. 
	Subclasses can also override the lookup and authentication mechanism."

	vault := anObject! !
!WebServer methodsFor: 'errors' stamp: 'HAW 5/6/2020 12:06:30' prior: 50892815!
                               debugErrorHandler

	^[:anException :aRequest | 
		[nil handleSignal: anException ] 
			on: UnhandledError 
			do: [ :unhandledError | nil handleSignal: unhandledError ]]! !
!WebServer methodsFor: 'errors' stamp: 'ar 2/20/2010 10:35' prior: 50892823!
      errorReportFor: anError
	"Provide a report for an error that's been caught during processing"

	^[
		String streamContents:[:s| 
			self errorReportFor: anError 
				stack: ([anError signalerContext stackOfSize: 2000] 
							on: Error do:[:ex| ex return: #()])
				on: s
		].
	] on: Error do: [:ex| ex pass. 'error reporting failed'].! !
!WebServer methodsFor: 'errors' stamp: 'jmv 5/19/2015 21:55' prior: 50892836!
                               errorReportFor: anError stack: preStack on: strm
	"Provide a report for an error that's been caught during processing"

	self errorStackFor: anError stack: preStack on: strm.
	strm newLine; nextPutAll: '-----------------------------------------------------------------'; newLine; newLine.
	self systemInfoOn: strm.
! !
!WebServer methodsFor: 'errors' stamp: 'jmv 5/19/2015 21:55' prior: 50892848!
                   errorStackFor: anError stack: preStack on: strm
	"Provide a report for an error that's been caught during processing"

	| cnt |
	cnt := 0.
	(preStack copyFrom: 1 to: (5 min: preStack size)) do:[:ctx|
		ctx printDetails: strm.	"variable values"
		strm newLine.
	].

	strm newLine; nextPutAll: '--- The full stack ---'; newLine.
	cnt := 0.

	preStack do:[:ctx|
		cnt := cnt + 1.
		cnt = 5 ifTrue: [
			strm nextPutAll: ' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'; newLine].
		strm print: ctx; newLine.  "just class>>selector"
	].
! !
!WebServer methodsFor: 'errors' stamp: 'jmv 5/19/2015 23:48' prior: 50892868!
     handleError: ex request: aRequest
	"The default error handling during processing. Sends a 500 response."

	| errLabel errReport |
	errLabel := [ex description] on: Error do:[:ex2| 
		ex2 return: ex class name
	].
	errReport := [self errorReportFor: ex] on: Error do:[:ex2|
		ex2 return: '<error report failed>'.
	].
	[self log: errLabel] on: Error do:[:ex2| ex return].
	[self log: String newLineString, errReport] on: Error do:[:ex2| ex return].
	aRequest send500Response: errReport. ! !
!WebServer methodsFor: 'errors' stamp: 'jmv 6/25/2017 19:16:01' prior: 50892886!
      systemInfoOn: strm
	"Provides system information for a server error report"
	| info |
	strm nextPutAll: 'VM: ';
		nextPutAll:  WebUtils platformName;
		nextPutAll: ' - ';
		nextPutAll: WebUtils vmVersion;
		newLine.

	strm nextPutAll: 'Image: ';
		nextPutAll:  SystemVersion current version asString;
		nextPutAll: ' [';
		nextPutAll: Smalltalk lastUpdateString asString;
		nextPutAll: ']';
		newLine.

	strm newLine.

	"SecurityManager default printStateOn: strm."

	"Additional info available from the windows VM"
	WebUtils platformName = 'Win32' ifTrue:[
		10001 to: 10003 do: [ :i |
			info := (Smalltalk getSystemAttribute: i) ifNil:[''].
			info isEmpty ifFalse:[strm newLine; nextPutAll: info]]]! !
!WebServer methodsFor: 'errors' stamp: 'HAW 5/6/2020 12:06:46' prior: 50892911!
              useDebugErrorHandler

	self errorHandler: self debugErrorHandler ! !
!WebServer methodsFor: 'testing' stamp: 'ar 3/30/2010 22:09' prior: 50892916!
             isRunning
	"Is the server still running?"

	^self isStopped not! !
!WebServer methodsFor: 'testing' stamp: 'ar 3/30/2010 22:09' prior: 50892921!
               isStopped
	"Is the server still running?"

	^listenerProcess == nil or:[listenerProcess isTerminated]! !
!WebServer methodsFor: 'listening' stamp: 'ar 2/20/2010 10:27' prior: 50892927!
       listenOn: aPort
	"Starts the server listening on the given port"

	^self listenOn: aPort interface: nil! !
!WebServer methodsFor: 'listening' stamp: 'ar 2/20/2010 10:28' prior: 50892933!
     listenOn: aPort interface: anInterface
	"Starts the server listening on the given port / network interface"

	^self listenOn: aPort interface: anInterface backlogSize: 8! !
!WebServer methodsFor: 'listening' stamp: 'SvenVanCaekenberghe 6/14/2010 15:48' prior: 50892941!
                  listenOn: aPort interface: anInterface backlogSize: backlog
	"Starts the server listening on the given port / network interface"
	
	| ipString |
	interface := anInterface.
	port := aPort.
	ipString := interface ifNil:['*'] ifNotNil:[
		String streamContents:[:s| interface do:[:b| s print: b] separatedBy:[s nextPut:$.]]].
	self log: 'listener starting (interface: ', ipString, ' port: ', port asString, ')'.
	listenerSocket := Socket newTCP.
	interface 
		ifNil:[listenerSocket listenOn: port backlogSize: backlog]
		ifNotNil:[listenerSocket listenOn: port backlogSize: backlog interface: interface].
	listenerSocket isWaitingForConnection ifFalse:[
		self error: 'Failed to listen(interface: ', interface printString, ' port: ', aPort printString,' )'.
	].
	self startListener.! !
!WebServer methodsFor: 'listening' stamp: 'ar 2/20/2010 10:28' prior: 50892968!
 listenerProcessPriority
	"The priority at which the listener process should run"

	^Processor lowIOPriority! !
!WebServer methodsFor: 'listening' stamp: 'ar 5/4/2010 09:22' prior: 50892974!
  runListener
	"Runs the server's listener loop. 
	Accepts incoming connections and handles them asynchronously"

	| connectionSocket |
	[[[listenerSocket notNil and:[listenerSocket isValid]] whileTrue:[
		"Waiting for five seconds means that WebServer will be
		back up after roughly five seconds when the system restarts."
		connectionSocket := listenerSocket waitForAcceptFor: 5.
		"Fork this off since or else errors in acceptClient: kill the listener"
		connectionSocket ifNotNil:[self asyncHandleConnectionFrom: connectionSocket].
	]] ensure:[
		"Logging here is only for the purpose of catching sockets going randomly bad"
		self log: 'listener terminating, socket: ', (listenerSocket ifNotNil:[:s| s statusString]).

		"Try to restart the listener"
		(listenerSocket notNil and:[listenerSocket isValid not]) ifTrue:[
			listenerSocket destroy.
			listenerProcess := nil.
			"Wait a little before retrying"
			(Delay forSeconds: 2) wait.
			^self listenOn: port interface: interface
		].
	]] on: Error do:[:ex| self log: ex].
! !
!WebServer methodsFor: 'listening' stamp: 'ar 2/20/2010 10:29' prior: 50893009!
     startListener
	"Starts the server's listener process"

	self stopListener.
	listenerProcess := [self runListener] newProcess.
	listenerProcess priority: self listenerProcessPriority.
	listenerProcess name: self class name, '''s listener process'.
	listenerProcess resume.
! !
!WebServer methodsFor: 'listening' stamp: 'ar 2/20/2010 10:29' prior: 50893020!
                            stopListener
	"Stops the server's listener process"

	listenerProcess ifNotNil:[listenerProcess terminate].
	listenerProcess := nil.! !
!WebServer methodsFor: 'sessions' stamp: 'ar 2/23/2010 12:09' prior: 50893027!
         sessionAt: key
	"Answer the session associated with the given key"

	^mutex critical:[sessions at: key ifAbsent:[nil]].! !
!WebServer methodsFor: 'sessions' stamp: 'ar 2/23/2010 12:10' prior: 50893033!
                      sessionAt: key ifAbsentPut: session
	"Answer the session associated with the given key"

	^mutex critical:[sessions at: key ifAbsentPut:[session]].! !
!WebServer methodsFor: 'sessions' stamp: 'ar 5/11/2010 23:34' prior: 50893040!
                          sessionAt: key put: session
	"Store the session associated with the given key"

	^mutex critical:[sessions at: key put: session].! !
!WebServer methodsFor: 'sessions' stamp: 'ar 2/23/2010 12:11' prior: 50893047!
            sessions
	"The sessions associated with the WebServer. These are not used by the server
	directly but rather provided so that client code has a convenient place to store
	session data."
	
	^sessions! !
!WebServer methodsFor: 'sessions' stamp: 'ar 2/23/2010 12:11' prior: 50893056!
       sessions: aDictionary
	"The sessions associated with the WebServer. These are not used by the server
	directly but rather provided so that client code has a convenient place to store
	session data."
	
	sessions := aDictionary! !
!WebServer class methodsFor: 'benchmarks' stamp: 'jmv 6/26/2017 19:12:52' prior: 50893066!
benchmark
	"Runs a WebClient/WebServer streaming benchmark to measure throughput"

	"
		WebServer benchmark
		MessageTally spyOn:[WebServer benchmark]
	"

	| amount time resp port |
	port := 8888.
	amount := 128 * 1024 * 1024.
	WebServer reset default listenOn: port.
	WebServer default addService: '/streaming' action:[:req|
		req stream200Response: DummyStream new size: amount.
	].
	time := [
		resp := WebClient httpGet: 'http://localhost:', port, '/streaming'.
		resp isSuccess ifFalse:[self error: resp status].
		resp streamTo: DummyStream new size: resp contentLength progress: nil.
		resp close.
	] timeToRun.
	WebServer reset.
	^(amount  * 1000 // time) printStringWithCommas, ' bytes/sec'
! !
!WebServer class methodsFor: 'benchmarks' stamp: 'ar 5/4/2010 21:27' prior: 50893091!
          requestBenchmark: persistent
	"Runs a WebClient/WebServer benchmark to measure request handling speed.
	Uses a persistent connection if requested."

	"
		WebServer requestBenchmark: false.
		WebServer requestBenchmark: true.
		MessageTally spyOn:[WebServer requestBenchmark: true]
	"

	| port |
	port := 8888.
	WebServer reset default listenOn: port.
	WebServer default addService: '/benchmark' action:[:req|
		req send200Response: ''.
	].
	^[WebClient 
		requestBenchmark: 'http://localhost:', port, '/benchmark'
		persistent: persistent] ensure:[WebServer reset].
! !
!WebServer class methodsFor: 'examples' stamp: 'jmv 3/18/2019 13:16:32' prior: 50893112!
             browseDir: directory request: request
	"Responds with a directory listing back to the original request"

	| entries listing url |
	url := request url.
	(url endsWith: '/') ifTrue:[url := url allButLast].

	entries := directory children sort:[:e1 :e2|
		e1 isDirectory = e2 isDirectory 
			ifTrue:[e1 name <= e2 name]
			ifFalse:[e2 isDirectory]].

	listing := String streamContents:[:s|
		s nextPutAll:'<html><head><title>Index of ', request url,'</title></head><body>'.
		s nextPutAll:'<h1>Index of ', request url,'</h1>'.
		s nextPutAll:'<pre>      Name                      Last modified      Size  Description<hr>'.
		s nextPutAll: '[up]  <a href="', (url copyUpToLast: $/),'">parent</a>'; cr; lf.
		entries do:[:e|
			s nextPutAll:(e isDirectory ifTrue:['[dir] '] ifFalse:['      ']).
			s nextPutAll: '<a href="', url, '/', e name, '">'.
			s nextPutAll: (e name truncateTo: 30).
			s nextPutAll: '</a>'.
			e name size < 30 ifTrue:[s nextPutAll: (String new: 30 - e name size withAll: $ )].
			s nextPutAll: (e modificationTime asString padded: #right to: 20 with: $ ).
			s nextPutAll: (e isDirectory ifTrue: [String new: 20] ifFalse: [e fileSize asString padded: #right to: 20 with: $ ]).
			s cr; lf.
		].
 	].

	request
		send200Response: listing asUtf8
		contentType: 'text/html; charset=utf-8'.

! !
!WebServer class methodsFor: 'examples' stamp: 'jmv 5/19/2015 23:52' prior: 50893156!
         browseFile: file request: request
	"Responds with a file back to the original request"

	| fileSize mimeTypes resp |
	file binary.
	fileSize := file size.
"	mimeTypes := file mimeTypes ifNil:[#('application/octet-stream')]."
	mimeTypes := nil ifNil:[#('application/octet-stream')].
	resp := request newResponse protocol: 'HTTP/1.1' code: 200.
	resp headerAt: 'Content-Type' put: mimeTypes first.
	request sendResponse: resp contentStream: file size: fileSize.! !
!WebServer class methodsFor: 'examples' stamp: 'jmv 3/18/2019 13:16:59' prior: 50893173!
                        browseRequest: request
	"Handle an HTTP request for browsing some resource"

	| path fd file directoryEntry fileEntry |

	"Extract the file path from the request"
	path := request url findTokens: '/'.
	path ifEmpty: [ ^self browseDir: DirectoryEntry currentDirectory request: request ].

	"Find the directory entry for the resource"
	fd := path allButLast inject: DirectoryEntry currentDirectory into: [ :dir :part | dir / part ].
	
	directoryEntry _ fd / path last.
	directoryEntry exists ifTrue: [
		"Send file listing. We handle this synchronously for simplicity."
		self browseDir: directoryEntry request: request.
		^ self].
	fileEntry _ fd // path last.
	fileEntry exists
	ifFalse: [^request send404Response ]
	ifTrue: [
		"Send file content. Since files can be large, we fork this off.
		However, since we forked it, we need to handle two different
		possible conditions:
			- closing the file in case of error
			- handling errors when sending it
		This makes the code below a bit ugly"
		[[
			file := fileEntry readStream.
			[ self browseFile: file request: request ]
				ensure: [ file close ] 	"close file even in case of error"
		] on: Error do: []				"ignore errors altogether"
		] fork. 							"fork it"
	]! !
!WebServer class methodsFor: 'examples' stamp: 'HAW 5/6/2020 09:45:44' prior: 50893214!
                              doItFrom: req

	| data result |
	
	req isPostRequest 
		ifTrue:[
			"We fetch all of the data instead of streaming it"
			data := req content. ]
		ifFalse: [ req isGetRequest 
			ifTrue: [ data := req rawUrl unescapePercents allButFirst ]
			ifFalse: [ ^req send404Response ]].
		
	"Compute the result"
	result := [Compiler evaluate: data] on: Error do:[:ex| ex return: ex asString].
	req send200Response: result asString 
	! !
!WebServer class methodsFor: 'examples' stamp: 'ar 2/23/2010 09:30' prior: 50893230!
                               exampleAuth		"WebServer exampleAuth"
	"Simple example requiring basic auth"

	| server port realm |
	port := 9999.
	server := WebServer reset default.
	
	"The realm to use for the server"
	realm := 'Example Realm'.

	"Add a sample user (note: password is hashed, not stored verbatim)"
	server passwordAt: 'squeak' realm: realm put: 'squeak'.

	server listenOn: port.
	server addService: '/' action:[:req| 
		server 
			authenticate: req 
			realm: realm
			methods: #(digest basic) 
			do:[self browseRequest: req]].
! !
!WebServer class methodsFor: 'examples' stamp: 'ar 2/20/2010 14:54' prior: 50893249!
  exampleBrowse	"WebServer exampleBrowse"
	"This example implements a simple http server allowing to view 
	and download files (like browsing ftp sites etc)."

	| server port |
	port := 9999.
	server := WebServer reset default.
	server listenOn: port.
	server addService: '/' action:[:req| self browseRequest: req].
! !
!WebServer class methodsFor: 'examples' stamp: 'HAW 5/6/2020 09:40:26' prior: 50893262!
          exampleDoIt		"WebServer exampleDoIt"
	"This example executes doIts from a POST request.
	It's the simplest possible RPC interface to Squeak."

	| server port |

	port := 9999.
	server := WebServer reset default.
	server listenOn: port.
	server addService: '/' action:[:req| self doItFrom: req ].
		
! !
!WebServer class methodsFor: 'examples' stamp: 'ar 7/29/2010 18:49' prior: 50893274!
                            exampleSSL: certName

	"This example implements a simple https server allowing to view 
	and download files (like browsing ftp sites etc):

		WebServer exampleSSL: 'Internet Widgits Pty'.
		WebServer exampleSSL: '/home/andreas/certs/testcert.pem'.

	"

	| server port |
	port := 8443.
	server := WebServer reset default.
	server accessLog: Transcript.
	server certName: certName.
	server listenOn: port.
	server addService: '/' action:[:req| self browseRequest: req].
! !
!WebServer class methodsFor: 'examples' stamp: 'ar 2/25/2010 03:28' prior: 50893291!
                   exampleSession		"WebServer exampleSession"
	"This example uses a simple session cookie to avoid 
	authentication for every request."

	| server port realm |
	realm := 'Example Realm'.	"authentication realm"
	port := 9999.
	server := WebServer reset default.
	server listenOn: port.

	"Add a sample user (note: password is hashed, not stored verbatim)"
	server passwordAt: 'squeak' realm: realm put: 'squeak'.

	"Register the login service (sets cookie when successful)"
	server addService: '/login' action:[:req| 
		server  authenticate: req  realm: realm methods: #(digest)  do:[ | id |
			"Set the cookie and redirect back to /"
			server sessionAt: (id := UUID new hex) put: ''.
			req send302Response: (req fields at: 'url' ifAbsent:['/'])
				do:[:resp| resp setCookie: 'session' value: id path: '/']]].

	"Register the normal browse service"
	server addService: '/' action:[:req|
		"Check if we have a valid session cookie. If not redirect to login."
		(server sessionAt: (req cookieAt: 'session')) notNil
			ifTrue:[self browseRequest: req]
			ifFalse:[req send302Response: '/login?url=', req url encodeForHTTP]].
! !
!WebServer class methodsFor: 'accessing' stamp: 'ar 2/23/2010 09:29' prior: 50893329!
     default
	"A default WebServer instance. Mostly for the examples."

	^Default ifNil:[Default := self new].! !
!WebServer class methodsFor: 'accessing' stamp: 'ar 2/23/2010 09:29' prior: 50893335!
                             reset		"WebServer reset"
	"Reset the default WebServer instance."

	Default ifNotNil:[
		Default destroy.
		Default := nil.
	].! !
!WebServer class methodsFor: 'accessing' stamp: 'DSG 5/29/2012 17:57' prior: 50893342!
      serverDate
	"Returns the date string to be used in responses"
	
	"FIXME: check http spec for time format"

	| date |
	^String streamContents:[:s|
		date := DateAndTime now asUTC.
		s nextPutAll: date dayOfWeekAbbreviation, ', '.
		date printOn: s.
		s nextPutAll: ' GMT'.
	].! !
!WebServer class methodsFor: 'accessing' stamp: 'jmv 6/25/2017 20:15:47' prior: 50893354!
               serverString
	"Returns the server string to be used in responses"

	^'WebServer/1.5 (',
		SystemVersion current version,'-',
		SystemVersion current highestUpdate printString, '; ',
		WebUtils platformName,')'
! !
!WebServer class methodsFor: 'registry' stamp: 'ar 11/1/2010 20:59' prior: 50893363!
                     forUrl: urlString
	"Answer the WebServer registered for a given URL string."

	^self forUrl: urlString ifAbsent:[self newForUrl: urlString]! !
!WebServer class methodsFor: 'registry' stamp: 'ar 11/1/2010 20:59' prior: 50893370!
                            forUrl: urlString ifAbsent: aBlock
	"Answer the WebServer registered for a given URL string.
	If no WebServer is registered, evaluate aBlock."

	^self registry at: urlString ifAbsent: aBlock! !
!WebServer class methodsFor: 'registry' stamp: 'ar 11/1/2010 21:02' prior: 50893379!
         newForUrl: urlString
	"Create a new WebServer instance registered for a given URL string."

	| server |
	"Out with the old ...."
	server := self removeUrl: urlString.
	server ifNotNil:[server destroy].

	"... and in with the new."
	server := self new.
	server siteUrl: urlString.
	self registry at: urlString put: server.
	^server
! !
!WebServer class methodsFor: 'registry' stamp: 'ar 11/1/2010 21:11' prior: 50893392!
                            registry
	"Answer the WebServer site registry"

	^Registry ifNil:[Registry := Dictionary new]! !
!WebServer class methodsFor: 'registry' stamp: 'ar 11/1/2010 20:59' prior: 50893398!
          removeUrl: urlString
	"Remove and answer the WebServer registered for a given URL string.
	If no WebServer was registered, return nil."

	^self removeUrl: urlString ifAbsent:[nil]! !
!WebServer class methodsFor: 'registry' stamp: 'ar 11/1/2010 20:59' prior: 50893406!
                    removeUrl: urlString ifAbsent: aBlock
	"Remove and answer the WebServer registered for a given URL string."

	^self registry removeKey: urlString ifAbsent: aBlock! !
!WebSocket methodsFor: 'private' stamp: 'ar 9/26/2011 11:41' prior: 50893414!
            handle: selector arguments: argList

	^self handle: selector arguments: argList ifAbsent:[nil]! !
!WebSocket methodsFor: 'private' stamp: 'ar 9/26/2011 11:41' prior: 50893419!
                handle: selector arguments: argList ifAbsent: aBlock

	^(handlers at: selector ifAbsent:[^aBlock value])
		valueWithPossibleArgs: argList.! !
!WebSocket methodsFor: 'private' stamp: 'ar 9/26/2011 10:47' prior: 50893426!
    handleClose
	"Handle a connection close"

	^self handle: 'close' arguments: (Array with: self)
! !
!WebSocket methodsFor: 'private' stamp: 'ar 9/26/2011 10:46' prior: 50893432!
               handleError: exception
	"Handle an error"

	^self handle: 'error' arguments: (Array with: exception with: self)! !
!WebSocket methodsFor: 'private' stamp: 'ar 9/26/2011 10:45' prior: 50893438!
                               handleMessage: msgData type: msgType
	"Handle an incoming message of the given type"

	self handle: 'message' arguments: (Array with: msgData with: msgType with: self)! !
!WebSocket methodsFor: 'initialize' stamp: 'ar 9/26/2011 13:06' prior: 50893446!
    close
	"Request graceful close"

	^self subclassResponsibility! !
!WebSocket methodsFor: 'initialize' stamp: 'ar 9/27/2011 13:42' prior: 50893451 overrides: 16896425!
                         initialize
	super initialize.
	handlers := Dictionary new.! !
!WebSocket methodsFor: 'initialize' stamp: 'DSG 3/28/2015 20:00' prior: 50893455!
                on: aStream
	"Create a new WebSocket instance using the given SocketStream"

	stream := aStream.
	name := String streamContents:[:s| 
		stream socket remoteAddress 
			do:[:b| s print: b] 
			separatedBy:[s nextPut: $.]].
	name := name, ':', stream socket remotePort asString.
	! !
!WebSocket methodsFor: 'running' stamp: 'ar 7/8/2010 20:00' prior: 50893466!
                         fork
	"Fork the WebSocket's input process."

	process := [self run] newProcess.
	process resume.
! !
!WebSocket methodsFor: 'running' stamp: 'ar 9/26/2011 10:46' prior: 50893472!
             onClose: aBlock
	"Set the handler block to invoke when the socket is closed"

	handlers at: 'close' put: aBlock.! !
!WebSocket methodsFor: 'running' stamp: 'ar 9/26/2011 10:45' prior: 50893478!
                              onError: aBlock
	"Set the handler block to invoke when an error occurs"

	handlers at: 'error' put: aBlock.! !
!WebSocket methodsFor: 'running' stamp: 'ar 9/26/2011 10:45' prior: 50893484!
   onMessage: aBlock
	"Set the handler block to invoke when a message is received"

	handlers at: 'message' put: aBlock.
! !
!WebSocket methodsFor: 'running' stamp: 'ar 9/26/2011 10:41' prior: 50893490!
                        run
	"Run the WebSocket's input process."

	^self subclassResponsibility! !
!WebSocket methodsFor: 'read/write' stamp: 'ar 9/26/2011 10:42' prior: 50893495!
   send: aString
	"Writes one frame worth of data"

	^self subclassResponsibility! !
!WebSocket methodsFor: 'accessing' stamp: 'ar 7/8/2010 21:39' prior: 50893500!
                               timeout
	"The underlying stream timeout"

	^stream timeout! !
!WebSocket methodsFor: 'accessing' stamp: 'ar 7/8/2010 21:40' prior: 50893504!
                   timeout: seconds
	"Sets the underlying stream timeout"

	^stream timeout: seconds! !
!WebSocket class methodsFor: 'example' stamp: 'jmv 6/25/2017 20:16:51' prior: 50893509!
                   example	"WebSocket example"

	"This is a very simple WebSocket example implementing a basic chat system.
	Each message sent by a client connection is broadcast to everyone."

	| mutex sockets |
	mutex := Mutex new.
	sockets := OrderedCollection new.
	WebServer reset default listenOn: 8080.

	WebServer default addService: '/' action:[:req|
		"Serves the main html chat page"
		req send200Response: self examplePage contentType: 'text/html'.
	].

	WebServer default addService: '/broadcast' action:[:req| | ws |
		"Implements the WebSocket broadcaster"
		ws := req asWebSocket.
		ws timeout: 300. "5 minutes timeout"
	
		"Transcript log: 'New ', ws requestLine."
		Transcript log: 'New '.
		
		ws onMessage:[:data|
			mutex critical:[sockets do:[:s| s send: data]].
		].
		ws onClose:[
			Transcript log: 'Closing ', ws requestLine.
			mutex critical:[sockets remove: ws ifAbsent:[]].
		].
		ws onError:[:ex|
			Transcript log: ws requestLine.
			Transcript log: ex description.
			Transcript log: ex signalerContext longStack.
		].
		mutex critical:[sockets add: ws].

		"We don't need to #fork here, in fact we shouldn't since it ensures
		that shutting down WebServer shuts down any WebSockets, too."
		ws run.
	].! !
!WebSocket class methodsFor: 'example' stamp: 'ar 7/8/2010 21:50' prior: 50893550!
        examplePage
	"The example HTML page for WebServer"

	^'<html>
<p id="status">WebSocket: Not connected</p> 
<form> 
    <input type="text" id="chat" placeholder="type and press enter to chat" /> 
</form> 
<p>To test, open two windows with Web Socket support, type a message above and press return.</p> 
<ul id="log"></ul> 

<script>

var conn = {};
var log = document.getElementById("log");
var chat = document.getElementById("chat");
var form = chat.form;
var state = document.getElementById("status"); 
 
if (window.WebSocket === undefined) {
  state.innerHTML = "(WebSockets not supported)";
} else {
    conn = new WebSocket("ws://localhost:8080/broadcast");
    conn.onopen = function () {
      state.innerHTML = "WebSocket: Connected";
    };
 
    conn.onmessage = function (event) {
      log.innerHTML = "<li>" + event.data + "</li>" + log.innerHTML;
    };
    
    conn.onclose = function (event) {
      state.innerHTML = "WebSocket: Closed";
    };

	form.addEventListener("submit", function (event) {
		event.preventDefault();
		if (conn.readyState === 1) {
			conn.send(chat.value);      
			chat.value = "";
		}
	}, false);
};
 
</script> 

</body>
</html>'! !
!WebSocket class methodsFor: 'instance creation' stamp: 'ar 7/8/2010 18:22' prior: 50893590!
          on: aStream
	"Create a new WebSocket instance using the given SocketStream"

	^self new on: aStream! !
!WebSocket00 methodsFor: 'running' stamp: 'jmv 9/5/2016 20:49:42' prior: 50893596 overrides: 50349263!
                  close
	"Request graceful close"

	stream isConnected ifTrue:[
		stream nextPut: (Character numericValue: 255).
		stream nextPutAll: (Character numericValue: 0).
		stream flush.
	].
! !
!WebSocket00 methodsFor: 'running' stamp: 'ar 7/8/2010 21:49' prior: 50893605 overrides: 50349312!
    run
	"Run the WebSocket's input process."

	[[[stream isConnected] whileTrue:[
		self readMessage.
		"XXXX: Should this be moved into handleMessage:type: ???"
		frameType = 255 ifTrue:[stream close. ^self].
		self handleMessage: frameData type: frameType.
	]] on: Error do:[:ex| self handleError: ex]] ensure:[
		[stream socket destroy] on: Error do:[:ex|].
		self handleClose.
	].
! !
!WebSocket00 methodsFor: 'read/write' stamp: 'jmv 9/5/2016 22:30:06' prior: 50893620!
        readMessage
	"Reads one frame worth of data"

	| byte length |
	byte := stream next ifNil:[
		frameType := 255.
		^nil].
	frameType := byte numericValue.
	frameType < 128 ifTrue:[
		"Frame type < 128: UTF-8 encoded text with 0xFF frame delimiter"
		frameData := String fromUtf8: (stream upTo: 255 asCharacter) asByteArray.
	] ifFalse:[
		"Frame type >= 128: Binary data with length prefix"
		length := 0.
		[byte := stream next numericValue.
		length := (length * 128) + (byte bitClear: 128).
		byte >= 128] whileTrue.
		frameData := ByteArray new: length.
		stream nextInto: frameData.
	].
! !
!WebSocket00 methodsFor: 'read/write' stamp: 'ar 9/26/2011 12:03' prior: 50893642 overrides: 50349317!
      send: aString
	"Writes one frame worth of data"

	^self send: aString type: 0! !
!WebSocket00 methodsFor: 'read/write' stamp: 'jmv 9/19/2016 21:54:06' prior: 50893647!
                        send: data type: type
	"Writes one frame worth of data using the given frame type"

	"Frame type"
	stream nextPut: (Character numericValue: type).
	type < 128 ifTrue:[
		"Frame type < 128: UTF-8 encoded text with 0xFF frame delimiter"
		stream nextPutAll: data asString asUtf8.
		stream nextPut: (Character numericValue: 255).
	] ifFalse:[ | prefix length |
		"Frame type >= 128: Binary data with length prefix"
		prefix := ByteArray new.
		length := data size.
		[length > 127]  whileTrue:[
			prefix := prefix copyWith: prefix \\ 128.
			length := length // 128.
		].
		prefix := prefix copyWith: length.
		stream nextPutAll: prefix reversed.
		stream nextPutAll: data.
		stream flush.
	].
	stream flush.
! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 13:06' prior: 50893673 overrides: 50349263!
            close
	"Send a close control request"

	closing ifFalse:[
		closing := true.
		self send: #[] code: 8.
	].! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 13:07' prior: 50893679!
                         handleClose: payload
	"Close is being sent by remote in process of shutting down connection"

	closing ifFalse:[^self close].

	"We're done. We've received the close and responded to it"
	stream close.

! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 11:37' prior: 50893688!
                        handleControl: payload type: opcode
	"Handle a control opcode"

	opcode caseOf: {
		[8]	-> [self handleClose: payload].
		[9]	-> [self handlePing: payload].
		[10] -> [self handlePong: payload].
	} otherwise:[self error: 'Unknown control request: ', opcode].

! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 11:41' prior: 50893699!
                               handlePing: payload

	self handle: 'ping' 
		arguments: (Array with: payload with: self)
		ifAbsent:[self pong: payload].
! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 11:40' prior: 50893706!
         handlePong: payload

	self handle: 'pong' arguments: (Array with: payload with: self).! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 12:49' prior: 50893712!
             onPing: aBlock
	"Set the handler block to invoke when a ping is received"

	handlers at: 'ping' put: aBlock.! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 12:49' prior: 50893718!
                       onPong: aBlock
	"Set the handler block to invoke when a pong is received"

	handlers at: 'pong' put: aBlock.! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 12:03' prior: 50893724!
                       ping: data
	"Send a ping control request"

	self send: data code: 9.! !
!WebSocket07 methodsFor: 'control requests' stamp: 'ar 9/26/2011 12:03' prior: 50893729!
                               pong: data
	"Send a pong control request"

	self send: data code: 10.! !
!WebSocket07 methodsFor: 'read/write' stamp: 'jmv 5/19/2015 22:45' prior: 50893734!
   firstFragment: aStringOrBytes
	"Writes the first fragment of data"

	aStringOrBytes isString 
		ifTrue:[^self send: aStringOrBytes asUtf8 code: 1 final: false]
		ifFalse:[^self send: aStringOrBytes code: 2 final: false].! !
!WebSocket07 methodsFor: 'read/write' stamp: 'jmv 5/19/2015 22:45' prior: 50893744!
            lastFragment: aStringOrBytes
	"Writes the last fragment of data.
	Note: Spec says that code is ZERO for final fragment."

	aStringOrBytes isString 
		ifTrue:[^self send: aStringOrBytes asUtf8 code: 0 final: true]
		ifFalse:[^self send: aStringOrBytes code: 0 final: true].! !
!WebSocket07 methodsFor: 'read/write' stamp: 'jmv 5/19/2015 22:45' prior: 50893755!
                        nextFragment: aStringOrBytes
	"Writes the first fragment of data
	Note: Spec says that code is ZERO for intermediate fragments."

	aStringOrBytes isString 
		ifTrue:[^self send: aStringOrBytes asUtf8 code: 0 final: false]
		ifFalse:[^self send: aStringOrBytes code: 0 final: false].! !
!WebSocket07 methodsFor: 'read/write' stamp: 'ar 9/27/2011 13:31' prior: 50893767!
               readFrame
	"Reads one frame worth of data"

	^self readFrameFrom: stream! !
!WebSocket07 methodsFor: 'read/write' stamp: 'jmv 9/5/2016 22:30:33' prior: 50893772!
                              readFrameFrom: aStream
	"Reads one frame worth of data"

	| byte length final mask opcode payload |
	byte := (aStream next ifNil:[^nil]) numericValue.

	final := byte anyMask: 128.
	opcode := byte bitAnd: 15.

	byte := (aStream next ifNil:[^nil]) numericValue.
	mask := byte anyMask: 128.
	length := byte bitAnd: 127.

	length = 126 ifTrue:[
		length := self nextNumber: 2 from: aStream.
	] ifFalse:[
		length = 127 ifTrue:[length := self nextNumber: 8 from: aStream].
	].

	mask 
		ifTrue:[mask := aStream next: 4] 
		ifFalse:[mask := nil].

	payload := ByteArray new: length.
	aStream next: length into: payload.

	"Unmask payload"
	mask ifNotNil:[self xor: payload with: mask].

	"First see if this is a control frame which can be inserted into fragmented messages."
	opcode >= 8 ifTrue:[^self handleControl: payload type: opcode].

	"Now see if this is a fragmented message"
	frameType ifNil:[
		frameType := opcode.
		frameData := Array with: payload.
	] ifNotNil:[
		frameData := frameData copyWith: payload.
	].

	final ifTrue:[
		"This was the final fragment"
		frameData size = 1 ifTrue:[
			payload := frameData first
		] ifFalse:[
			payload := frameData allButFirst 
							inject: frameData first 
							into:[:each :next| each, next].
		].
		frameType = 1 ifTrue:[payload := String fromUtf8: payload asByteArray].
		self handleMessage: payload type: frameType.
		frameType := frameData := nil.
	].
! !
!WebSocket07 methodsFor: 'read/write' stamp: 'DSG 3/28/2015 21:49' prior: 50893820 overrides: 50349317!
               send: aStringOrBytes
	"Writes one frame worth of data"

	aStringOrBytes isString 
		ifTrue:[^self send: aStringOrBytes asString asUtf8 code: 1]
		ifFalse:[^self send: aStringOrBytes code: 2].! !
!WebSocket07 methodsFor: 'read/write' stamp: 'ar 9/26/2011 12:48' prior: 50893829!
          send: data code: opcode
	"Sends unfragmented data using the given opcode"

	^self send: data code: opcode final: true! !
!WebSocket07 methodsFor: 'read/write' stamp: 'ar 9/27/2011 13:47' prior: 50893835!
                    send: data code: opcode final: isFinal
	"Sends unfragmented data using the given opcode"

	^self send: data code: opcode final: isFinal mask: self masking! !
!WebSocket07 methodsFor: 'read/write' stamp: 'jmv 4/11/2019 15:34:42' prior: 50893843!
           send: data code: opcode final: isFinal mask: doMask
	"Sends unfragmented data using the given opcode"

	| byte1 byte2 mask xLength copy |
	byte1 := opcode. "FIN = 1, RSV1=RSV2=RSV3=0"
	isFinal ifTrue:[byte1 := byte1 bitOr: 128].
	data size > 125 ifTrue:[
		data size > 16rFFFF ifTrue:[
			byte2 := 127.
			xLength := ByteArray new: 8.
			(WriteStream on: xLength)
				nextUnsignedInt32Put: data size >> 32 bigEndian: true;
				nextUnsignedInt32Put: (data size bitAnd: 16rFFFFFFFF) bigEndian: true.
		] ifFalse:[
			byte2 := 126.
			xLength := ByteArray new: 2.
			(WriteStream on: xLength) nextUnsignedInt16Put: data size bigEndian: true.
		].
	] ifFalse:[
		byte2 := data size.
		xLength := #[].
	].
	doMask ifTrue:[
		byte2 := byte2 bitOr: 128. "Mask = 1"
		mask := ByteArray new: 4.
		1 to: 4 do:[:i| mask at: i put: 256 atRandom-1].
		copy := data copy.
		self xor: copy with: mask.
	] ifFalse:[
		copy := data.
	].
	stream nextPut: byte1.
	stream nextPut: byte2.
	stream nextPutAll: xLength.
	mask ifNotNil:[stream nextPutAll: mask].
	stream nextPutAll: copy.
	stream flush.! !
!WebSocket07 methodsFor: 'read/write' stamp: 'ar 9/26/2011 13:09' prior: 50893879!
                  xor: data with: mask
	"XOR all the data using the given mask bytes.

	WARNING: Does inplace reversal; do not call with literal data."

	"This would be much faster w/ BitBlt but data may not be 
	4-byte aligned and so BB will barf."
	1 to: data size do:[:i|
		data byteAt: i put: ((data byteAt: i) bitXor: (mask byteAt: i-1 \\ 4 + 1)).
	].
! !
!WebSocket07 methodsFor: 'initialize' stamp: 'klub 6/13/2012 17:00' prior: 50893893 overrides: 50349269!
initialize

	super initialize.
	closing := false.
	masking := true. " 	http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07#section-4.1 says:
   ''Frames sent from the client to the server are masked to
   avoid confusing network intermediaries, such as intercepting proxies.''"! !
!WebSocket07 methodsFor: 'accessing' stamp: 'ar 9/27/2011 13:47' prior: 50893905!
      masking
	"If true, outgoing frames are masked."

	^masking! !
!WebSocket07 methodsFor: 'accessing' stamp: 'ar 9/27/2011 13:47' prior: 50893909!
                masking: aBool
	"If true, outgoing frames are masked."

	masking := aBool! !
!WebSocket07 methodsFor: 'private' stamp: 'jmv 9/5/2016 21:35:24' prior: 50893914!
nextNumber: n from: aStream
	"Answer the next n bytes as a positive Integer or LargePositiveInteger."
	| s |
	s := 0.
	1 to: n do: 
		[:i | s := (s bitShift: 8) bitOr: aStream next numericValue].
	^ s normalize! !
!WebSocket07 methodsFor: 'running' stamp: 'ar 9/26/2011 12:40' prior: 50893924 overrides: 50349312!
      run
	"Run the WebSocket's input process."

	[[[stream isConnected] whileTrue:[
		self readFrame.
	]] on: Error do:[:ex| self handleError: ex]] ensure:[
		[stream socket destroy] on: Error do:[:ex|].
		self handleClose.
	].
! !
!WebUtils class methodsFor: 'decoding' stamp: 'jmv 6/25/2017 19:16:15' prior: 50893934!
     decodeMultipartForm: aStream boundary: boundary do: aBlock
	"Parse the contents of a multipart/form-data submission.

	Evaluate aBlock with three parts: The headers, the (parsed) form-data
	arguments and the (undecoded) contents of the part. The sender is
	expected to take care of other issues such as content-transfer-encoding
	and similar headers."

	| skip headers content disposition index params |
	aStream upToAll: '--', boundary.
	[aStream atEnd or:[(skip := aStream next: 2) = '--']] whileFalse:[
		skip = String crlfString ifFalse:[self error: 'Error decoding multipart/form-data fields'].
		headers := Dictionary new.
		(WebUtils readHeadersFrom: aStream) do:[:hdr| headers add: hdr].
		content := aStream upToAll: String crlfString, '--', boundary.
		params := Dictionary new.
		disposition := headers at: 'content-disposition' ifAbsent:[''].
		#(name filename) do:[:arg| | len val |
			len := arg size + 2.
			index := disposition findString: arg,'='.
			index > 0 ifTrue:[
				val := disposition copyFrom: index + len to: (disposition indexOf: $" startingAt: index+len) - 1.
				params at: arg put: val.
			].
		].
		aBlock value: headers value: params value: content.
	].! !
!WebUtils class methodsFor: 'decoding' stamp: 'ar 2/21/2010 09:54' prior: 50893974!
      decodeUrlEncodedForm: aString
	"Decodes the fields embedded in the url ?var1=val1&var2=val2"

	^self decodeUrlEncodedForm: aString multipleValues: false! !
!WebUtils class methodsFor: 'decoding' stamp: 'DSG 5/24/2012 21:19' prior: 50893982!
               decodeUrlEncodedForm: aString do: aBlock
	"Decodes the fields embedded in the url ?var1=val1&var2=val2.
	Evaluates aBlock with the key/value pairs defined in the fields."

	| args keyval index key value |
	args := aString readStream.
	[args atEnd] whileFalse:[
		keyval := args upTo: $&.
		(index := keyval indexOf: $=) = 0 ifTrue:[
			key := keyval.
			value := ''.
		] ifFalse:[
			key := keyval copyFrom: 1 to: index-1.
			value := keyval copyFrom: index +1 to: keyval size.
		].
		key := key unescapePercents.
		value := value unescapePercents.
		aBlock value: key value: value.
	].
! !
!WebUtils class methodsFor: 'decoding' stamp: 'ar 7/20/2010 20:37' prior: 50894003!
                             decodeUrlEncodedForm: aString multipleValues: aBool
	"Decodes the fields embedded in the url ?var1=val1&var2=val2"

	| fields |
	fields := Dictionary new.
	self decodeUrlEncodedForm: aString do:[:key :value|
		aBool 
			ifTrue:[fields at: key put: (fields at: key ifAbsent:['']), value]
			ifFalse:[fields at: key put: value].
	].
	^fields! !
!WebUtils class methodsFor: 'decoding' stamp: 'jmv 6/26/2017 19:54:45' prior: 50894016!
                 encodeMultipartForm: fieldMap boundary: boundary
	"Encodes the fieldMap as multipart/form-data.

	The fieldMap may contain MIMEDocument instances to indicate the presence
	of a file to upload to the server. If the MIMEDocument is present, its
	content type and file name will be used for the upload.

	The fieldMap can be EITHER an array of associations OR a Dictionary of 
	key value pairs (the former is useful for providing multiple fields and/or 
	specifying the order of fields)."

	^String streamContents:[:stream|
		(fieldMap as: Dictionary) keysAndValuesDo:[:fieldName :fieldValue | | fieldContent |
			"Write multipart boundary and common headers"
			stream nextPutAll: '--', boundary; nextPutAll: String crlfString.
			stream nextPutAll: 'Content-Disposition: form-data; name="', fieldName, '"'.
			"Figure out if this is a file upload - This code was deleted. Cuis does not currently include MIMEDocument. See Squeak."
			fieldContent := fieldValue.
			stream nextPutAll: String crlfString; nextPutAll: String crlfString.
			stream nextPutAll: fieldContent asString.
			stream nextPutAll: String crlfString.
		].
		stream nextPutAll: '--', boundary, '--', String crlfString.
	].
! !
!WebUtils class methodsFor: 'decoding' stamp: 'jmv 5/19/2015 23:52' prior: 50894056!
 encodeUrlEncodedForm: fieldMap
	"Encodes the fieldsMap in the form of var1=val1&var2=val2.
	The fieldMap can be EITHER an array of associations OR a Dictionary of 
	key value pairs (the former is useful for providing multiple fields and/or 
	specifying the order of fields)."

	| associations |
	associations := (fieldMap isKindOf: Dictionary) ifTrue:[fieldMap associations] ifFalse:[fieldMap].
	^String streamContents:[:s|
		associations do:[:assoc|
			s nextPutAll: assoc key encodeForHTTP.
			assoc value ifNotNil:[
				s nextPutAll: '='.
				s nextPutAll: assoc value asString encodeForHTTP
			].
		] separatedBy:[s nextPutAll:'&'].
	].! !
!WebUtils class methodsFor: 'decoding' stamp: 'jmv 5/19/2015 21:52' prior: 50894079!
       multipartBoundary
	"Answer a string to be used as multpart boundary in posts"

	^'----squeak-', Date today printString,'-', Time localMillisecondClock printString, '-webclient-----'.! !
!WebUtils class methodsFor: 'proxy' stamp: 'CK 11/24/2017 13:59:29' prior: 50894087!
                 defaultProxyServer
	"Answer the default proxy server to use."
	^ currentProxyServer ! !
!WebUtils class methodsFor: 'proxy' stamp: 'CK 11/24/2017 14:00:05' prior: 50894092!
                   defaultProxyServer: aString
	"Set the default proxy server to use."
	currentProxyServer _ aString ! !
!WebUtils class methodsFor: 'proxy' stamp: 'DSG 12/4/2013 23:03' prior: 50894098!
        proxyExceptionsDo: aBlock
	"Evaluate aBlock with all registered proxy exceptions. 
	Uses the information from HTTPSocket."

	"HTTPSocket httpProxyExceptions do: aBlock."! !
!WebUtils class methodsFor: 'proxy' stamp: 'CK 11/27/2017 12:06:52' prior: 50894106!
                              proxyServerFor: serverName
	"Answer the proxy server to use for the given server:port
	Returns the proxy server:port to use or nil if no proxy is required."

	| domain |
	domain := serverName copyUpTo: $:.
	self proxyExceptionsDo:[:pattern| (pattern match: domain) ifTrue:[^nil]].
	^self defaultProxyServer! !
!WebUtils class methodsFor: 'websockets' stamp: 'ar 7/20/2010 20:38' prior: 50894118!
                    extractWebSocketKey: field
	"Decodes a WebSocket key:

		Sec-WebSocket-Key1: 18x 6]8vM;54 *(5:  {   U1]8  z [  8
		Sec-WebSocket-Key2: 1_ tx7X d  <  nw  334J702) 7]o}` 0

		For each of these fields, the server has to take the digits from the
		 value to obtain a number (in this case 1868545188 and 1733470270
		respectively), then divide that number by the number of spaces
		characters in the value (in this case 12 and 10) to obtain a 32-bit
		number (155712099 and 173347027).  These two resulting numbers are
		then used in the server handshake, as described below.
	"

	| digits spaces |
	digits := spaces := 0.
	field do:[:ch|
		ch isDigit ifTrue:[digits := digits * 10 + ch digitValue].
		ch = $ ifTrue:[spaces := spaces + 1].
	].
	^digits // spaces.
! !
!WebUtils class methodsFor: 'websockets' stamp: 'ar 7/8/2010 18:59' prior: 50894144!
                webSocketHandshake: key1 with: key2 with: data
	"Do the actual WebSocket handshake computation"

	| bytes |
	bytes := ByteArray new: 16.
	bytes longAt: 1 put: key1 bigEndian: true.
	bytes longAt: 5 put: key2 bigEndian: true.
	bytes replaceFrom: 9 to: 16 with: data.
	^(self md5HashStream: bytes readStream) reversed! !
!WebUtils class methodsFor: 'websockets' stamp: 'ar 9/26/2011 10:30' prior: 50894157!
           webSocketHash07: key
	"Do the actual WebSocket hash computation"

	| uid |
	uid := '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'.
	^(ByteArray newFrom: (SecureHashAlgorithm new hashMessage: key, uid)) reversed base64Encoded! !
!WebUtils class methodsFor: 'auth' stamp: 'jmv 6/25/2017 19:55:56' prior: 50894166!
                handleAuth: aBlock
	"Utility method to handle web authentication requests interactively.

	Use like here:
		| wc |
		wc := WebClient new.
		WebUtils handleAuth:[wc httpGet: 'http://some.auth.required'].
	"

	| user pass |
	^[aBlock value] on: WebAuthRequired do:[:ex|
		"Allow outer handlers to take over authentication"
		ex isNested ifFalse:[
			user := FillInTheBlankMorph request:  ex message, 
				'\Please enter your user name:' initialAnswer:''.
			user ifNotEmpty:[
				"Just a little obfuscation to avoid completely plain passwords"
				pass := (FillInTheBlankMorph request:
					'Please enter the password for "', user,'":') asUtf8 base64Encoded.
				 ex username: user password: [String fromUtf8: pass base64Decoded]]].
		ex pass].! !
!WebUtils class methodsFor: 'oauth' stamp: 'DSG 3/28/2015 23:22' prior: 50894192!
    hmacSha1: message key: signKey
	"Compute the SHA1 HMAC for the given message"

	| blockSize key ipad opad |
	blockSize := 64. "SHA1 block size"
	key := signKey asByteArray.
	key size > blockSize ifTrue:[key := self sha1Hash: key].
	key size < blockSize ifTrue:[key := key, (ByteArray new: blockSize - key size)].
	ipad := ByteArray new: blockSize withAll: 16r36.
	opad := ByteArray new: blockSize withAll: 16r5C.
	^self sha1Hash: 
		(key with: opad collect:[:b1 :b2| b1 bitXor: b2]), 
		(self sha1Hash: (key with: ipad collect:[:b1 :b2| b1 bitXor: b2]), message)! !
!WebUtils class methodsFor: 'oauth' stamp: 'jmv 6/25/2017 19:16:16' prior: 50894212!
                     oAuthSign: webRequest url: requestUrl extra: postFields using: params
	"Sign the given webRequest using the set of oauth parameters provided"

	| epoch timestamp nonce normalized baseString query signature key header extraKeys baseUrl |

	"Allow providing an oauth_timestamp; HOWEVER this is only useful for
	tests etc. For actual API calls the timestamp *must* match real-time closely
	or else the request will be rejected".

	timestamp := params at: 'oauth_timestamp' ifAbsent:[
		"Timestamp is relative to Jan. 1st 1970 GMT"
		epoch := DateAndTime year: 1970 day: 1 hour: 0 minute: 0 second: 0 
			offset: (Duration seconds: 0).
		(DateAndTime now asUTC - epoch) totalSeconds.
	].

	"Same for nonces (although nonces can be reused)"
	nonce := params at: 'oauth_nonce' ifAbsent:[UUID new hex].

	"Assemble the required parameters. Start with the (POST) body fields."
	normalized := (postFields as: Dictionary) associations asOrderedCollection.

	"If present, extract any (GET) fields from the URL"
	(requestUrl copyAfter: $?) ifNotEmpty:[:fields|
		self decodeUrlEncodedForm: fields do:[:fkey :fval| normalized add: fkey -> fval]].

	"Keep the extra argument keys so we can exclude them below"
	extraKeys := Set newFrom: (normalized collect:[:assoc| assoc key]).
	normalized add:('oauth_nonce' -> nonce).
	normalized add: ('oauth_timestamp' -> timestamp asString).
	
	normalized add: (params associationAt: 'oauth_consumer_key').
	normalized add: (params associationAt: 'oauth_signature_method').
	normalized add: (params associationAt: 'oauth_version').

	(params includesKey: 'oauth_callback') ifTrue:[
		normalized add: (params associationAt: 'oauth_callback').
	].
	(params includesKey: 'oauth_token') ifTrue:[
		normalized add: (params associationAt: 'oauth_token').
	].
	(params includesKey: 'oauth_verifier') ifTrue:[
		normalized add: (params associationAt: 'oauth_verifier').
	].

	normalized := normalized sort:[:a1 :a2| 
		a1 key = a2 key 
			ifTrue:[a1 value <= a2 value]
			ifFalse:[a1 key <= a2 key]].

	query := String streamContents:[:s|
		normalized do:[:assoc|
			s nextPutAll: assoc key.
			s nextPutAll: '='.
			s nextPutAll: assoc value encodeForHTTP.
		] separatedBy:[s nextPutAll: '&'].
	].

	baseUrl := (requestUrl copyUpTo: $?) copyUpTo: $#.
	baseString := webRequest method, 
		'&', baseUrl encodeForHTTP, 
		'&',  query encodeForHTTP.

	key := (params at: 'oauth_consumer_secret'), 
			'&', (params at: 'oauth_token_secret' ifAbsent:['']).
	(params at: 'oauth_signature_method') caseOf: {
		['HMAC-SHA1'] -> [
			signature := (WebUtils hmacSha1: baseString key: key) base64Encoded
		].
	} otherwise:[self error: 'Unsupported signature method'].

	header := String streamContents:[:s|
		s nextPutAll: 'OAuth '.
		"Even though we need to include the extra args in the computation,
		they do NOT go into the OAuth header field."
		normalized do:[:assoc|
			(extraKeys includes: assoc key) 
				ifFalse:[ s nextPutAll: assoc key, '="', assoc value encodeForHTTP, '",']].
		s nextPutAll: 'oauth_signature="', signature encodeForHTTP, '"'.
	].

	webRequest headerAt: 'Authorization' put: header.! !
!WebUtils class methodsFor: 'oauth' stamp: 'ar 8/23/2010 21:55' prior: 50894312!
                             oAuthSign: webRequest url: requestUrl using: params
	"Sign the given webRequest using the set of oauth parameters provided"

	^self oAuthSign: webRequest url: requestUrl extra: #() using: params! !
!WebUtils class methodsFor: 'oauth' stamp: 'ar 8/12/2010 16:31' prior: 50894321!
         sha1Hash: message
	"Compute the SHA1 hash for the given message. Slightly different from 
	SecureHashAlgorithm to produce fixed-length byte arrays."

	| sha hash |
	sha := SecureHashAlgorithm new hashMessage: message.
	hash := ByteArray new: 20.
	1 to: 20 do:[:i| hash at: i put: (sha digitAt: 21-i)].
	^hash
! !
!WebUtils class methodsFor: 'json-encode' stamp: 'ar 2/10/2012 13:39' prior: 50894333!
                jsonArray: anArray on: stream
	"Encodes an array"

	stream nextPut: $[.
	anArray 
		do:[:each| self jsonObj: each on: stream]
		separatedBy:[stream nextPutAll:', '].
	stream nextPut:$].
! !
!WebUtils class methodsFor: 'json-encode' stamp: 'ar 2/10/2012 13:39' prior: 50894342!
           jsonChar: aCharacter on: stream
	"Writes a single encoded character"

	| ascii |
	ascii := aCharacter asciiValue.

	ascii < 32 ifTrue:["Control character"
		ascii caseOf: {
			[13]	-> [^stream nextPutAll: '\r'].
			[12]	-> [^stream nextPutAll: '\f'].
			[10]	-> [^stream nextPutAll: '\n'].
			[9]		-> [^stream nextPutAll: '\t'].
			[8]		-> [^stream nextPutAll: '\b'].
		} otherwise:[
			^stream nextPutAll: '\u'; nextPutAll: 
				((ascii printStringBase: 16) padded: #left to: 4 with: $0)
		].
	].

	(ascii >= 32 and:[ascii <=127]) ifTrue:["Ascii character"
		(ascii = 34 or:[ascii = 92 or:[ascii = 47]]) ifTrue:[stream nextPut: $\].
		^stream nextPut: aCharacter
	].

	"Encode other characters (control chars, accents, umlauts, unicode)"
	stream nextPutAll:  
		'\u', (((ascii bitAnd: 16rFFFF) printStringBase: 16) padded: #left to: 4 with: $0).
! !
!WebUtils class methodsFor: 'json-encode' stamp: 'ar 2/10/2012 13:41' prior: 50894371!
                      jsonEncode: anObject
	"Encode the given object as JSON"

	^String streamContents:[:s| self jsonObj: anObject on: s]! !
!WebUtils class methodsFor: 'json-encode' stamp: 'ar 2/10/2012 13:40' prior: 50894377!
                  jsonMap: aDictionary on: stream
	"Encodes a dictionary"

	stream nextPut: ${.
	"Sorting keys ensures deterministic order"
	aDictionary keys asArray sort do:[:key|
		self jsonString: key on: stream.
		stream nextPutAll:': '.
		self jsonObj: (aDictionary at: key) on: stream.
	] separatedBy:[stream nextPutAll: ', '].
	stream nextPut: $}.! !
!WebUtils class methodsFor: 'json-encode' stamp: 'ar 2/10/2012 13:38' prior: 50894390!
                     jsonNumber: aNumber on: stream
	"Encodes a number"

	| value |
	value := aNumber.
	value isInteger ifFalse:[value := aNumber asFloat].
	stream print: aNumber.
! !
!WebUtils class methodsFor: 'json-encode' stamp: 'jmv 6/26/2017 19:34:55' prior: 50894398!
  jsonObj: anObject on: stream
	"Encode a generic object"

	anObject isString ifTrue:[^self jsonString: anObject on: stream].
	anObject isNumber ifTrue:[^self jsonNumber: anObject on: stream].
	anObject == nil ifTrue:[^stream nextPutAll: 'null'].
	anObject == true ifTrue:[^stream nextPutAll: 'true'].
	anObject == false ifTrue:[^stream nextPutAll: 'false'].
	anObject isArray ifTrue:[^self jsonArray: anObject on: stream].
	(anObject is: #Dictionary) ifTrue:[^self jsonMap: anObject on: stream].

	self error: 'Cannot encode: ', anObject! !
!WebUtils class methodsFor: 'json-encode' stamp: 'ar 2/10/2012 13:39' prior: 50894418!
             jsonString: aString on: stream
	"Encodes a string"

	stream nextPut: $".
	aString do:[:ch| self jsonChar: ch on: stream].
	stream nextPut: $".
! !
!WebUtils class methodsFor: 'json-decode' stamp: 'ar 2/10/2012 13:43' prior: 50894425!
                      jsonArrayFrom: stream
	"Decodes a JSON [value, *] array from the stream"

	| ch result |
	(ch := stream next) = $[ ifFalse:[^self error: 'JSON Array expected'].
	stream skipSeparators.
	stream peek = $] ifTrue:[stream next. ^#()].
	result := WriteStream on: (Array new: 10).
	["Decode the next value"
	stream skipSeparators.
	result nextPut: (self jsonDecode: stream).
	stream skipSeparators.
	(ch := stream next) = $]] whileFalse:[
		ch = $, ifFalse:[^self error: 'Comma expected'].
	].

	^result contents! !
!WebUtils class methodsFor: 'json-decode' stamp: 'jmv 6/26/2017 19:52:56' prior: 50894444!
       jsonCharFrom: stream on: writeStream
	"Decodes a backslash-escaped character"

	| ch decoded |
	ch := stream next.
	ch = $u ifTrue: [
		String
			addUnicodeCodePoint: (Integer readFrom: (stream next: 4) readStream base: 16)
			to: writeStream
			hex: true.
		^ self ].
	decoded _ ch caseOf: {
		[$r] 	-> 	[Character cr].
		[$n] 	-> 	[Character lf].
		[$t] 	-> 	[Character tab].
		[$b] 	->	[Character backspace].
		[$f] 	->	[Character newPage].
	} otherwise: [ch].
	writeStream nextPut: decoded! !
!WebUtils class methodsFor: 'json-decode' stamp: 'ar 2/10/2012 13:48' prior: 50894462!
                        jsonDecode: stream
	"Decodes an arbitrary JSON encoded value from the given stream"

	stream skipSeparators.
	^stream peek caseOf: {
		[$"]		->	[self jsonStringFrom: stream].
		[$t]		->	[self jsonTrueFrom: stream].
		[$f]		->	[self jsonFalseFrom: stream].
		[$n]		->	[self jsonNullFrom: stream].
		[${]		-> 	[self jsonMapFrom: stream].
		[$[]		->	[self jsonArrayFrom: stream].
	} otherwise:[self jsonNumberFrom: stream].
! !
!WebUtils class methodsFor: 'json-decode' stamp: 'ar 2/10/2012 13:43' prior: 50894478!
jsonFalseFrom: stream
	"Decodes 'false' from aStream"

	((stream next: 5) = 'false' 
		and:[stream atEnd or:[stream peek isAlphaNumeric not]]) 
			ifFalse:[^self error: 'Expected ''false'''].
	^false! !
!WebUtils class methodsFor: 'json-decode' stamp: 'ar 2/10/2012 13:45' prior: 50894487!
                              jsonMapFrom: stream
	"Decodes a JSON {key:value, *} object from the stream"

	| map ch key value |
	map := Dictionary new.
	(ch := stream next) = ${ ifFalse:[^self error: 'JSON Object expected'].
	stream skipSeparators.
	stream peek = $} ifTrue:[^map].

	["Decode the next key:value pair"
	stream skipSeparators.
	key := self jsonStringFrom: stream.
	stream skipSeparators.
	stream next = $: ifFalse:[^self error: 'Key-value pair expected'].
	value := self jsonDecode: stream.
	map at: key put: value.
	stream skipSeparators.
	(ch := stream next) = $}] whileFalse:[
		ch = $, ifFalse:[^self error: 'Comma expected'].
	].

	^map! !
!WebUtils class methodsFor: 'json-decode' stamp: 'ar 2/10/2012 13:43' prior: 50894509!
                  jsonNullFrom: stream
	"Decodes 'null' from aStream"

	((stream next: 4) = 'null'
		and:[stream atEnd or:[stream peek isAlphaNumeric not]]) 
			ifFalse:[^self error: 'Expected ''null'''].
	^nil! !
!WebUtils class methodsFor: 'json-decode' stamp: 'ar 2/10/2012 13:44' prior: 50894518!
     jsonNumberFrom: stream
	"Decodes a JSON number from the stream"

	| ascii integer fraction scale sign expSign exponent value ch |
	integer := fraction := 0. sign := scale := exponent := expSign := 1.
	ascii := stream next asciiValue.
	ascii = 45 "$- asciiValue" ifTrue:[
		sign := -1.
		ascii := stream next asciiValue.
	].
	"JSON requires at least one digit"
	(ascii >= 48 and:[ascii <= 57]) ifFalse:[^self error: 'Digit expected'].

	"Read the integer part"
	integer := ascii - 48.
	[ch := stream next ifNil:[^integer * sign].
	ascii := ch asciiValue.
	ascii >= 48 and:[ascii <= 57]] whileTrue:[
		integer := (integer * 10) + (ascii - 48).
	].

	ascii = 46 "$. asciiValue" ifTrue:[
		"Read the fraction part"
		[ch := stream next ifNil:[^(integer * scale + fraction * sign) asFloat / scale].
		ascii := ch asciiValue.
		ascii >= 48 and:[ascii <= 57]] whileTrue:[
			fraction := (fraction * 10) + (ascii - 48).
			scale := scale * 10.
		].
		value := (integer * scale + fraction * sign) asFloat / scale asFloat.
	] ifFalse:[value := integer * sign].

	(ascii =  69 "$E asciiValue" or:[ascii =  101 "$e asciiValue"]) ifTrue:[
		"Read exponent"
		ascii := stream next asciiValue.
		ascii = $- ifTrue:[
			expSign := -1.
			ascii := stream next asciiValue.
		] ifFalse:[ascii = $+ ifTrue:[ascii := stream next asciiValue]].
		exponent := ascii - 48.
		[ch := stream next ifNil:[^value * (10 raisedTo: expSign * exponent)].
		ascii := ch asciiValue.
		ascii >= 48 and:[ascii <= 57]] whileTrue:[
			exponent := (exponent * 10) + (ascii - 48).			
		].
		exponent := exponent * expSign.
	].

	"Skip back before last character since number might be part of a sequence
	like 1, 2, 3, 4, etc (which would eat the trailing comma)"
	ch isAlphaNumeric ifTrue:[^self error: 'Delimiter expected'].
	stream skip: -1.

	exponent = 1 ifFalse:[
		exponent < 0 ifTrue:[value := value asFloat].
		value := value * (10 raisedTo: exponent).
	].
	^value! !
!WebUtils class methodsFor: 'json-decode' stamp: 'jmv 6/26/2017 19:49:10' prior: 50894581!
                       jsonStringFrom: stream
	"Decodes a JSON encoded string"

	| ch result |
	(ch := stream next) = $" 
		ifFalse:[^self error: 'String expected'].
	result := WriteStream on: (String new: 20).
	[(ch := stream next) == nil] whileFalse:[
		ch = $" ifTrue:[^result contents].
		ch = $\
			ifTrue: [ self jsonCharFrom: stream on: result ]
			ifFalse: [ result nextPut: ch ].
	].
	^self error: 'Unterminated string'! !
!WebUtils class methodsFor: 'json-decode' stamp: 'ar 2/10/2012 13:46' prior: 50894596!
                jsonTrueFrom: stream
	"Decodes 'true' from aStream"

	((stream next: 4) = 'true'
		and:[stream atEnd or:[stream peek isAlphaNumeric not]]) 
			 ifFalse:[^self error: 'Expected ''true'''].
	^true! !
!WebUtils class methodsFor: 'misc' stamp: 'DSG 3/28/2015 22:49' prior: 50894605!
         logEntryFor: request response: response
	"Create a log entry in common log format from the given request / response"

	| entry logdate logsize |

	"CLF prints date as [day/month/year:hour:min:sec zone]"
	logdate := String streamContents:[:s| | date |
		date := DateAndTime fromSeconds: Time localSecondClock.
		s nextPut: $[.
			date date printOn: s format: #( 1 2 3 $/ 2 1 2).
		s nextPut: $:.
			date time print24: true on: s.
		s nextPutAll:(' ',
			(date offset hours >= 0 ifTrue:['+'] ifFalse:['-']),
			(date offset hours abs asString padded: #left to: 2 with: $0),
			(date offset minutes abs asString padded: #left to: 2 with: $0)
		).
		s nextPut: $].
	].

	"CLF prints zero length as - "
	logsize := response contentLength ifNil:[0].
	logsize = 0 ifTrue:[logsize := '-'].

	entry := String streamContents:[:s|
		s 
			nextPutAll: (request remoteHost ifNil:[
				"Substitute with the host header"
				(request headerAt: 'host') copyUpTo: $:
			]);
			nextPutAll: ' -'; 	"RFC 1413 identity of client"
			nextPutAll: ' -';	"TODO: userid of authenticated user"
			nextPutAll: ' ', logdate;
			nextPutAll: ' "', request requestLine, '"';
			nextPutAll: ' ', response code asString;
			nextPutAll: ' ', logsize asString.
	].
	^entry
! !
!WebUtils class methodsFor: 'misc' stamp: 'pb 5/25/2016 01:29' prior: 50894646!
                       logRequest: request response: response on: streamOrFilename
	"Log a request in common log format on the given stream / file."

	| entry |

	"Create the log entry for the request/response pair"
	entry := self logEntryFor: request response: response.

	"If the argument is a string, it represents the file name to log to"
	streamOrFilename isString
		ifTrue: [
			streamOrFilename asFileEntry appendStreamDo: [ :stream |
				stream nextPutAll: entry; newLine ]]
		ifFalse: [
			streamOrFilename nextPutAll: entry; newLine.
			streamOrFilename flush ]! !
!WebUtils class methodsFor: 'misc' stamp: 'ar 7/21/2010 00:09' prior: 50894666!
        mcVersion
	"Answers the Monticello version of WebServer's MC package"

	| version |
	Smalltalk at: #MCWorkingCopy ifPresent:[:mc|
		mc managersForClass: self do:[:wc|
			wc ancestors ifNotEmpty:[:ancestry| version := ancestry first name]]].
	^version ifNil:[''].! !
!WebUtils class methodsFor: 'misc' stamp: 'ar 11/17/2011 10:16' prior: 50894677!
     platformName
	"Return the name of the platform we're running on."

	^Smalltalk getSystemAttribute: 1001! !
!WebUtils class methodsFor: 'misc' stamp: 'DSG 3/28/2015 19:59' prior: 50894683!
    urlEncode: urlString
	"For backwards compatibility only. Use 'urlString urlEncoded' if you can."

	^urlString encodeForHTTP! !
!WebUtils class methodsFor: 'misc' stamp: 'ar 11/17/2011 10:06' prior: 50894689!
                vmVersion	
	"Return a string identifying the interpreter version"

	^Smalltalk getSystemAttribute: 1004! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/20/2010 12:45' prior: 50894695!
      md5Digest: aStringOrByteArray
	"This creates a little endian hex string to be used with various auth methods
	This is the same as htdigest (apache) uses for its md5 digest auth db"

	^(self md5HashStream: (ReadStream on: aStringOrByteArray asByteArray)) reversed hex! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/25/2010 23:29' prior: 50894706!
   md5HashStream: aStream
	"self md5HashStream: (ReadStream on: 'foo')"

	| start buffer bytes sz n words hash |
	hash := WordArray 
		with: 16r67452301 
		with: 16rEFCDAB89 
		with: 16r98BADCFE 
		with: 16r10325476.
	words := WordArray new: 16.
	buffer := ByteArray new: 64.
	start := aStream position.
	[aStream atEnd] whileFalse: [
		bytes := aStream nextInto: buffer.
		(bytes size < 64 or:[aStream atEnd]) ifTrue:[
			sz := bytes size.
			buffer replaceFrom: 1 to: sz with: bytes startingAt: 1.
			buffer from: sz+1 to: buffer size put: 0.
			sz < 56 ifTrue:[
				buffer at: sz + 1 put: 128. "trailing bit"
			] ifFalse:[
				"not enough room for the length, so just pad this one, then..."
				sz < 64 ifTrue:[buffer at: sz + 1 put: 128].
				1 to: 16 do:[:i| words at: i put: (buffer unsignedLongAt: i*4-3 bigEndian: false)].
				self md5Transform: words hash: hash.
				"process one additional block of padding ending with the length"
				buffer atAllPut: 0.
				sz = 64 ifTrue: [buffer at: 1 put: 128].
			].
			"Fill in the final 8 bytes with the 64-bit length in bits."
			n := (aStream position - start) * 8.
			7 to: 0 by: -1 do:[:i| buffer at: (buffer size - i) put: ((n bitShift: 7 - i * -8) bitAnd: 255)].
		].
		1 to: 16 do:[:i| words at: i put: (buffer unsignedLongAt: i*4-3 bigEndian: false)].
		self md5Transform: words hash: hash.
	].
	bytes := ByteArray new: 16.
	bytes unsignedLongAt: 1 put: (hash at: 4) bigEndian: true.
	bytes unsignedLongAt: 5 put: (hash at: 3) bigEndian: true.
	bytes unsignedLongAt: 9 put: (hash at: 2) bigEndian: true.
	bytes unsignedLongAt: 13 put: (hash at: 1) bigEndian: true.
	^bytes
! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/23/2010 09:28' prior: 50894760!
               md5Transform: in hash: hash
	"This adds the incoming words to the existing hash"

	| a b c d |
	<primitive: 'primitiveMD5Transform' module: 'CroquetPlugin'>
	a := hash at: 1.
	b := hash at: 2.
	c := hash at: 3.
	d := hash at: 4.

	a := self step1: a x: b y: c z: d data: (in at:  1) add: 16rD76AA478 shift: 7.
	d := self step1: d x: a y: b z: c data: (in at:  2) add: 16rE8C7B756 shift: 12.
	c := self step1: c x: d y: a z: b data: (in at:  3) add: 16r242070DB shift: 17.
	b := self step1: b x: c y: d z: a data: (in at:  4) add: 16rC1BDCEEE shift: 22.
	a := self step1: a x: b y: c z: d data: (in at:  5) add: 16rF57C0FAF shift:  7.
	d := self step1: d x: a y: b z: c data: (in at:  6) add: 16r4787C62A shift: 12.
	c := self step1: c x: d y: a z: b data: (in at:  7) add: 16rA8304613 shift: 17.
	b := self step1: b x: c y: d z: a data: (in at:  8) add: 16rFD469501 shift: 22.
	a := self step1: a x: b y: c z: d data: (in at:  9) add: 16r698098D8 shift:  7.
	d := self step1: d x: a y: b z: c data: (in at: 10) add: 16r8B44F7AF shift: 12.
	c := self step1: c x: d y: a z: b data: (in at: 11) add: 16rFFFF5BB1 shift: 17.
	b := self step1: b x: c y: d z: a data: (in at: 12) add: 16r895CD7BE shift: 22.
	a := self step1: a x: b y: c z: d data: (in at: 13) add: 16r6B901122 shift:  7.
	d := self step1: d x: a y: b z: c data: (in at: 14) add: 16rFD987193 shift: 12.
	c := self step1: c x: d y: a z: b data: (in at: 15) add: 16rA679438E shift: 17.
	b := self step1: b x: c y: d z: a data: (in at: 16) add: 16r49B40821 shift: 22.

	a := self step2: a x: b y: c z: d data: (in at:  2) add: 16rF61E2562 shift:  5.
	d := self step2: d x: a y: b z: c data: (in at:  7) add: 16rC040B340 shift:  9.
	c := self step2: c x: d y: a z: b data: (in at: 12) add: 16r265E5A51 shift: 14.
	b := self step2: b x: c y: d z: a data: (in at:  1) add: 16rE9B6C7AA shift: 20.
	a := self step2: a x: b y: c z: d data: (in at:  6) add: 16rD62F105D shift:  5.
	d := self step2: d x: a y: b z: c data: (in at: 11) add: 16r02441453 shift:  9.
	c := self step2: c x: d y: a z: b data: (in at: 16) add: 16rD8A1E681 shift: 14.
	b := self step2: b x: c y: d z: a data: (in at:  5) add: 16rE7D3FBC8 shift: 20.
	a := self step2: a x: b y: c z: d data: (in at: 10) add: 16r21E1CDE6 shift:  5.
	d := self step2: d x: a y: b z: c data: (in at: 15) add: 16rC33707D6 shift:  9.
	c := self step2: c x: d y: a z: b data: (in at:  4) add: 16rF4D50D87 shift: 14.
	b := self step2: b x: c y: d z: a data: (in at:  9) add: 16r455A14ED shift: 20.
	a := self step2: a x: b y: c z: d data: (in at: 14) add: 16rA9E3E905 shift:  5.
	d := self step2: d x: a y: b z: c data: (in at:  3) add: 16rFCEFA3F8 shift:  9.
	c := self step2: c x: d y: a z: b data: (in at:  8) add: 16r676F02D9 shift: 14.
	b := self step2: b x: c y: d z: a data: (in at: 13) add: 16r8D2A4C8A shift: 20.

	a := self step3: a x: b y: c z: d data: (in at:  6) add: 16rFFFA3942 shift:  4.
	d := self step3: d x: a y: b z: c data: (in at:  9) add: 16r8771F681 shift: 11.
	c := self step3: c x: d y: a z: b data: (in at: 12) add: 16r6D9D6122 shift: 16.
	b := self step3: b x: c y: d z: a data: (in at: 15) add: 16rFDE5380C shift: 23.
	a := self step3: a x: b y: c z: d data: (in at:  2) add: 16rA4BEEA44 shift:  4.
	d := self step3: d x: a y: b z: c data: (in at:  5) add: 16r4BDECFA9 shift: 11.
	c := self step3: c x: d y: a z: b data: (in at:  8) add: 16rF6BB4B60 shift: 16.
	b := self step3: b x: c y: d z: a data: (in at: 11) add: 16rBEBFBC70 shift: 23.
	a := self step3: a x: b y: c z: d data: (in at: 14) add: 16r289B7EC6 shift:  4.
	d := self step3: d x: a y: b z: c data: (in at:  1) add: 16rEAA127FA shift: 11.
	c := self step3: c x: d y: a z: b data: (in at:  4) add: 16rD4EF3085 shift: 16.
	b := self step3: b x: c y: d z: a data: (in at:  7) add: 16r04881D05 shift: 23.
	a := self step3: a x: b y: c z: d data: (in at: 10) add: 16rD9D4D039 shift:  4.
	d := self step3: d x: a y: b z: c data: (in at: 13) add: 16rE6DB99E5 shift: 11.
	c := self step3: c x: d y: a z: b data: (in at: 16) add: 16r1FA27CF8 shift: 16.
	b := self step3: b x: c y: d z: a data: (in at:  3) add: 16rC4AC5665 shift: 23.

	a := self step4: a x: b y: c z: d data: (in at:  1) add: 16rF4292244 shift:  6.
	d := self step4: d x: a y: b z: c data: (in at:  8) add: 16r432AFF97 shift: 10.
	c := self step4: c x: d y: a z: b data: (in at: 15) add: 16rAB9423A7 shift: 15.
	b := self step4: b x: c y: d z: a data: (in at:  6) add: 16rFC93A039 shift: 21.
	a := self step4: a x: b y: c z: d data: (in at: 13) add: 16r655B59C3 shift:  6.
	d := self step4: d x: a y: b z: c data: (in at:  4) add: 16r8F0CCC92 shift: 10.
	c := self step4: c x: d y: a z: b data: (in at: 11) add: 16rFFEFF47D shift: 15.
	b := self step4: b x: c y: d z: a data: (in at:  2) add: 16r85845DD1 shift: 21.
	a := self step4: a x: b y: c z: d data: (in at:  9) add: 16r6FA87E4F shift:  6.
	d := self step4: d x: a y: b z: c data: (in at: 16) add: 16rFE2CE6E0 shift: 10.
	c := self step4: c x: d y: a z: b data: (in at:  7) add: 16rA3014314 shift: 15.
	b := self step4: b x: c y: d z: a data: (in at: 14) add: 16r4E0811A1 shift: 21.
	a := self step4: a x: b y: c z: d data: (in at:  5) add: 16rF7537E82 shift:  6.
	d := self step4: d x: a y: b z: c data: (in at: 12) add: 16rBD3AF235 shift: 10.
	c := self step4: c x: d y: a z: b data: (in at:  3) add: 16r2AD7D2BB shift: 15.
	b := self step4: b x: c y: d z: a data: (in at: 10) add: 16rEB86D391 shift: 21.

	a := (a + (hash at: 1)) bitAnd: 16rFFFFFFFF. hash at: 1 put: a.
	b := (b + (hash at: 2)) bitAnd: 16rFFFFFFFF. hash at: 2 put: b.
	c := (c + (hash at: 3)) bitAnd: 16rFFFFFFFF. hash at: 3 put: c.
	d := (d + (hash at: 4)) bitAnd: 16rFFFFFFFF. hash at: 4 put: d.

	^hash! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/23/2010 09:28' prior: 50894940!
                         rotate: value by: amount
	"Rotate value left by amount"

	| lowMask highMask |
	lowMask := (1 bitShift: 32-amount) - 1.
	highMask := 16rFFFFFFFF - lowMask.
	^((value bitAnd: lowMask) bitShift: amount) + 
		((value bitAnd: highMask) bitShift: amount-32)! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/23/2010 09:28' prior: 50894950!
                 step1: w x: x y: y z: z data: data add: add shift: s
	"Step 1 in MD5 transformation"

	| f result |
	f := z bitXor: (x bitAnd: (y bitXor: z)).
	result := w + f + data + add.
	result := self rotate: result by: s.
	^result + x bitAnd: 16rFFFFFFFF! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/23/2010 09:28' prior: 50894960!
                         step2: w x: x y: y z: z data: data add: add shift: s
	"Step 2 in MD5 transformation"

	| f result |
	f := y bitXor: (z bitAnd: (x bitXor: y)).
	result := w + f + data + add.
	result := self rotate: result by: s.
	^result + x bitAnd: 16rFFFFFFFF! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/23/2010 09:28' prior: 50894970!
                         step3: w x: x y: y z: z data: data add: add shift: s
	"Step 3 in MD5 transformation"

	| f result |
	f := (x bitXor: y) bitXor: z.
	result := w + f + data + add.
	result := self rotate: result by: s.
	^result + x bitAnd: 16rFFFFFFFF! !
!WebUtils class methodsFor: 'md5' stamp: 'ar 2/23/2010 09:28' prior: 50894980!
     step4: w x: x y: y z: z data: data add: add shift: s
	"Step 4 in MD5 transformation"

	| f result |
	f := y bitXor: (x bitOr: (z  bitXor: 16rFFFFFFFF)).
	result := w + f + data + add.
	result := self rotate: result by: s.
	^result + x bitAnd: 16rFFFFFFFF! !
!WebUtils class methodsFor: 'auth utils' stamp: 'DSG 12/5/2013 17:20' prior: 50894991!
       parseAuthParams: authHeader
	"Parse the auth header to find authentication parameters"

	| authParams stream key value|
	authParams := Dictionary new.
	stream := ReadStream on: authHeader.
	authParams at: 'method' put: (stream upTo: Character space) asLowercase.
	[stream skipSeparators.
	stream atEnd] whileFalse:[
		key := stream upTo: $=.
		stream skipSeparators.
		stream peek = $" 
			ifTrue:[value := stream next; upTo: $". stream upTo: $,]
			ifFalse:[value := stream upToAny: ' ,' asCharacterSet].
		authParams at: key asLowercase put: value.
	].
	^authParams! !
!WebUtils class methodsFor: 'quoting' stamp: 'ar 3/31/2010 08:43' prior: 50895011!
                  quote: aString
	"Quote the given string, escaping as necessary any embedded quotes"

	^'"', (aString copyReplaceAll: '"' with: '\"'), '"'
! !
!WebUtils class methodsFor: 'quoting' stamp: 'ar 3/31/2010 08:45' prior: 50895018!
                               unquote: aString
	"Unquote the given string, unescaping as necessary any embedded quotes"

	(aString beginsWith: '"') ifFalse:[^aString].
	(aString endsWith: '"') ifFalse:[^aString].
	^(aString copyReplaceAll: '\"' with: '"') allButFirst allButLast! !
!WebUtils class methodsFor: 'headers' stamp: 'jmv 6/25/2017 19:36:55' prior: 50895029!
             readHeadersFrom: aStream
	"Parse http headers and answer a collection of key -> value pairs."

	| headers nextLine existing |
	headers := OrderedCollection new.
	[nextLine := aStream upToAll: String crlfString.
	nextLine isEmpty] whileFalse:[
		nextLine first isSeparator ifTrue:["Continuation as per HTTP 1.1 spec"
			existing := headers last.
			existing value: (existing value, String space, nextLine withBlanksTrimmed).
		] ifFalse:["Regular header"
			headers add: 
				(nextLine copyUpTo: $:) asLowercase ->
					(nextLine copyAfter: $:) withBlanksTrimmed.
		].
	].
	^headers! !
!SqueakSSL methodsFor: 'convenience' stamp: 'ar 7/18/2010 20:42' prior: 50895050!
     accept
	"Convenience API. Perform an SSL server handshake.
	Raises an error if something goes wrong."

	| inbuf outbuf count result |

	inbuf := ByteArray new: 4096.
	outbuf := ByteArray new: 4096.
	count := 0.

	[self isConnected] whileFalse:[
		"Read input"
		count := self readDataInto: inbuf.
		result := self accept: inbuf from: 1 to: count into: outbuf.

		"Check for errors first"
		result < -1 ifTrue:[^self error: 'SSL accept failed with code: ', result].

		"If a token has been produced in the handshake, send it to the remote"
		result > 0 ifTrue:[self writeData: outbuf count: result].
	].
! !
!SqueakSSL methodsFor: 'convenience' stamp: 'ar 7/16/2010 23:10' prior: 50895072!
               connect
	"Convenience API. Perform an SSL client handshake. 
	Raises an error if something goes wrong."

	| inbuf outbuf count result |

	inbuf := ByteArray new: 4096.
	outbuf := ByteArray new: 4096.
	count := 0.

	"Begin the SSL handshake"
	[result := self connect: inbuf from: 1 to: count into: outbuf.
	result = 0] whileFalse:[
		"Check for errors first"
		result < -1 ifTrue:[^self error: 'SSL connect failed with code: ', result].

		"If a token has been produced in the handshake, send it to the remote"
		result > 0 ifTrue:[self writeData: outbuf count: result].

		"Read more input and repeat"
		count := self readDataInto: inbuf.
	].! !
!SqueakSSL methodsFor: 'convenience' stamp: 'ar 7/18/2010 14:18' prior: 50895095!
        decrypt: data
	"Convenience API. Decrypt incoming data and return the result.

	Warning: This method may produce more or less results than expected
	unless called with exactly one SSL/TLS frame."

	| buf count |
	buf := data class new: 4096.
	count := self decrypt: data from: 1 to: data size into: buf.
	count < 0 ifTrue:[self error: 'Decryption failed, code: ', count].
	^buf copyFrom: 1 to: count! !
!SqueakSSL methodsFor: 'convenience' stamp: 'ar 7/18/2010 14:18' prior: 50895110!
                           encrypt: data
	"Convenience API. Encrypt incoming data and return the result."

	| buf count |
	buf := data class new: data size + 100.
	count := self encrypt: data from: 1 to: data size into: buf.
	count < 0 ifTrue:[self error: 'Decryption failed, code: ', count].
	^buf copyFrom: 1 to: count! !
!SqueakSSL methodsFor: 'convenience' stamp: 'ar 7/16/2010 23:04' prior: 50895122!
     receiveData
	"Convenience API. Receive data and decrypt it."

	| inbuf outbuf count |
	inbuf := String new: 4096.
	outbuf := String new: 4096.

	^String streamContents:[:s|
		"Read the next input bytes"
		count := self readDataInto: inbuf.
		"Push the input bytes into the SSL"
		count := self decrypt: inbuf from: 1 to: count into: outbuf.
		"And keep draining as long as output is being produced"
		[count > 0] whileTrue:[
			s next: count putAll: outbuf.
			count := self decrypt: inbuf from: 1 to: 0 into: outbuf.
		].
	].! !
!SqueakSSL methodsFor: 'convenience' stamp: 'ar 7/16/2010 23:04' prior: 50895141!
                            sendData: inbuf
	"Convenience API. Encrypt and send data"

	| outbuf count |
	outbuf := inbuf class new: inbuf size + 100.
	count := self encrypt: inbuf from: 1 to: inbuf size into: outbuf.
	^self writeData: outbuf count: count.! !
!SqueakSSL methodsFor: 'operations' stamp: 'ar 7/16/2010 23:02' prior: 50895151!
       accept: srcBuf from: start to: stop into: dstBuf
	"Start or continue the server handshake using the given input token."

	^self primitiveSSL: handle accept: srcBuf startingAt: start count: stop-start+1 into: dstBuf! !
!SqueakSSL methodsFor: 'operations' stamp: 'eem 3/23/2016 16:55' prior: 50895160!
                    connect: srcBuf from: start to: stop into: dstBuf
	"Start or continue the server handshake using the given input token."

	| r |
	r := self primitiveSSL: handle connect: srcBuf startingAt: start count: stop-start+1 into: dstBuf.
	r <= 0 ifTrue:
		[Processor yield].
	^r! !
!SqueakSSL methodsFor: 'operations' stamp: 'ar 7/16/2010 21:58' prior: 50895171!
                              decrypt: srcBuf from: start to: stop into: dstBuf
	"Decrypt the input in srcBuf into the provided output buffer.

	Clients are expected to adhere to the following rules:
		* The size of dstBuf must be large enough for the largest encrypted packet.
		* Clients must not call this method with a huge srcBuf (tens of kb of data)
		* After having called this method with new input, clients must call it 
		   with NO input until all data has been 'drained' for example:
			count := squeakSSL decrypt: srcBuf into: dstBuf.
			[count > 0] whileTrue:[
				count := squeakSSL decrypt: #[] into: dstBuf.
			].
	"

	^self primitiveSSL: handle decrypt: srcBuf startingAt: start count: stop-start+1 into: dstBuf! !
!SqueakSSL methodsFor: 'operations' stamp: 'ar 7/16/2010 21:59' prior: 50895195!
                encrypt: srcBuf from: start to: stop into: dstBuf
	"Encrypt the input in srcBuf into the provided output buffer.
	The output buffer must be large enough to include the framing information."

	^self primitiveSSL: handle encrypt: srcBuf startingAt: start count: stop-start+1 into: dstBuf! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/18/2010 21:31' prior: 50895207!
               certName
	"The name of the (local) certificate to provide to the remote peer."

	^self primitiveSSL: handle getStringProperty: 1! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 11/16/2011 16:48' prior: 50895214!
           certName: aString
	"Sets the name of the (local) certificate to provide to the remote peer.
	OpenSSL:
		The name is the full path to a .pem file.
	WinSSL:
		The name is matched against the 'friendly name' of a certificate in the cert store.
	"

	^self primitiveSSL: handle setStringProperty: 1 toValue: (aString ifNil:[''])! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/18/2010 21:27' prior: 50895227!
         certState
	"Returns the certificate verification bits. The returned value indicates
	whether the certificate is valid. The two standard values are:

		0 - The certificate is valid.
		-1 - No certificate has been provided by the peer.

	Otherwise, the result is a bit mask of the following values:

		1 - If set, there is an unspecified issue with the cert (generic error)
		2 - If set, the root CA is untrusted (usually a self-signed cert)
		4 - If set, the certificate is expired.
		8 - If set, the certificate is used for the wrong purpose
		16 - If set, the CN of the certificate is invalid.
		32 - If set, the certificate was revoked.

	"
	^self primitiveSSL: handle getIntProperty: 3! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/18/2010 21:26' prior: 50895251!
                            logLevel
	"Returns the log level of the ssl instance"

	^self primitiveSSL: handle getIntProperty: 1! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/18/2010 21:27' prior: 50895257!
        logLevel: aNumber
	"Sets the log level of the ssl instance"

	^self primitiveSSL: handle setIntProperty: 1 toValue: aNumber! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/18/2010 21:31' prior: 50895263!
                 peerName
	"Returns the certificate name of the remote peer.
	The method only returns a name if the certificate has been verified."

	^self primitiveSSL: handle getStringProperty: 0! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/18/2010 21:25' prior: 50895271!
                        pluginVersion
	"Returns the version of the plugin"

	^self primitiveSSL: handle getIntProperty: 0! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/15/2010 20:16' prior: 50895277!
           readBlock
	"The block used to read data where required. The block takes one argument,
	the buffer to fill with data and is expected to return the number of bytes read."

	^readBlock! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/15/2010 20:16' prior: 50895285!
                       readBlock: aBlock
	"The block used to read data where required. The block takes one argument,
	the buffer to fill with data and is expected to return the number of bytes read."

	readBlock := aBlock! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ul 10/16/2014 10:35' prior: 50895294!
     serverName: aString
	"Sets the name to use with the Server Name Indication TLS extension. Which should be a valid FQDN. No WinSSL support yet."

	^[ self primitiveSSL: handle setStringProperty: 2 toValue: aString ]
		on: Error
		do: [ "nothing" ]! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/18/2010 21:27' prior: 50895304!
                      sslState
	"Returns the current state of the SSL connection:
		0 - Unused.
		1 - In accept handshake.
		2 - In connect handshake.
		3 - Connected.
	"
	^self primitiveSSL: handle getIntProperty: 2
		! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/15/2010 20:17' prior: 50895313!
       writeBlock
	"The block used to write data where required. The block takes two arguments,
	the buffer and the number of bytes to be written from the buffer."

	^writeBlock! !
!SqueakSSL methodsFor: 'accessing' stamp: 'ar 7/15/2010 20:17' prior: 50895321!
  writeBlock: aBlock
	"The block used to write data where required. The block takes two arguments,
	the buffer and the number of bytes to be written from the buffer."

	writeBlock := aBlock! !
!SqueakSSL methodsFor: 'initialize' stamp: 'ar 7/16/2010 22:01' prior: 50895329!
                destroy
	"Destroys the underlying platform handle"

	handle ifNotNil:[
		self primitiveSSLDestroy: handle.
		handle := nil.
	].! !
!SqueakSSL methodsFor: 'initialize' stamp: 'ar 7/16/2010 23:10' prior: 50895336 overrides: 16896425!
                        initialize
	"Initialize the receiver"

	handle := self primitiveSSLCreate.
! !
!SqueakSSL methodsFor: 'initialize' stamp: 'ar 7/18/2010 20:37' prior: 50895341!
on: aSocket
	"Convenience API. Set up SqueakSSL to operate on a standard TCP socket.
	Generally not very useful for real applications (it lacks error handling etc) 
	but very helpful for debugging and other experiments."

	self readBlock:[:inbuf|
		aSocket waitForDataIfClosed:[].
		aSocket receiveDataInto: inbuf.
	].
	self writeBlock:[:outbuf :count|
		aSocket sendData: (outbuf copyFrom: 1 to: count).
	].! !
!SqueakSSL methodsFor: 'testing' stamp: 'ar 7/16/2010 22:37' prior: 50895356!
                      isConnected
	"Returns true if the SSL handshake has been completed"

	^self sslState = 3! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 21:57' prior: 50895361!
                   primitiveSSL: sslHandle accept: srcbuf startingAt: start count: length into: dstbuf
	"Primitive. Starts or continues a server handshake using the provided data.
	Will eventually produce output to be sent to the server.
	Returns:
		> 0	 - Number of bytes to be sent to the server
		0	 - Success. The connection is established.
		-1 	 - More input is required.
		< -1 - Other errors
	"
	<primitive: 'primitiveAccept' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 21:57' prior: 50895378!
 primitiveSSL: sslHandle connect: srcbuf startingAt: start count: length into: dstbuf
	"Primitive. Starts or continues a client handshake using the provided data.
	Will eventually produce output to be sent to the server.
	Returns:
		> 0	 - Number of bytes to be sent to the server
		0	 - Success. The connection is established.
		-1 	 - More input is required.
		< -1 - Other errors
	"
	<primitive: 'primitiveConnect' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 21:58' prior: 50895395!
                               primitiveSSL: sslHandle decrypt: srcbuf startingAt: start count: length into: dstbuf
	"Primitive. Takes incoming data for decryption and continues to decrypt data.
	Returns the number of bytes produced in the output"

	<primitive: 'primitiveDecrypt' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 21:59' prior: 50895407!
      primitiveSSL: sslHandle encrypt: srcbuf startingAt: start count: length into: dstbuf
	"Primitive. Encrypts the incoming buffer into the result buffer.
	Returns the number of bytes produced as a result."

	<primitive: 'primitiveEncrypt' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 22:00' prior: 50895418!
                    primitiveSSL: sslHandle getIntProperty: propID
	"Primitive. Returns a string property from an SSL session."

	<primitive: 'primitiveGetIntProperty' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 21:59' prior: 50895427!
            primitiveSSL: sslHandle getStringProperty: propID
	"Primitive. Returns a string property from an SSL session."

	<primitive: 'primitiveGetStringProperty' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 1/12/2011 09:40' prior: 50895436!
      primitiveSSL: sslHandle setIntProperty: propID toValue: anInteger
	"Primitive. Sets a string property in an SSL session."

	<primitive: 'primitiveSetIntProperty' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 22:00' prior: 50895445!
                              primitiveSSL: sslHandle setStringProperty: propID toValue: aString
	"Primitive. Sets a string property in an SSL session."

	<primitive: 'primitiveSetStringProperty' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 22:01' prior: 50895454!
                          primitiveSSLCreate
	"Primitive. Creates and returns a new SSL handle"

	<primitive: 'primitiveCreate' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'primitives' stamp: 'ar 7/16/2010 22:01' prior: 50895461!
                          primitiveSSLDestroy: sslHandle
	"Primitive. Destroys the SSL session handle"

	<primitive: 'primitiveDestroy' module: 'SqueakSSL'>
	^self primitiveFailed! !
!SqueakSSL methodsFor: 'private' stamp: 'ar 7/15/2010 20:08' prior: 50895468!
                     readDataInto: aBuffer
	"Private. Read actual data into the given buffer.
	Return the number of bytes read."

	^readBlock value: aBuffer! !
!SqueakSSL methodsFor: 'private' stamp: 'ar 11/16/2011 16:31' prior: 50895475!
      setStringProperty: index to: aString
	"Private. Use with caution"

	^self primitiveSSL: handle setStringProperty: index toValue: aString! !
!SqueakSSL methodsFor: 'private' stamp: 'ar 7/15/2010 20:08' prior: 50895482!
      writeData: aBuffer count: count
	"Private. Write actual data from the given buffer."

	writeBlock value: aBuffer value: count! !
!SqueakSSL class methodsFor: 'utilities' stamp: 'ar 8/7/2010 12:36' prior: 50895489!
          checkCert: certName
	"Attempt to verify the cert with the given name by performing 
	an SSL handshake. Raises an error if there is an issue with the cert,
	returns the peer name from the cert if successful."

	| sslClient sslServer inbuf outbuf result |
	inbuf := ByteArray new: 4096.
	outbuf := ByteArray new: 4096.

	["Perform the SSL handshake"
	sslClient := SqueakSSL new.
	sslServer := SqueakSSL new.
	sslServer certName: certName.

	result := 0.
	[result := sslClient connect: inbuf from: 1 to: result into: outbuf.
	result = 0] whileFalse:[
		result < -1 ifTrue:[^self error: 'SSL handshake failed (client code: ', result, ')'].
		result := sslServer accept: outbuf from: 1 to: result into: inbuf.
		result < -1 ifTrue:[^self error: 'SSL handshake failed (server code: ', result, ')'].
	].

	"Handshake complete. Check the cert status"
	sslClient certState = 0 ifFalse:[
		^self error: 'Certificate validation failed (code: ', sslClient certState, ')'.
	].

	"When successful, just return the peer name to the caller"
	^sslClient peerName
	
	] ensure:[
		sslClient ifNotNil:[sslClient destroy].
		sslServer ifNotNil:[sslServer destroy].
	].! !
!SqueakSSL class methodsFor: 'utilities' stamp: 'ar 11/17/2011 10:16' prior: 50895528!
          platformName
	"Return the name of the platform we're running on."

	^Smalltalk getSystemAttribute: 1001! !
!SqueakSSL class methodsFor: 'examples' stamp: 'ar 6/17/2012 14:58' prior: 50895534!
ensureSampleCert
	"Ensure that we have a sample certificate for the tests"

	SqueakSSL platformName caseOf: {
		['unix'] -> [^self ensureSampleCertFile].
		['Win32'] -> [^self ensureSampleCertInStore].
	} otherwise: [^nil].
! !
!SqueakSSL class methodsFor: 'examples' stamp: 'jmv 6/25/2017 21:14:29' prior: 50895544!
   ensureSampleCertFile
	"On Unix, we can simply create a valid cert file"

	| certName file |
	SqueakSSL platformName = 'unix' ifFalse:[^self].
	certName := self name, 'Cert.pem'.
	file _ DirectoryEntry currentDirectory // certName.
	file exists ifFalse: [
		 file writeStreamDo: [ :stream |
			stream nextPutAll: self exampleCertFile ]].
	^file pathName! !
!SqueakSSL class methodsFor: 'examples' stamp: 'ar 6/17/2012 14:57' prior: 50895558!
       ensureSampleCertInStore
	"Ensure that we have a valid certificate in the Windows certificate store"

	SqueakSSL platformName = 'Win32' ifFalse:[^self].
	"Undocumented. Allows importing a pfx w/o password.
	For the sole purpose of being able to run tests reliably"
	SqueakSSL new setStringProperty: 10001 to: self exampleCertPFX.
	^'testcert'. "Friendly name of test cert"
! !
!SqueakSSL class methodsFor: 'examples' stamp: 'ar 6/17/2012 14:57' prior: 50895572!
                   exampleCertFile
^'-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQDnCv/gxDCb2yq15qkNwYtdMOHfW609Ck7wfwjVgzSNg+Hw+1R4
+krWhYRsWoXZUcy9xPC9WhnFCFijcnROcWp7vByVukFkVPYgzk1OBFT484ZCLBme
08GqLSzZrjgu7c1Yu5M9MZQdZKObBvZzDFsnvFccfM7G5mX/FgATasYaLQIDAQAB
AoGBAMpUJ6B+LtNOKykAxir1w0Xo+OTRM/SwglC57tKMBAmp5MNUVbVb+w3B/yWk
YHLf35yQSwKHVOnnVThNkuzfBY+MBxnaZwCByKknB4viP1ihPmfwdtqW4QXt1CTH
53sc9BVPjs3Nn1eEVrc582RK0MhORmjvlz+GkTswXCiKD3tBAkEA+6/au8T8XUeM
y/KrtJ+U84seviw5nY93Yg7495n4ir1fojp4wFbWq1JTeM22zspZQOKzEsjxfHUi
UH3buH//OwJBAOsAlJdIZqTIJponBXho+jqLHqcZYXBz3znDzHZU1PLfyfq2DuVe
gt8UWa4VwlCZNtPi7g/iFPEcLOlf2XY3hbcCQFU7voVsNlKYknPW4JMwn87CREz+
yRw0o6dPjry7JdJGQ4a66n2oatZl8OKuN8Rb/lHc8+vepPkS6eX8WVZn8lUCQE2r
F3EYgLQdYoS4ONqe93S53hukC8w6v6A70iuZxfevdvXhjfLI1cAc3bbngh1ZRgGp
kry1H+7APSe0gg7MMukCQQD3jdsVoc4yhziMdpUMyw6R6vYCMJbMEr/tI6CJYBG4
lW+zdcLK2d6GNpZU80F49HOvxH4HMg1Qv+UUiuxT7jpG
-----END RSA PRIVATE KEY-----
-----BEGIN CERTIFICATE-----
MIICxTCCAi6gAwIBAgIJAN/0HUpkM5dvMA0GCSqGSIb3DQEBBQUAMEwxCzAJBgNV
BAYTAkdCMRIwEAYDVQQIEwlCZXJrc2hpcmUxEDAOBgNVBAcTB05ld2J1cnkxFzAV
BgNVBAoTDk15IENvbXBhbnkgTHRkMB4XDTExMDYwNjE0MzcyMFoXDTEyMDYwNTE0
MzcyMFowTDELMAkGA1UEBhMCR0IxEjAQBgNVBAgTCUJlcmtzaGlyZTEQMA4GA1UE
BxMHTmV3YnVyeTEXMBUGA1UEChMOTXkgQ29tcGFueSBMdGQwgZ8wDQYJKoZIhvcN
AQEBBQADgY0AMIGJAoGBAOcK/+DEMJvbKrXmqQ3Bi10w4d9brT0KTvB/CNWDNI2D
4fD7VHj6StaFhGxahdlRzL3E8L1aGcUIWKNydE5xanu8HJW6QWRU9iDOTU4EVPjz
hkIsGZ7TwaotLNmuOC7tzVi7kz0xlB1ko5sG9nMMWye8Vxx8zsbmZf8WABNqxhot
AgMBAAGjga4wgaswHQYDVR0OBBYEFGFwXmx2B6FB25yKMBm6g884lB2xMHwGA1Ud
IwR1MHOAFGFwXmx2B6FB25yKMBm6g884lB2xoVCkTjBMMQswCQYDVQQGEwJHQjES
MBAGA1UECBMJQmVya3NoaXJlMRAwDgYDVQQHEwdOZXdidXJ5MRcwFQYDVQQKEw5N
eSBDb21wYW55IEx0ZIIJAN/0HUpkM5dvMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcN
AQEFBQADgYEAbjMF7YzNQGovKD4NRjsnnKzQnUCTw6UquY2Oz/5SeLcPfLm8DudF
qppAjJjNpAgYC0yWoWcIxatYF/AsgGc2WL3hzI8oK7by6STfVi5RfLA6jS7lIDOv
4BUVsWZKADbEPsfiwed9b9MLLx8gpLLBrrr2rZpSyeDu4v16haV6wg8=
-----END CERTIFICATE-----
'! !
!SqueakSSL class methodsFor: 'examples' stamp: 'ar 6/17/2012 14:57' prior: 50895635!
exampleCertPFX
	^ #[48 130 7 50 2 1 3 48 130 6 248 6 9 42 134 72 134 247 13 1 7 1 160 130 6 233 4 130 6 229 48 130 6 225 48 130 3 191 6 9 42 134 72 134 247 13 1 7 6 160 130 3 176 48 130 3 172 2 1 0 48 130 3 165 6 9 42 134 72 134 247 13 1 7 1 48 28 6 10 42 134 72 134 247 13 1 12 1 6 48 14 4 8 88 63 142 234 51 170 181 1 2 2 8 0 128 130 3 120 247 113 35 203 188 93 48 77 162 13 174 138 246 211 61 198 135 133 35 173 48 145 17 17 215 165 194 254 211 158 248 98 76 208 35 117 179 66 160 245 118 213 71 174 220 87 29 165 94 87 52 172 173 229 251 165 205 43 242 114 250 65 123 9 113 132 130 241 182 211 44 155 163 177 90 52 4 72 47 37 0 101 149 229 33 113 144 29 160 38 44 28 178 1 193 134 122 194 233 165 233 236 242 121 119 47 72 143 91 146 148 29 155 94 202 17 124 77 21 110 194 197 228 149 28 9 129 74 139 76 1 180 245 235 1 191 177 175 158 159 16 12 52 96 80 243 34 26 155 45 210 192 183 217 230 122 13 19 197 214 172 29 151 24 153 136 8 203 72 220 199 79 22 79 251 248 83 204 246 117 242 216 219 53 20 182 121 148 173 221 177 210 171 107 56 101 159 63 110 23 37 168 47 25 252 163 244 206 125 220 122 108 251 223 93 219 129 242 137 229 199 216 254 230 235 62 33 236 39 211 255 184 37 134 152 51 188 182 195 242 18 43 29 134 16 183 48 35 0 100 231 121 145 91 99 171 183 225 246 126 56 190 198 188 79 227 107 211 1 65 113 64 71 9 120 185 75 138 171 220 155 182 35 226 180 121 108 83 253 1 232 183 151 97 160 73 117 218 140 182 224 58 227 40 171 59 143 213 187 41 57 174 185 115 190 81 111 110 81 149 122 114 170 14 10 168 113 248 120 13 247 231 160 162 14 4 227 41 48 249 153 2 107 130 176 16 144 160 116 41 25 241 225 126 110 24 7 69 221 205 108 141 73 164 61 76 219 248 94 142 69 171 109 44 45 75 34 179 205 40 62 161 191 222 79 131 239 230 86 201 124 48 226 212 13 178 187 248 29 191 81 98 229 199 91 204 153 220 112 227 71 116 233 131 134 160 244 78 77 84 128 144 63 123 210 148 221 133 201 44 41 218 89 64 253 172 106 220 127 130 151 11 88 155 57 172 192 196 165 93 177 197 139 128 45 223 88 64 196 6 15 153 160 156 168 3 202 102 129 134 25 75 61 51 190 216 218 178 101 250 91 255 169 245 170 55 228 47 111 197 10 145 196 180 96 217 97 49 104 134 62 228 86 203 242 207 75 246 77 115 20 81 40 173 107 113 251 9 172 18 21 10 102 117 86 63 252 91 190 64 190 140 1 146 70 75 130 110 94 129 107 155 24 253 117 204 162 32 30 102 75 62 42 204 19 159 205 62 23 26 192 23 79 128 205 18 72 198 84 83 107 16 234 121 61 33 101 48 72 32 197 119 216 2 24 213 8 133 63 181 65 15 192 138 240 203 219 69 207 68 66 233 168 195 13 212 235 34 22 142 226 141 25 131 250 123 202 13 163 142 214 170 179 240 5 21 201 143 103 4 70 139 84 104 115 140 248 163 15 71 220 197 222 251 170 15 158 82 26 214 186 154 139 37 245 77 174 37 29 218 103 99 14 230 36 75 72 140 186 89 146 99 10 10 94 68 150 159 234 64 234 32 254 117 187 160 102 46 25 25 77 184 134 151 2 236 109 63 58 186 148 239 251 122 59 123 200 29 42 70 51 118 54 71 184 71 0 111 178 10 81 141 247 59 254 67 191 214 239 78 238 217 142 184 87 107 111 14 102 97 61 229 94 118 187 52 204 25 52 233 177 250 17 62 113 22 163 2 250 13 5 238 103 80 143 201 25 73 33 93 212 81 126 207 29 138 72 191 60 182 132 255 76 97 254 188 96 81 72 73 43 118 191 106 118 41 112 45 96 255 148 59 79 111 89 61 199 106 75 199 154 21 60 25 124 156 168 42 233 7 102 203 120 161 126 125 118 110 114 229 174 26 31 215 140 120 85 171 146 207 176 159 100 102 215 83 142 39 61 255 84 12 19 235 207 44 199 229 220 98 38 167 113 24 88 66 31 115 135 184 70 133 129 3 57 44 202 230 225 37 70 222 228 126 130 216 185 247 48 130 3 26 6 9 42 134 72 134 247 13 1 7 1 160 130 3 11 4 130 3 7 48 130 3 3 48 130 2 255 6 11 42 134 72 134 247 13 1 12 10 1 2 160 130 2 166 48 130 2 162 48 28 6 10 42 134 72 134 247 13 1 12 1 3 48 14 4 8 157 82 4 247 110 231 147 241 2 2 8 0 4 130 2 128 81 141 63 61 170 27 13 87 195 101 166 17 185 109 40 123 79 40 85 18 112 106 87 142 32 19 113 12 131 155 36 149 204 92 237 1 142 195 36 34 134 117 241 52 38 4 223 121 9 207 149 114 168 232 16 31 38 128 191 205 129 96 20 210 13 246 170 175 72 206 132 163 135 42 227 200 61 4 223 65 246 136 48 139 206 95 243 12 78 111 152 17 172 160 235 19 185 107 248 215 171 69 17 108 110 12 143 48 163 35 112 60 104 210 180 61 97 35 132 190 185 52 214 94 137 51 90 103 115 176 108 81 179 254 43 128 230 0 178 229 102 142 136 122 52 213 218 150 93 29 251 227 151 124 220 211 152 14 214 57 253 134 5 216 20 70 142 9 67 253 187 20 45 239 144 60 149 38 118 94 5 240 92 240 11 163 131 39 237 219 228 68 198 176 184 23 155 181 19 149 188 2 73 215 118 95 52 169 186 179 142 106 201 222 98 38 7 72 12 167 242 23 217 58 8 48 98 75 203 68 202 230 50 109 112 231 34 77 8 212 132 34 53 120 195 211 170 209 138 45 25 22 249 200 39 170 102 104 35 23 165 199 0 180 149 231 66 55 227 101 212 227 111 140 202 218 21 211 142 227 95 228 34 59 29 23 212 43 142 132 36 100 19 58 38 124 136 77 192 186 174 111 82 162 61 13 207 31 123 138 16 236 169 94 182 156 137 71 11 3 223 81 146 185 230 164 108 87 82 126 167 121 216 202 201 21 197 50 204 62 46 30 80 245 60 157 124 81 50 79 225 144 130 55 141 182 176 61 62 128 88 105 3 206 168 97 81 180 145 20 211 135 252 195 71 185 42 209 139 98 27 47 3 181 252 89 41 67 246 238 34 71 224 211 65 165 130 115 138 102 130 153 126 248 225 200 42 33 247 34 83 47 161 223 179 49 244 240 108 184 244 229 129 42 34 208 77 62 142 125 57 121 39 2 223 123 75 83 35 184 136 71 228 58 15 61 16 21 111 21 72 84 107 99 66 51 251 47 132 92 62 85 53 197 90 170 118 254 28 232 170 69 119 55 25 30 210 189 113 231 121 214 151 141 218 11 54 90 17 40 94 143 41 72 221 16 204 7 126 200 220 28 157 75 159 142 181 56 44 244 2 206 93 230 121 110 124 181 108 157 161 2 131 121 119 22 99 4 194 228 137 124 193 89 196 239 216 79 206 88 233 84 70 205 120 107 79 1 95 117 198 73 112 207 18 52 174 188 81 59 75 238 227 184 57 166 66 12 188 200 97 251 40 146 239 27 44 6 104 216 90 153 8 161 189 194 32 200 124 180 43 124 169 200 80 238 28 234 114 46 216 243 192 75 180 149 181 215 39 214 64 69 183 205 159 252 238 50 141 132 214 2 245 5 251 219 32 217 37 146 78 226 201 81 209 79 74 174 108 65 49 70 48 31 6 9 42 134 72 134 247 13 1 9 20 49 18 30 16 0 116 0 101 0 115 0 116 0 99 0 101 0 114 0 116 48 35 6 9 42 134 72 134 247 13 1 9 21 49 22 4 20 161 19 18 59 76 168 198 72 97 179 205 74 244 65 111 116 223 140 145 154 48 49 48 33 48 9 6 5 43 14 3 2 26 5 0 4 20 182 216 177 70 221 73 183 142 238 169 97 22 175 148 97 145 207 223 75 54 4 8 178 120 42 60 194 226 96 245 2 2 8 0]! !
!SqueakSSL class methodsFor: 'examples' stamp: 'jmv 6/25/2017 21:27:45' prior: 50895839!
          google: query
	"An example HTTPS query to encrypted.google.com.
	Example:
		SqueakSSL google: 'squeak'.
		SqueakSSL google: 'SqueakSSL'.
	"

	| hostName address socket ssl |

	"Change the host name to try an https request to some other host"
	hostName := 'encrypted.google.com'.

	address := NetNameResolver addressForName: hostName.
	socket := Socket newTCP.

	"Connect the TCP socket"
	socket connectTo: address port: 443.
	socket waitForConnectionFor: 10.

	"Set up SqueakSSL using the convenience APIs"
	ssl := SqueakSSL on: socket.

	["Let SqueakSSL handle the client handshake"
	ssl connect.

	"Verify that the cert is valid"
	ssl certState = 0 ifFalse:[
		self error: 'The certificate is invalid (code: ', ssl certState,')'.
	].

	"If the certificate is valid, make sure we're were we wanted to go"
	(ssl peerName match: hostName) ifFalse:[
		self error: 'Host name mismatch: ', ssl peerName.
	].

	"Send encrypted data"
	ssl sendData:
		'GET /search?q=', query,' HTTP/1.0', String crlfString,
		'Host: ', hostName, String crlfString,
		'Connection: close', String crlfString,
		String crlfString.

	"Wait for the response"
	^String streamContents:[:s|
		[socket isConnected | socket dataAvailable] 
			whileTrue:[s nextPutAll: ssl receiveData]].
	] ensure:[ssl destroy].
! !
!SqueakSSL class methodsFor: 'examples' stamp: 'jmv 6/25/2017 21:31:39' prior: 50895882!
    serverOn: port certName: certName
	"An HTTPS server example. Fires up a listener at the given port such that
	you can point a browser to that https url. Responds with a single line of text
	and closes the listener after the first connection.

		SqueakSSL 
			serverOn: 8443
			certName: 'Internet Widgits Pty'.

		SqueakSSL 
			serverOn: 8443 
			certName: '/home/andreas/certs/testcert.pem'.

	"
	| listener socket ssl |
	"Set up the listener socket"
	listener := Socket newTCP.
	listener listenOn: port backlogSize: 8.
	[socket := listener waitForAcceptFor: 30.
	socket == nil] whileTrue.
	listener destroy.

	"Set up SqueakSSL for the just accepted connection"
	[ssl := SqueakSSL on: socket.

	"The SSL needs the cert name."
	ssl certName: certName.

	"Let SqueakSSL do the server handshake"
	ssl accept.

	"Read out the HTTPS request"
	ssl receiveData.
	
	"And send the response"
	ssl sendData:
		'HTTP/1.0 200 OK', String crlfString,
		'Connection: close', String crlfString,
		'Content-Type: text/plain', String crlfString,
		'Server: SqueakSSL', String crlfString,
		String crlfString,
		'This is a successful SqueakSSL response.'.

	socket close.

	] ensure:[
		ssl destroy.
		socket destroy.
	].! !
!SqueakSSL class methodsFor: 'instance creation' stamp: 'ar 7/16/2010 22:59' prior: 50895923!
          on: aSocket
	"Convenience API. Create a SqueakSSL operating on a standard TCP socket.
	Generally not very useful for real applications (it lacks error handling etc) 
	but very helpful for debugging and other experiments."

	^self new on: aSocket! !
!SqueakSSL class methodsFor: 'instance creation' stamp: 'ar 6/17/2012 11:13' prior: 50895934!
         secureSocket
	"Answer the class to use as secure socket implementation.
	Provided here so that users only need a dependency on SqueakSSL."

	^SecureSocket! !
!SqueakSSL class methodsFor: 'instance creation' stamp: 'ar 6/17/2012 11:25' prior: 50895942!
    secureSocketStream
	"Answer the class to use as secure socket stream implementation.
	Provided here so that users only need a dependency on SqueakSSL."

	^SecureSocketStream! !
!SmallInteger methodsFor: '*WebClient' stamp: 'jmv 9/19/2016 22:04:27' prior: 50895950!
                       numericValue
	"Shouldn't be needed!!"! !
!String methodsFor: '*WebClient' stamp: 'jmv 6/26/2017 19:36:20' prior: 50895954!
     encodeForHTTP! !
!String methodsFor: '*WebClient' stamp: 'jmv 9/5/2016 20:49:10' prior: 50895957!
                              unescapePercents
	"change each %XY substring to the character with ASCII value XY in hex.  This is the opposite of #encodeForHTTP"
	| ans c asciiVal pos oldPos specialChars |
	ans _ WriteStream on: String new.
	oldPos _ 1.
	specialChars _ '+%' asCharacterSet.

	[pos _ self indexOfAnyOf: specialChars startingAt: oldPos ifAbsent: [ 0 ]. pos > 0 ]
	whileTrue: [
		ans nextPutAll: (self copyFrom: oldPos to: pos - 1).
		c _ self at: pos.
		c = $+ ifTrue: [ans nextPut: $ ] ifFalse: [
			(c = $% and: [pos + 2 <= self size]) ifTrue: [
				asciiVal _ (self at: pos+1) asUppercase digitValue * 16 +
					(self at: pos+2) asUppercase digitValue.
				pos _ pos + 2.
				asciiVal > 255 ifTrue: [^self].	"not really an escaped string"
				ans nextPut: (Character numericValue: asciiVal)]
			ifFalse: [ans nextPut: c]].
		oldPos _ pos+1].
	ans nextPutAll: (self copyFrom: oldPos to: self size).
	^ ans contents! !

WebClient initialize!

WebMessage initialize!

----End fileIn of /home/awolfsdorf/Dropbox/CSCOM/IngeSoft1/2021-1c/20-TusLibros/Iteracion 4/WebClient.pck.st----!

Object subclass: #ShopWebClient
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!

!classDefinition: #ShopWebClient category: 'Tus-Libros-Web-Client' stamp: 'AW 7/1/2021 18:07:48'!
Object subclass: #ShopWebClient
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!ShopWebClient methodsFor: 'no messages' stamp: 'AW 7/1/2021 18:08:43' overrides: 16896425!
                            initialize

	! !

self superclass!

self super class!

self class!

self class!

self class superclass !

self class superclass superclass !

self class superclass superclass  superclass !

self class superclass superclass  superclass  superclass !

self class superclass superclass  superclass  superclass  WidgetMorph !

self class superclass superclass  superclass  superclass  superclass  superclass  superclass  superclass  !

self class superclass superclass  superclass  superclass  superclass  superclass  superclass !

self class superclass superclass  superclass  superclass  superclass  superclass !

self class superclass superclass  superclass  superclass  superclass  !

self class superclass superclass  superclass  superclass !

self class superclass superclass  superclass  !

self class superclass superclass  !
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:16:34' prior: 50351895 overrides: 16896425!
              initialize

! !

SystemWindow subclass: #ShopWebClient
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!

!classDefinition: #ShopWebClient category: 'Tus-Libros-Web-Client' stamp: 'AW 7/1/2021 18:16:44'!
SystemWindow subclass: #ShopWebClient
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:18:25' prior: 50351925 overrides: 50559914!
                  initialize

	self setLabel: 'Hola don pepito'.
	self openInWorld.
	! !

ShopWebClient new.!
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:20:28' prior: 50351942 overrides: 50559914!
                initialize

	super initialize.
	self setLabel: 'Hola don pepito'.

	self openInWorld.
	! !

ShopWebClient new.!
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:21:36' prior: 50351949 overrides: 50559914!
                            initialize

	super initialize.
	self setLabel: 'Compre ya sus libros'.

	self openInWorld.
	! !

!classDefinition: #ShopWebClientModel category: 'Tus-Libros-Web-Client' stamp: 'AW 7/1/2021 18:24:21'!
Object subclass: #ShopWebClientModel
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:24:17' prior: 50351957 overrides: 50559914!
                  initialize

	super initialize.
	self setLabel: 'Compre ya sus libros'.
	self model: ShopWebClientModel new.
	self buildShopWindow.
	

	self openInWorld.
	! !

ShopWebClient new.  !
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:25:04'!
                           buildShopWindow
	self shouldBeImplemented.! !
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:33:27' prior: 50351981!
                  buildShopWindow
	
	self layoutMorph 
		beColumn;
		separation: 15;
		axisEdgeWeight: 0;
		addMorph: self build1stRow.! !
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:35:44' prior: 50351986!
       buildShopWindow
	
	self layoutMorph 
		beColumn;
		separation: 15;
		axisEdgeWeight: 0;
		addMorph: self buildUserAndPasswordTextboxRow;
		addMorph: self buildCreateCartButtonRow.! !
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:35:57'!
                         buildUserAndPasswordTextboxRow
	self shouldBeImplemented.! !
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:36:53' prior: 50352002!
   buildUserAndPasswordTextboxRow
	
	
	| layout |
	layout _ LayoutMorph new.
	
	^layout.! !
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:36:58' prior: 50352007!
       buildUserAndPasswordTextboxRow
	| layout |
	
	layout _ LayoutMorph new.
	
	^layout.! !
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:37:36' prior: 50352013!
         buildUserAndPasswordTextboxRow
	| layout |
	
	layout _ LayoutMorph newRow.
	
	^layout.! !
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:37:48'!
                      buildCreateCartButtonRow
	self shouldBeImplemented.! !
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:38:14' prior: 50352025!
         buildCreateCartButtonRow
	| layout |
	
	layout _ LayoutMorph newRow.
	
	
	^layout .! !
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:39:35'!
                         buildCreateCartWindow
	
	self layoutMorph 
		beColumn;
		separation: 15;
		axisEdgeWeight: 0;
		addMorph: self buildUserAndPasswordTextboxRow;
		addMorph: self buildCreateCartButtonRow.! !
!ShopWebClient methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:39:35' prior: 50351972 overrides: 50559914!
               initialize

	super initialize.
	self setLabel: 'Compre ya sus libros'.
	self model: ShopWebClientModel new.
	self buildCreateCartWindow.
	

	self openInWorld.
	! !

!methodRemoval: ShopWebClient #buildShopWindow stamp: 'AW 7/1/2021 18:39:35'!
buildShopWindow
	
	self layoutMorph 
		beColumn;
		separation: 15;
		axisEdgeWeight: 0;
		addMorph: self buildUserAndPasswordTextboxRow;
		addMorph: self buildCreateCartButtonRow.!

!classRenamed: #ShopWebClient as: #CreateCartWindow stamp: 'AW 7/1/2021 18:40:03'!
Smalltalk renameClassNamed: #ShopWebClient as: #CreateCartWindow!

!classRenamed: #ShopWebClientModel as: #CreateCartWindowModel stamp: 'AW 7/1/2021 18:40:13'!
Smalltalk renameClassNamed: #ShopWebClientModel as: #CreateCartWindowModel!
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:40:13' prior: 50352046 overrides: 50559914!
 initialize

	super initialize.
	self setLabel: 'Compre ya sus libros'.
	self model: CreateCartWindowModel new.
	self buildCreateCartWindow.
	

	self openInWorld.
	! !

!classDefinition: #CreateCartWindow category: 'Tus-Libros-Web-Client' stamp: 'AW 7/1/2021 18:45:00'!
SystemWindow subclass: #CreateCartWindow
	instanceVariableNames: 'userNameTextBox'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:45:12' prior: 50352019!
           buildUserAndPasswordTextboxRow
	| layout |
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox
		"addMorph: passwordTextBox;"
		.
	
	
	^layout.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:46:44' prior: 50352090!
                 buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ TextModelMorph
		textProvider: nil.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox
		"addMorph: passwordTextBox;"
		.
	
	
	^layout.! !

CreateCartWindow new. !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:47:36' prior: 50352100!
                               buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ TextModelMorph
		textProvider: self model.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox
		"addMorph: passwordTextBox;"
		.
	
	
	^layout.! !

CreateCartWindow new. !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:51:39' prior: 50352113!
                        buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ TextModelMorph
		textProvider: self model
		textGetter: #userName
		textSetter: #userName:.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox
		"addMorph: passwordTextBox;"
		.
	
	
	^layout.! !

CreateCartWindow new.  !

CreateCartWindow new.  !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:51:55'!
                       userName
	self shouldBeImplemented.! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:52:07' prior: 50352141!
                 userName
	^'Hola mama'! !

CreateCartWindow new.  !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:54:50' prior: 50352126!
         buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ TextModelMorph
		textProvider: self model
		textGetter: #userName
		textSetter: #userName:.
		
	userNameTextBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			userNameTextBox textMorph acceptContents ].
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox
		"addMorph: passwordTextBox;"
		.
	
	
	^layout.! !

CreateCartWindow new.  !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:55:04'!
                     userName: aText 
	self shouldBeImplemented.! !

!classDefinition: #CreateCartWindowModel category: 'Tus-Libros-Web-Client' stamp: 'AW 7/1/2021 18:55:51'!
Object subclass: #CreateCartWindowModel
	instanceVariableNames: 'userName'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/1/2021 18:55:49' prior: 50352169!
 userName: aUsername 
	userName _ aUsername.! !

----QUIT----(1 July 2021 22:01:05) CuisUniversity-4532.image priorSource: 252576!

----STARTUP---- (1 July 2021 22:04:01) as /home/nikita/r/f/isw1/Inge1-ejercicios/20-TusLibros-Iteracion-4/CuisUniversity-4532.image!

!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:07:45' prior: 50352146!
               userName
	^userName! !

CreateCartWindow new.  !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:08:41' overrides: 16896425!
   initialize
	userName _ ''.! !


CreateCartWindow new.  !


CreateCartWindow new.  !


CreateCartWindow new.  !


PluggableMorph new.!


PluggableMorph new.!


PluggableMorph new.!

self openInWorld.!


CreateCartWindow new.  !

!classDefinition: #CreateCartWindow category: 'Tus-Libros-Web-Client' stamp: 'nz 7/1/2021 22:12:39'!
SystemWindow subclass: #CreateCartWindow
	instanceVariableNames: 'userNameTextBox passwordTextBox'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:12:27' prior: 50352151!
                               buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ TextModelMorph
		textProvider: self model
		textGetter: #userName
		textSetter: #userName:.
		
	userNameTextBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			userNameTextBox textMorph acceptContents ].
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:12:54' prior: 50352219!
     buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ TextModelMorph
		textProvider: self model
		textGetter: #userName
		textSetter: #userName:.
		
	userNameTextBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			userNameTextBox textMorph acceptContents ].
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:13:21' prior: 50352236!
     buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ TextModelMorph
		textProvider: self model
		textGetter: #userName
		textSetter: #userName:.
		
	userNameTextBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			userNameTextBox textMorph acceptContents ].
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:13:42'!
                     buildTextBoxMorph

	userNameTextBox _ TextModelMorph
		textProvider: self model
		textGetter: #userName
		textSetter: #userName:.
		
	userNameTextBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			userNameTextBox textMorph acceptContents ]! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:13:42' prior: 50352253!
                             buildUserAndPasswordTextboxRow
	| layout |
	
	self buildTextBoxMorph.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:14:04' prior: 50352270!
                       buildTextBoxMorph

	userNameTextBox _ TextModelMorph
		textProvider: self model
		textGetter: #userName
		textSetter: #userName:.
		
	userNameTextBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			userNameTextBox textMorph acceptContents ]! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:14:29'!
             buildTextBoxMorph: aGetter

	userNameTextBox _ TextModelMorph
		textProvider: self model
		textGetter: #userName
		textSetter: #userName:.
		
	userNameTextBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			userNameTextBox textMorph acceptContents ]! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:14:29' prior: 50352282!
                    buildUserAndPasswordTextboxRow
	| layout |
	
	self buildTextBoxMorph: #userName.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !

!methodRemoval: CreateCartWindow #buildTextBoxMorph stamp: 'nz 7/1/2021 22:14:29'!
buildTextBoxMorph

	userNameTextBox _ TextModelMorph
		textProvider: self model
		textGetter: #userName
		textSetter: #userName:.
		
	userNameTextBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			userNameTextBox textMorph acceptContents ]!
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:14:59'!
          buildTextBoxMorph: aGetter setter: aSetter 

	userNameTextBox _ TextModelMorph
		textProvider: self model
		textGetter: #userName
		textSetter: #userName:.
		
	userNameTextBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			userNameTextBox textMorph acceptContents ]! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:14:59' prior: 50352316!
   buildUserAndPasswordTextboxRow
	| layout |
	
	self buildTextBoxMorph: #userName setter: #userName:.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !

!methodRemoval: CreateCartWindow #buildTextBoxMorph: stamp: 'nz 7/1/2021 22:14:59'!
buildTextBoxMorph: aGetter

	userNameTextBox _ TextModelMorph
		textProvider: self model
		textGetter: #userName
		textSetter: #userName:.
		
	userNameTextBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			userNameTextBox textMorph acceptContents ]!
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:15:19' prior: 50352337!
                             buildTextBoxMorph: aGetter setter: aSetter 

	| textBox |
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
	^textBox.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:15:49' prior: 50352349!
       buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ self buildTextBoxMorph: #userName setter: #userName:.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:16:04' prior: 50352384!
       buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ self buildTextBoxMorph: #userName setter: #userName:.
	passwordTextBox _ self buildTextBoxMorph: #password setter: #password:.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !


CreateCartWindow new.  !


CreateCartWindow new.  !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:16:19'!
                   password
	self shouldBeImplemented.! !

!classDefinition: #CreateCartWindowModel category: 'Tus-Libros-Web-Client' stamp: 'nz 7/1/2021 22:16:26'!
Object subclass: #CreateCartWindowModel
	instanceVariableNames: 'userName password'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:16:24' prior: 50352412!
password
	password! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:16:49' prior: 50352199 overrides: 16896425!
              initialize
	userName _ ''.
	password _ ''.! !


CreateCartWindow new.  !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:17:32' prior: 50352425!
               password
	^ password.! !


CreateCartWindow new.  !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:18:39' prior: 50352372!
         buildTextBoxMorph: aGetter setter: aSetter 

	| textBox |
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
	textBox	
		borderWidth: 1;
		borderColor: Color skyBlue;
		morphWidth: 300.
		
	^textBox.! !


CreateCartWindow new.  !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:19:04' prior: 50352441!
                            buildTextBoxMorph: aGetter setter: aSetter 

	| textBox |
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
	textBox	
		borderWidth: 1;
		borderColor: Color skyBlue;
		morphWidth: 300;
		morphHeight: 20.
		
	^textBox.! !


CreateCartWindow new.  !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:20:06'!
                         withLabel: aLabel buildTextBoxMorph: aGetter setter: aSetter 

	| textBox |
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
	textBox	
		borderWidth: 1;
		borderColor: Color skyBlue;
		morphWidth: 300;
		morphHeight: 20.
		
	^textBox.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:20:06' prior: 50352396!
                  buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ self withLabel: 'asdf' buildTextBoxMorph: #userName setter: #userName:.
	passwordTextBox _ self withLabel: 'asdf' buildTextBoxMorph: #password setter: #password:.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !

!methodRemoval: CreateCartWindow #buildTextBoxMorph:setter: stamp: 'nz 7/1/2021 22:20:06'!
buildTextBoxMorph: aGetter setter: aSetter 

	| textBox |
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
	textBox	
		borderWidth: 1;
		borderColor: Color skyBlue;
		morphWidth: 300;
		morphHeight: 20.
		
	^textBox.!
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:20:28'!
                       buildTextBoxMorphwithLabel: aLabel getter: aGetter setter: aSetter 

	| textBox |
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
	textBox	
		borderWidth: 1;
		borderColor: Color skyBlue;
		morphWidth: 300;
		morphHeight: 20.
		
	^textBox.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:20:28' prior: 50352489!
            buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ self buildTextBoxMorphwithLabel: 'asdf' getter: #userName setter: #userName:.
	passwordTextBox _ self buildTextBoxMorphwithLabel: 'asdf' getter: #password setter: #password:.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !

!methodRemoval: CreateCartWindow #withLabel:buildTextBoxMorph:setter: stamp: 'nz 7/1/2021 22:20:28'!
withLabel: aLabel buildTextBoxMorph: aGetter setter: aSetter 

	| textBox |
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
	textBox	
		borderWidth: 1;
		borderColor: Color skyBlue;
		morphWidth: 300;
		morphHeight: 20.
		
	^textBox.!
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:20:46' prior: 50352535!
                               buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ self buildTextBoxMorphwithLabel: 'User Name' getter: #userName setter: #userName:.
	passwordTextBox _ self buildTextBoxMorphwithLabel: 'Password' getter: #password setter: #password:.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:21:06' prior: 50352567!
     buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ self
		buildTextBoxMorphwithLabel: 'User Name'
		getter: #userName
		setter: #userName:.
	passwordTextBox _ self
		buildTextBoxMorphwithLabel: 'Password'
		getter: #password
		setter: #password:.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:21:09' prior: 50352583!
                         buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ self
		buildTextBoxMorphwithLabel: 'User Name'
		getter: #userName
		setter: #userName:.
		
	passwordTextBox _ self
		buildTextBoxMorphwithLabel: 'Password'
		getter: #password
		setter: #password:.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:23:03' prior: 50352600!
                      buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ self
		buildTextBoxMorphwithLabel: 'User Name'
		getter: #userName
		setter: #userName:.
		
	passwordTextBox _ self
		buildTextBoxMorphwithLabel: 'Password'
		getter: #password
		setter: #password:.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:23:48' prior: 50352519!
                      buildTextBoxMorphwithLabel: aLabel getter: aGetter setter: aSetter 

	| textBox |
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
	textBox	
		borderWidth: 1;
		borderColor: Color skyBlue;
		morphWidth: 300;
		morphHeight: 20.
	textBox label: aLabel.
		
	^textBox.! !


CreateCartWindow new.  !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:24:04' prior: 50352634!
                         buildTextBoxMorphwithLabel: aLabel getter: aGetter setter: aSetter 

	| textBox |
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
	textBox	
		borderWidth: 1;
		borderColor: Color skyBlue;
		morphWidth: 300;
		morphHeight: 20.
		
		
	^textBox.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:24:59' prior: 50352652!
         buildTextBoxMorphwithLabel: aLabel getter: aGetter setter: aSetter 

	| textBox |
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
		
	textBox
		borderWidth: 1;
		borderColor: Color skyBlue;
		morphWidth: 300;
		morphHeight: 20.
		
		
	^textBox.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:27:44' prior: 50352668!
       buildTextBoxMorphwithLabel: aLabel getter: aGetter setter: aSetter 

	| textBox firstRowLayoutMorph |
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
		
	textBox
		borderWidth: 1;
		borderColor: Color skyBlue;
		morphWidth: 300;
		morphHeight: 20.
		
	firstRowLayoutMorph _ LayoutMorph newRow.
	firstRowLayoutMorph
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: (LabelMorph contents: aLabel);
		addMorph: textBox.
	^ firstRowLayoutMorph.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:27:51' prior: 50352684!
buildTextBoxMorphwithLabel: aLabel getter: aGetter setter: aSetter 

	| textBox layout |
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
		
	textBox
		borderWidth: 1;
		borderColor: Color skyBlue;
		morphWidth: 300;
		morphHeight: 20.
		
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: (LabelMorph contents: aLabel);
		addMorph: textBox.
	^ layout.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:27:57' prior: 50352706!
                    buildTextBoxMorphwithLabel: aLabel getter: aGetter setter: aSetter 
	| textBox layout |
	
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
		
	textBox
		borderWidth: 1;
		borderColor: Color skyBlue;
		morphWidth: 300;
		morphHeight: 20.
		
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: (LabelMorph contents: aLabel);
		addMorph: textBox.
	^ layout.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:28:23'!
   buildTextBoxMorphWithLabel: aLabel getter: aGetter setter: aSetter 
	| textBox layout |
	
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
		
	textBox
		borderWidth: 1;
		borderColor: Color skyBlue;
		morphWidth: 300;
		morphHeight: 20.
		
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: (LabelMorph contents: aLabel);
		addMorph: textBox.
	^ layout.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:28:23' prior: 50352617!
                   buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ self
		buildTextBoxMorphWithLabel: 'User Name'
		getter: #userName
		setter: #userName:.
		
	passwordTextBox _ self
		buildTextBoxMorphWithLabel: 'Password'
		getter: #password
		setter: #password:.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		.
	
	
	^layout.! !

!methodRemoval: CreateCartWindow #buildTextBoxMorphwithLabel:getter:setter: stamp: 'nz 7/1/2021 22:28:23'!
buildTextBoxMorphwithLabel: aLabel getter: aGetter setter: aSetter 
	| textBox layout |
	
	textBox _ TextModelMorph
		textProvider: self model
		textGetter: aGetter
		textSetter: aSetter.
		
	textBox textMorph
		setProperty: #keyStroke:
		toValue: [ :key |
			textBox textMorph acceptContents ].
		
	textBox
		borderWidth: 1;
		borderColor: Color skyBlue;
		morphWidth: 300;
		morphHeight: 20.
		
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: (LabelMorph contents: aLabel);
		addMorph: textBox.
	^ layout.!


CreateCartWindow new.  !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:29:31' prior: 50352768!
       buildUserAndPasswordTextboxRow
	| layout |
	
	userNameTextBox _ self
		buildTextBoxMorphWithLabel: 'User Name'
		getter: #userName
		setter: #userName:.
		
	passwordTextBox _ self
		buildTextBoxMorphWithLabel: 'Password'
		getter: #password
		setter: #password:.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: userNameTextBox;
		addMorph: passwordTextBox.
		
	
	
	^layout.! !


CreateCartWindow new.  !

!classDefinition: #CreateCartWindow category: 'Tus-Libros-Web-Client' stamp: 'nz 7/1/2021 22:31:16'!
SystemWindow subclass: #CreateCartWindow
	instanceVariableNames: 'userNameTextBox passwordTextBox createCartButton'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:31:13' prior: 50352030!
                buildCreateCartButtonRow
	| layout |
	
	createCartButton _ PluggableButtonMorph
		model: self model
		stateGetter: nil
		action: #createCartRequest
		label: 'Create Cart'.
	
	layout _ LayoutMorph newRow.
	layout
		separation: 25;
		axisEdgeWeight: 0.5;
		addMorph: createCartButton.
	^layout .! !


CreateCartWindow new.  !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:31:46'!
    createCartRequest
	self shouldBeImplemented.! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:31:49' prior: 50352846!
        createCartRequest
	! !


CreateCartWindow new.  !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:32:27' prior: 50352851!
      createCartRequest
	
	self inspect! !


CreateCartWindow new.  !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:32:46'!
        password: aText 
	self shouldBeImplemented.
	password _ aText! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:32:51' prior: 50352861!
                       password: aText 
	password _ aText! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:45:47' prior: 50352073 overrides: 50559914!
   initialize

	super initialize.
	self setLabel: 'Compre ya sus libros'.
	self model: CreateCartWindowModel new.
	self buildCreateCartWindow.
	
	self openInWorld.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:46:05' prior: 50352872 overrides: 50559914!
     initialize

	super initialize.
	self setLabel: 'Cree su carrito'.
	self model: CreateCartWindowModel new.
	self buildCreateCartWindow.
	
	self openInWorld.! !


TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.!

!classDefinition: #TusLibrosClient category: 'Tus-Libros-Web-Client' stamp: 'nz 7/1/2021 22:51:55'!
Object subclass: #TusLibrosClient
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:51:44' prior: 50352856!
       createCartRequest
	
	| tusLibrosClient |
	tusLibrosClient := TusLibrosClient new.
	tusLibrosClient createCart: userName password: password.
	! !


CreateCartWindow new.  !
!TusLibrosClient methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 22:54:56'!
  createCart: aText password: aText2 
	self shouldBeImplemented.! !
!TusLibrosClient methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 23:00:12' prior: 50352911!
                            createCart: aClientId password: aPassword 

	| fieldDict resp |
	fieldDict _ Dictionary new.
	fieldDict at: 'clientId' put: aClientId.
	fieldDict at: 'password' put: aPassword.
	resp _ WebClient
		htmlSubmit: self url, '/createCart'
		fields: fieldDict.
	resp isSuccess
		ifTrue: [ ^ (WebUtils jsonDecode: resp content readStream) asOrderedCollection ]
		ifFalse: [ ^ self error: resp content ].! !
!TusLibrosClient methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 23:00:18' prior: 50352917!
               createCart: aClientId password: aPassword 

	| fieldDict response |
	fieldDict _ Dictionary new.
	fieldDict at: 'clientId' put: aClientId.
	fieldDict at: 'password' put: aPassword.
	response _ WebClient
		htmlSubmit: self url, '/createCart'
		fields: fieldDict.
	response isSuccess
		ifTrue: [ ^ (WebUtils jsonDecode: response content readStream) asOrderedCollection ]
		ifFalse: [ ^ self error: response content ].! !
!TusLibrosClient methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 23:00:41'!
           url
	self shouldBeImplemented.! !
!TusLibrosClient methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 23:01:06' prior: 50352949!
                            url
	^'http://localhost:8080'! !
!TusLibrosClient methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 23:01:08' prior: 50352954!
                             url
	^'http://localhost:8080'.! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 23:02:23' prior: 50352903!
                      createCartRequest
	
	| tusLibrosClient response |
	tusLibrosClient := TusLibrosClient new.
	response := tusLibrosClient createCart: userName password: password.
	response inspect.! !
!TusLibrosClient methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 23:03:19' prior: 50352933!
       createCart: aClientId password: aPassword 

	| fieldDict response |
	fieldDict _ Dictionary new.
	fieldDict at: 'clientId' put: aClientId.
	fieldDict at: 'password' put: aPassword.
	response _ WebClient
		htmlSubmit: self url, '/createCart'
		fields: fieldDict.
	response isSuccess
		ifTrue: [ ^WebUtils jsonDecode: response content readStream ]
		ifFalse: [ ^ self error: response content ].! !
!TusLibrosClient methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 23:03:20' prior: 50352973!
                  createCart: aClientId password: aPassword 

	| fieldDict response |
	fieldDict _ Dictionary new.
	fieldDict at: 'clientId' put: aClientId.
	fieldDict at: 'password' put: aPassword.
	response _ WebClient
		htmlSubmit: self url, '/createCart'
		fields: fieldDict.
	response isSuccess
		ifTrue: [ ^ WebUtils jsonDecode: response content readStream ]
		ifFalse: [ ^ self error: response content ].! !


CreateCartWindow new.  !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 23:04:09' prior: 50352964!
                createCartRequest
	
	| tusLibrosClient response |
	tusLibrosClient := TusLibrosClient new.
	response := tusLibrosClient createCart: userName password: password.
	self halt.! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'nz 7/1/2021 23:07:07' prior: 50353006!
        createCartRequest
	
	| tusLibrosClient response |
	tusLibrosClient := TusLibrosClient new.
	response := tusLibrosClient createCart: userName password: password.
	
	self halt.
	"
	en el caso de que este ok: 
	- actualizar el modelo (guardarnos el id de carrito)
	- tirar un evento avisando que tenemos un carrito 
	en el caso de que falle:
	- tirar un evento con informacion del error
	
	despues:
	- capturar eventos en la vista y actuar en consecencia
	"! !

----QUIT----(1 July 2021 23:09:12) CuisUniversity-4532.image priorSource: 657134!

----STARTUP---- (6 July 2021 19:06:29) as /home/awolfsdorf/Dropbox/CSCOM/IngeSoft1/Inge1-ejercicios/20-TusLibros-Iteracion-4/CuisUniversity-4532.image!


!classDefinition: #CreateCartWindowModel category: 'Tus-Libros-Web-Client' stamp: 'AW 7/6/2021 19:13:15'!
Object subclass: #CreateCartWindowModel
	instanceVariableNames: 'userName password tusLibrosClien'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:13:14' prior: 50353015!
 createCartRequest
	
	| response |
	response := tusLibrosClien createCart: userName password: password.
	
	self halt.
	"
	en el caso de que este ok: 
	- actualizar el modelo (guardarnos el id de carrito)
	- tirar un evento avisando que tenemos un carrito 
	en el caso de que falle:
	- tirar un evento con informacion del error
	
	despues:
	- capturar eventos en la vista y actuar en consecencia
	"! !

!classDefinition: #CreateCartWindowModel category: 'Tus-Libros-Web-Client' stamp: 'AW 7/6/2021 19:13:23'!
Object subclass: #CreateCartWindowModel
	instanceVariableNames: 'userName password tusLibrosClient'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:13:23' prior: 50353049!
       createCartRequest
	
	| response |
	response := tusLibrosClient createCart: userName password: password.
	
	self halt.
	"
	en el caso de que este ok: 
	- actualizar el modelo (guardarnos el id de carrito)
	- tirar un evento avisando que tenemos un carrito 
	en el caso de que falle:
	- tirar un evento con informacion del error
	
	despues:
	- capturar eventos en la vista y actuar en consecencia
	"! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:13:31' prior: 50352430 overrides: 16896425!
                   initialize
	userName _ ''.
	password _ ''.
	tusLibrosClient := TusLibrosClient new.! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:15:32' prior: 50353074!
 createCartRequest
	
	| response |
	response := tusLibrosClient createCart: userName password: password.
	
	self cart: response.
	
	self halt.
	"
	en el caso de que este ok: 
	- actualizar el modelo (guardarnos el id de carrito)
	- tirar un evento avisando que tenemos un carrito 
	en el caso de que falle:
	- tirar un evento con informacion del error
	
	despues:
	- capturar eventos en la vista y actuar en consecencia
	"! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:15:39' prior: 50353097!
               createCartRequest
	
	| cartId |
	cartId := tusLibrosClient createCart: userName password: password.
	
	self cart: cartId.
	
	self halt.
	"
	en el caso de que este ok: 
	- actualizar el modelo (guardarnos el id de carrito)
	- tirar un evento avisando que tenemos un carrito 
	en el caso de que falle:
	- tirar un evento con informacion del error
	
	despues:
	- capturar eventos en la vista y actuar en consecencia
	"! !
!TusLibrosClient methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:17:23' prior: 50352989!
                           createCart: aClientId password: aPassword 

	| fieldDict response |
	fieldDict _ Dictionary new.
	fieldDict at: 'clientId' put: aClientId.
	fieldDict at: 'password' put: aPassword.
	response _ WebClient
		htmlSubmit: self url, '/createCart'
		fields: fieldDict.
	self halt.
	response isSuccess
		ifTrue: [ ^ WebUtils jsonDecode: response content readStream ]
		ifFalse: [ ^ self error: response content ].! !


CreateCartWindow new.  !

	response content!

	response content readStream !

(WebUtils jsonDecode: response content readStream) at: 'cartId'!
!TusLibrosClient methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:20:01' prior: 50353131!
                    createCart: aClientId password: aPassword 

	| fieldDict response |
	fieldDict _ Dictionary new.
	fieldDict at: 'clientId' put: aClientId.
	fieldDict at: 'password' put: aPassword.
	response _ WebClient
		htmlSubmit: self url, '/createCart'
		fields: fieldDict.
	response isSuccess
		ifTrue: [ ^ (WebUtils jsonDecode: response content readStream) at: 'cartId' ]
		ifFalse: [ ^ self error: response content ].
		
! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:20:17'!
        cart: aSmallInteger 
	self shouldBeImplemented.! !

!classDefinition: #CreateCartWindowModel category: 'Tus-Libros-Web-Client' stamp: 'AW 7/6/2021 19:21:19'!
Object subclass: #CreateCartWindowModel
	instanceVariableNames: 'userName password tusLibrosClient cartID'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:21:17' prior: 50353168!
                             cart: aCartId 
	cartID := aCartId.! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:22:00' prior: 50353114!
                  createCartRequest
	
	self cart: (tusLibrosClient createCart: userName password: password).
	
	self halt.
	"
	en el caso de que este ok: 
	- actualizar el modelo (guardarnos el id de carrito)
	- tirar un evento avisando que tenemos un carrito 
	en el caso de que falle:
	- tirar un evento con informacion del error
	
	despues:
	- capturar eventos en la vista y actuar en consecencia
	"! !

!classDefinition: #CreateCartWindowModel category: 'Tus-Libros-Web-Client' stamp: 'AW 7/6/2021 19:22:09'!
Object subclass: #CreateCartWindowModel
	instanceVariableNames: 'userName password tusLibrosClient cartId'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:22:09' prior: 50353183!
            cart: aCartId 
	cartId := aCartId.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:31:22' prior: 50352881 overrides: 50559914!
   initialize

	super initialize.
	self setLabel: 'Cree su carrito'.
	self model: CreateCartWindowModel new.
	self buildCreateCartWindow.
	
	self model when: #cartCreated send: #navigateToCatalogWindow to: self.
	
	self openInWorld.! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:31:54' prior: 50353188!
               createCartRequest
	
	self cart: (tusLibrosClient createCart: userName password: password).
	
	self cartCreated.
	"
	en el caso de que este ok: 
	- actualizar el modelo (guardarnos el id de carrito)
	- tirar un evento avisando que tenemos un carrito 
	en el caso de que falle:
	- tirar un evento con informacion del error
	
	despues:
	- capturar eventos en la vista y actuar en consecencia
	"! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:32:39' prior: 50353229!
             createCartRequest
	
	self cart: (tusLibrosClient createCart: userName password: password).
	
	self triggerEvent: #cartCreated with: self.
	"
	en el caso de que este ok: 
	- actualizar el modelo (guardarnos el id de carrito)
	- tirar un evento avisando que tenemos un carrito 
	en el caso de que falle:
	- tirar un evento con informacion del error
	
	despues:
	- capturar eventos en la vista y actuar en consecencia
	"! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:34:31' prior: 50353245!
                   createCartRequest
	
	self cart: (tusLibrosClient createCart: userName password: password).
	
	self triggerEvent: self class cartCreatedEvent with: self.
	"
	en el caso de que este ok: 
	- actualizar el modelo (guardarnos el id de carrito)
	- tirar un evento avisando que tenemos un carrito 
	en el caso de que falle:
	- tirar un evento con informacion del error
	
	despues:
	- capturar eventos en la vista y actuar en consecencia
	"! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:35:10' prior: 50353218 overrides: 50559914!
                     initialize

	super initialize.
	self setLabel: 'Cree su carrito'.
	self model: CreateCartWindowModel new.
	self buildCreateCartWindow.
	
	self model when: self model class createdCartEvent send: #navigateToCatalogWindow to: self.
	
	self openInWorld.! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:35:18' prior: 50353280 overrides: 50559914!
           initialize

	super initialize.
	self setLabel: 'Cree su carrito'.
	self model: CreateCartWindowModel new.
	self buildCreateCartWindow.
	
	self model when: self model class cartCreatedEvent send: #navigateToCatalogWindow to: self.
	
	self openInWorld.! !


CreateCartWindow new.  !
!CreateCartWindowModel class methodsFor: 'events' stamp: 'AW 7/6/2021 19:36:13'!
                      cartCreatedEvent
	self shouldBeImplemented.! !
!CreateCartWindowModel class methodsFor: 'events' stamp: 'AW 7/6/2021 19:36:18' prior: 50353304!
                cartCreatedEvent
	^#cartCreated! !
!CreateCartWindow methodsFor: 'navigation' stamp: 'AW 7/6/2021 19:36:42'!
                   navigateToCatalogWindow
	self shouldBeImplemented.! !
!CreateCartWindow methodsFor: 'navigation' stamp: 'AW 7/6/2021 19:36:59' prior: 50353313!
                navigateToCatalogWindow
	
	"
	Hacer algo para movernos a la pantalla de catalogo
	"! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:40:49' prior: 50353262!
 createCartRequest
	[ self cart: (tusLibrosClient createCart: userName password: password).
	  self triggerEvent: self class cartCreatedEvent with: self. ] on: Error
		do: [ self triggerEvent: self class cartCreationErrorEvent ].
		
	"
	en el caso de que este ok: 
	- actualizar el modelo (guardarnos el id de carrito)
	- tirar un evento avisando que tenemos un carrito 
	en el caso de que falle:
	- tirar un evento con informacion del error
	
	despues:
	- capturar eventos en la vista y actuar en consecencia
	"! !
!CreateCartWindowModel methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:41:05' prior: 50353324!
                     createCartRequest
	[ self cart: (tusLibrosClient createCart: userName password: password).
	  self triggerEvent: self class cartCreatedEvent with: self. ] on: Error
		do: [ self triggerEvent: self class cartCreationErrorEvent with: self ].
		
	"
	en el caso de que este ok: 
	- actualizar el modelo (guardarnos el id de carrito)
	- tirar un evento avisando que tenemos un carrito 
	en el caso de que falle:
	- tirar un evento con informacion del error
	
	despues:
	- capturar eventos en la vista y actuar en consecencia
	"! !
!CreateCartWindow methodsFor: 'as yet unclassified' stamp: 'AW 7/6/2021 19:43:16' prior: 50353292 overrides: 50559914!
                           initialize

	super initialize.
	self setLabel: 'Cree su carrito'.
	self model: CreateCartWindowModel new.
	self buildCreateCartWindow.
	
	
	self model when: self model class cartCreatedEvent send: #navigateToCatalogWindow to: self.
	self model when: self model class cartCreationErrorEvent send: #showBadLoginErrorDialog to: self.
	
	self openInWorld.! !


CreateCartWindow new.  !
!CreateCartWindowModel class methodsFor: 'events' stamp: 'AW 7/6/2021 19:43:41'!
                 cartCreationErrorEvent
	self shouldBeImplemented.! !

CreateCartWindow new.  !
!CreateCartWindowModel class methodsFor: 'events' stamp: 'AW 7/6/2021 19:44:33' prior: 50353380!
                cartCreationErrorEvent
	^#cartCreationErrorEvent! !


shopConfiguration _ ShopConfiguration 
		withUserAuthenticator: (stubs mockUserAuthenticatorAlwaysReturning: false)
		prices: stubs priceList
		merchantProcessor: stubs mockAlwaysOkMerchantProcessor
		timeProvider: stubs timeProvider. 
		
TusLibrosRestInterface allInstances do: [ :x | x destroy ].
tusLibrosWebServer _ TusLibrosRestInterface on: 8080 shopConfiguration: shopConfiguration. 
tusLibrosWebServer startListening.
!


CreateCartWindow new.  !
!CreateCartWindow methodsFor: 'dialogs' stamp: 'AW 7/6/2021 19:45:47'!
                            showBadLoginErrorDialog
	self shouldBeImplemented.! !

self contents: 'Hola'!

MinimalStringMorph contents: 'Hola'!

MinimalStringMorph contents: 'Hola'!

MinimalStringMorph contents: 'Hola'!

MinimalStringMorph contents: 'Hola'!

MinimalStringMorph contents: 'Hola'.!

MinimalStringMorph contents: 'Hola'.!

MinimalStringMorph contents: 'Hola'.!

(MinimalStringMorph contents: 'Hola') openInWorld .!

(MinimalStringMorph contents: 'Hola') openInWorld .!

(MinimalStringMorph contents: 'Hola') openInWorld .!

(MinimalStringMorph contents: 'Hola') openInWorld .!

(MinimalStringMorph contents: 'Hola') openInWorld .!

TextModelMorph withText: 'holis'!

(TextModelMorph withText: 'holis') openInWorld !

SystemWindow subclass: #MessageDialogWindow
	instanceVariableNames: 'message'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!

!classDefinition: #MessageDialogWindow category: 'Tus-Libros-Web-Client' stamp: 'AW 7/6/2021 19:55:11'!
SystemWindow subclass: #MessageDialogWindow
	instanceVariableNames: 'message'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!MessageDialogWindow class methodsFor: 'no messages' stamp: 'AW 7/6/2021 19:56:11'!
    message: aMessageText 

	^self new initializeMessage: aMessageText.! !

MessageDialogWindow message: 'holis'!

!classDefinition: #MessageDialogWindow category: 'Tus-Libros-Web-Client' stamp: 'AW 7/6/2021 19:56:56'!
SystemWindow subclass: #MessageDialogWindow
	instanceVariableNames: 'message messageText'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 19:56:56'!
            initializeMessage: aMessageText 
	self shouldBeImplemented.
	messageText := aMessageText.! !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 19:57:01' prior: 50353458!
  initializeMessage: aMessageText 
	
	messageText := aMessageText.! !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 19:57:54' prior: 50353464!
                           initializeMessage: aMessageText 
	
	messageText := aMessageText.
	
	self label: aMessageText.
	
	self openInWorld.! !

	MessageDialogWindow message: 'holis' !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 19:58:30' prior: 50353470!
initializeMessage: aMessageText 
	
	self label: aMessageText.
	
	self openInWorld.! !

SystemWindow subclass: #MessageDialogWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!

!classDefinition: #MessageDialogWindow category: 'Tus-Libros-Web-Client' stamp: 'AW 7/6/2021 19:58:38'!
SystemWindow subclass: #MessageDialogWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 19:58:49' prior: 50353478!
             initializeMessage: aMessageText 
	
	self setLabel: aMessageText.
	
	self openInWorld.! !

	MessageDialogWindow message: 'holis' !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 20:01:49' prior: 50353497!
                             initializeMessage: aMessageText 
	
	self setLabel: aMessageText.
	self morphExtent: self defaultExtent
	self openInWorld.! !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 20:02:05'!
                  defaultExtent
	^200@200! !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 20:02:14' prior: 50353505!
    initializeMessage: aMessageText 
	
	self setLabel: aMessageText.
	self morphExtent: self defaultExtent.
	self openInWorld.
	! !

(MessageDialogWindow message: 'HOlis') openInWorld !

(MessageDialogWindow message: 'HOlis') !

(MessageDialogWindow message: 'HOlis') !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 20:03:11' prior: 50353512!
                     defaultExtent
	^20@20! !

	(MessageDialogWindow message: 'HOlis') !

	self initialExtent !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 20:05:33' overrides: 16926571!
initialExtent 
	self defaultExtent.
	! !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 20:05:38' prior: 50353534 overrides: 16926571!
  initialExtent 
	^self defaultExtent.
	! !

	(MessageDialogWindow message: 'HOlis') !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 20:06:05' prior: 50353539 overrides: 16926571!
                      initialExtent 
	^200@200.
	
! !

	(MessageDialogWindow message: 'HOlis') !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 20:07:10' prior: 50353546 overrides: 16926571!
initialExtent 
	^100@200.
	 
! !

	 (MessageDialogWindow message: 'HOlis') !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 20:07:22' prior: 50353552 overrides: 16926571!
                              initialExtent 
	^200@100.

! !

	 (MessageDialogWindow message: 'HOlis') !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 20:07:56' prior: 50353559 overrides: 16926571!
initialExtent 
	^300@0.


! !

	 (MessageDialogWindow message: 'HOlis') !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 20:08:17' prior: 50353565 overrides: 16926571!
 initialExtent 
	^500@0.


! !

	 (MessageDialogWindow message: 'HOlis') !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'AW 7/6/2021 20:08:29' prior: 50353571 overrides: 16926571!
 initialExtent 
	^500@0.
! !
!CreateCartWindow methodsFor: 'dialogs' stamp: 'AW 7/6/2021 20:09:23' prior: 50353405!
             showBadLoginErrorDialog
	MessageDialogWindow message: 'Login Inválido!!'.! !

CreateCartWindow new.  !

----QUIT----(6 July 2021 20:14:25) CuisUniversity-4532.image priorSource: 684201!

----STARTUP---- (6 July 2021 20:42:53) as /home/nikita/r/f/isw1/Inge1-ejercicios/20-TusLibros-Iteracion-4/CuisUniversity-4532.image!


p := PluggableMorph new.!

p openInWorld!

PluggableMorph subclass: #MessageDialogWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!

!classDefinition: #MessageDialogWindow category: 'Tus-Libros-Web-Client' stamp: 'nz 7/6/2021 20:46:05'!
PluggableMorph subclass: #MessageDialogWindow
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 20:51:50' prior: 50353516!
                   initializeMessage: aMessageText 
	
	self setLabel: aMessageText.
	self morphExtent: self defaultExtent.
	
	self layoutMorph
		beColumn;
		separation: 15;
		axisEdgeWeight: 0;
		addMorph: (LabelMorph contents: aMessageText).
	
	self openInWorld.
	! !

PluggableMorph subclass: #MessageDialogWindow
	instanceVariableNames: 'contentLayout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!

!classDefinition: #MessageDialogWindow category: 'Tus-Libros-Web-Client' stamp: 'nz 7/6/2021 20:58:00'!
PluggableMorph subclass: #MessageDialogWindow
	instanceVariableNames: 'contentLayout'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Tus-Libros-Web-Client'!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 20:59:15' prior: 50353609!
           initializeMessage: aMessageText 
	
	self setLabel: aMessageText.
	self morphExtent: self defaultExtent.
	
	contentLayout _ LayoutMorph newColumn.
	contentLayout
		beColumn;
		separation: 15;
		axisEdgeWeight: 0;
		addMorph: (LabelMorph contents: aMessageText).
	
	self openInWorld.
	! !

p openInWorld!

m _ MessageDialogWindow new.!

m openInWorld.!


CreateCartWindow new.  !


CreateCartWindow new.  !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:28:24' prior: 50353634!
          initializeMessage: aMessageText 
	
	self setLabel: aMessageText.
	self morphExtent: self defaultExtent.
	
	contentLayout _ LayoutMorph newColumn.
	self addMorph: contentLayout.
	contentLayout
		beColumn;
		separation: 15;
		axisEdgeWeight: 0;
		addMorph: (LabelMorph contents: aMessageText).
	
	self openInWorld.
	! !


m _ MessageDialogWindow new.
m openInWorld.!


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:29:08' prior: 50353650!
                      initializeMessage: aMessageText 
	
	self morphExtent: self defaultExtent.
	
	contentLayout _ LayoutMorph newColumn.
	self addMorph: contentLayout.
	contentLayout
		beColumn;
		separation: 15;
		axisEdgeWeight: 0;
		addMorph: (LabelMorph contents: aMessageText).
	
	self openInWorld.
	! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:29:41' prior: 50353577!
   initialExtent 
	^500@100.
! !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:29:44' prior: 50353681!
 initialExtent 
	^300@100.
! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:30:50'!
                     initialExtent_ 
	^300@100.
! !

!methodRemoval: MessageDialogWindow #initialExtent stamp: 'nz 7/6/2021 23:30:50'!
initialExtent 
	^300@100.
!


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:31:09' prior: 50353528!
                     defaultExtent
	^300@100! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!

self color: (Color fromHexString: '#006200')!

self position!

self position!

self extent!

self location!

self location!

self location: (MorphicTranslation withTranslation: 7.0@6.0)  !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:39:28' prior: 50353667!
          initializeMessage: aMessageText 
	
	self morphExtent: self defaultExtent.
	contentLayout _ LayoutMorph newColumn.
	self addMorph: contentLayout.
	contentLayout
		beColumn;
		separation: 15;
		morphExtent: self defaultExtent;
		axisEdgeWeight: 0;
		addMorph: (LabelMorph contents: aMessageText).
	
	self openInWorld.
	! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:40:31' prior: 50353713!
  initializeMessage: aMessageText 
	
	self morphExtent: self defaultExtent.
	
	contentLayout _ LayoutMorph newColumn.
	self addMorph: contentLayout.
	contentLayout
		beColumn;
		separation: 15;
		morphExtent: self defaultExtent;
		axisEdgeWeight: 0;
		addMorph: (LabelMorph contents: aMessageText);
		addMorph: (self buildOkButton).
	
	self openInWorld.
	! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!
!MessageDialogWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/6/2021 23:41:05'!
         buildOkButton
	self shouldBeImplemented.! !
!MessageDialogWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/6/2021 23:41:31' prior: 50353744!
              buildOkButton

	^PluggableButtonMorph
		model: self model
		stateGetter: nil
		action: #close
		label: 'Ok'.
	! !


CreateCartWindow new.  !
!MessageDialogWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/6/2021 23:44:45' prior: 50353749!
             buildOkButton

	^PluggableButtonMorph
		model: self model
		stateGetter: nil
		action: #closeBoxHit
		label: 'Ok'.
	! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!
!MessageDialogWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/6/2021 23:45:42' prior: 50353757!
          buildOkButton

	^PluggableButtonMorph
		model: self
		stateGetter: nil
		action: #closeDialog
		label: 'Ok'.
	! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!
!MessageDialogWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/6/2021 23:46:01'!
                            closeDialog
	self shouldBeImplemented.! !
!MessageDialogWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/6/2021 23:47:03' prior: 50353777!
                closeDialog
	! !
!MessageDialogWindow methodsFor: 'as yet unclassified' stamp: 'nz 7/6/2021 23:48:00' prior: 50353782!
         closeDialog
	self delete.! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!

!methodRemoval: MessageDialogWindow #initialExtent_ stamp: 'nz 7/6/2021 23:48:29'!
initialExtent_ 
	^300@100.
!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:49:13' prior: 50353728!
                         initializeMessage: aMessageText 
	
	self morphExtent: self defaultExtent.
	
	self addMorph: (
		LayoutMorph newColumn
			beColumn;
			separation: 15;
			morphExtent: self defaultExtent;
			axisEdgeWeight: 0;
			addMorph: (LabelMorph contents: aMessageText);
			addMorph: (self buildOkButton);
			yourself
	)
		
	self openInWorld.
	! !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:49:17' prior: 50353798!
                initializeMessage: aMessageText 
	
	self morphExtent: self defaultExtent.
	
	self addMorph: (
		LayoutMorph newColumn
			beColumn;
			separation: 15;
			morphExtent: self defaultExtent;
			axisEdgeWeight: 0;
			addMorph: (LabelMorph contents: aMessageText);
			addMorph: (self buildOkButton);
			yourself
	).
		
	self openInWorld.
	! !
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:49:38' prior: 50353812!
               initializeMessage: aMessageText 
	
	self morphExtent: self defaultExtent.
	
	self addMorph: (
		LayoutMorph newColumn
			beColumn;
			separation: 15;
			morphExtent: self defaultExtent;
			axisEdgeWeight: 0;
			addMorph: (
				LabelMorph contents: aMessageText
			);
			addMorph: (
				self buildOkButton
			);
			yourself
	).
		
	self openInWorld.
	! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.
!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:50:31' prior: 50353826!
initializeMessage: aMessageText 
	
	self morphExtent: self defaultExtent.
	
	self addMorph: (
		LayoutMorph newColumn
			beColumn;
			separation: 15;
			color: (Color fromString: 'white');
			morphExtent: self defaultExtent;
			axisEdgeWeight: 0;
			addMorph: (
				LabelMorph contents: aMessageText
			);
			addMorph: (
				self buildOkButton
			);
			yourself
	).
		
	self openInWorld.
	! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.
!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:51:42' prior: 50353842!
                         initializeMessage: aMessageText 
	
	self morphExtent: self defaultExtent.
	
	self addMorph: (
		LayoutMorph newColumn
			beColumn;
			separation: 15;
			color: (Color fromString: 'palePeach');
			morphExtent: self defaultExtent;
			axisEdgeWeight: 0;
			addMorph: (
				LabelMorph contents: aMessageText
			);
			addMorph: (
				self buildOkButton
			);
			yourself
	).
		
	self openInWorld.
	! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.
!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:52:00' prior: 50353860!
                     initializeMessage: aMessageText 
	
	self morphExtent: self defaultExtent.
	
	self addMorph: (
		LayoutMorph newColumn
			beColumn;
			separation: 15;
			color: (Color fromString: 'lightBlue');
			morphExtent: self defaultExtent;
			axisEdgeWeight: 0;
			addMorph: (
				LabelMorph contents: aMessageText
			);
			addMorph: (
				self buildOkButton
			);
			yourself
	).
		
	self openInWorld.
	! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.
!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:53:21' overrides: 16889446!
                 defaultBorderWidth
	^1! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:56:20' prior: 50353878!
         initializeMessage: aMessageText 
	
	self morphExtent: self defaultExtent.
	
	self addMorph: (
		LayoutMorph newColumn
			beColumn;
			separation: 15;
			color: Color lightBlue;
			borderColor: Color darkGray;
			borderWidth: 2;
			morphExtent: self defaultExtent;
			axisEdgeWeight: 0;
			addMorph: (
				LabelMorph contents: aMessageText
			);
			addMorph: (
				self buildOkButton
			);
			yourself
	).
		
	self openInWorld.
	! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.
!


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.
!

!methodRemoval: MessageDialogWindow #defaultBorderWidth stamp: 'nz 7/6/2021 23:56:59'!
defaultBorderWidth
	^1!


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:57:29' prior: 50353902!
             initializeMessage: aMessageText 
	
	self morphExtent: self defaultExtent.
	
	self addMorph: (
		LayoutMorph newColumn
			beColumn;
			separation: 15;
			color: Color lightBlue;
			borderColor: Color darkGray;
			borderWidth: 2;
			morphExtent: self defaultExtent - 2@2;
			axisEdgeWeight: 0;
			addMorph: (
				LabelMorph contents: aMessageText
			);
			addMorph: (
				self buildOkButton
			);
			yourself
	).
		
	self openInWorld.
	! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:57:50' prior: 50353930!
             initializeMessage: aMessageText 
	
	self morphExtent: self defaultExtent.
	
	self addMorph: (
		LayoutMorph newColumn
			beColumn;
			separation: 15;
			color: Color lightBlue;
			borderColor: Color darkGray;
			borderWidth: 2;
			morphExtent: self defaultExtent - (2@2);
			axisEdgeWeight: 0;
			addMorph: (
				LabelMorph contents: aMessageText
			);
			addMorph: (
				self buildOkButton
			);
			yourself
	).
		
	self openInWorld.
	! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.!
!MessageDialogWindow methodsFor: 'initialization' stamp: 'nz 7/6/2021 23:58:05' prior: 50353949!
               initializeMessage: aMessageText 
	
	self morphExtent: self defaultExtent.
	
	self addMorph: (
		LayoutMorph newColumn
			beColumn;
			separation: 15;
			color: Color lightBlue;
			borderColor: Color darkGray;
			borderWidth: 2;
			morphExtent: self defaultExtent;
			axisEdgeWeight: 0;
			addMorph: (
				LabelMorph contents: aMessageText
			);
			addMorph: (
				self buildOkButton
			);
			yourself
	).
		
	self openInWorld.
	! !


m _ MessageDialogWindow message: 'Holas'.
m openInWorld.
!

----QUIT----(6 July 2021 23:59:24) CuisUniversity-4532.image priorSource: 701958!